// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSTCommandArchives.proto

#ifndef PROTOBUF_TSTCommandArchives_2eproto__INCLUDED
#define PROTOBUF_TSTCommandArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSDArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSCEArchives.pb.h"
#include "TSWPArchives.pb.h"
#include "TSTArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TST {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSTCommandArchives_2eproto();
void protobuf_AssignDesc_TSTCommandArchives_2eproto();
void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

class TableCommandArchive;
class CommandApplyCellDiffArchive;
class CommandChangeFreezeHeaderStateArchive;
class CommandDeleteCellsArchive;
class CommandDeleteCellContentsArchive;
class CommandSetMultipleCellsArchive;
class CommandSetMultipleCellsCustomArchive;
class CommandSetMultipleCellsMultipleChoiceListArchive;
class CommandCoerceMultipleCellsArchive;
class CommandSetControlCellsDisplayNumberFormatArchive;
class CommandSetAutomaticFormatArchive;
class CommandSetAutomaticDurationUnitsArchive;
class CommandReplaceCustomFormatArchive;
class CommandInsertColumnsOrRowsArchive;
class CommandInsertColumnsOrRowsArchive_StyleIndexPair;
class CommandPasteArchive;
class CommandRemoveColumnsOrRowsArchive;
class CommandResizeColumnOrRowArchive;
class CommandSetCellArchive;
class CommandTextPreflightInsertCellArchive;
class CommandPostflightSetCellArchive;
class CommandSetNumberOfHeadersOrFootersArchive;
class CommandFixWPStylesInRowsOrColumnsArchive;
class CommandFixStylesInHeadersOrFootersArchive;
class CommandSetTableNameArchive;
class CommandSetTableNameEnabledArchive;
class CommandSetTableFontSizeArchive;
class CommandSetTableFontNameArchive;
class CommandSetTableNameHeightArchive;
class CommandStyleCellsArchive;
class CommandSetFillPropertyArchive;
class CommandStyleTableArchive;
class CommandFillCellsArchive;
class CommandReplaceTextArchive;
class CommandReplaceAllTextArchive;
class CommandSetRepeatingHeaderEnabledArchive;
class CommandSetFiltersEnabledArchive;
class CommandAddQuickFilterRulesArchive;
class CommandDeleteFilterRulesArchive;
class CommandModifyFilterRuleArchive;
class CommandApplyStrokePresetArchive;
class CommandAddTableStylePresetArchive;
class CommandRemoveTableStylePresetArchive;
class CommandReplaceTableStylePresetArchive;
class CommandApplyTableStylePresetArchive;
class CommandApplyTableStylePresetArchive_StyleIndexTuple;
class CommandSetStyleApplyClearsAllFlagArchive;
class CommandApplyThemeToTableArchive;
class CommandApplyThemeChildForTableArchive;
class CommandToggleTextPropertyArchive;
class CommandResetFillPropertyToDefault;
class CommandSetSingleNumberFormatParameterArchive;
class CommandSetBaseArchive;
class CommandSetBasePlacesArchive;
class CommandSetBaseUseMinusSignArchive;
class CommandSetControlMinimumArchive;
class CommandSetControlMaximumArchive;
class CommandSetControlIncrementArchive;
class CommandSetCurrencyCodeArchive;
class CommandSetFractionAccuracyArchive;
class CommandSetMultipleChoiceListFormatForEditedItemArchive;
class CommandSetMultipleChoiceListFormatForDeleteItemArchive;
class CommandSetMultipleChoiceListFormatForReorderItemArchive;
class CommandSetMultipleChoiceListFormatForInitialValueArchive;
class CommandSetNegativeNumberStyleArchive;
class CommandSetExplicitFormatArchive;
class CommandSetNumberOfDecimalPlacesArchive;
class CommandSetDateTimeFormatArchive;
class CommandSetShowThousandsSeparatorArchive;
class CommandSetUseAccountingStyleArchive;
class CommandMoveRowsArchive;
class CommandMoveColumnsArchive;
class CommandSortArchive;
class CommandRewriteFormulasForSortArchive;
class CommandRewriteFormulasForTectonicShiftArchive;
class CommandRewriteFormulasForMoveArchive;
class CommandRewriteFormulasForCellMergeArchive;
class CommandRewriteFilterFormulasForTableResizeArchive;
class CommandRewriteFilterFormulasForTectonicShiftArchive;
class CommandRewriteFilterFormulasForSortArchive;
class CommandRewriteConditionalStylesForTectonicShiftArchive;
class CommandRewriteConditionalStylesForSortArchive;
class CommandRewriteConditionalStylesForRangeMoveArchive;
class CommandRewriteConditionalStylesForCellMergeArchive;
class CommandMergeUnmergeArchive;
class CommandHideShowArchive;
class TableInfoGeometryCommandArchive;
class FormulaEditingCommandGroupArchive;
class FormulaEditingCommandSelectionBehaviorArchive;
class UndoRedoStateCommandSelectionBehaviorArchive;
class TableCommandSelectionBehaviorArchive;
class DisableTableNameSelectionBehaviorArchive;
class CommandApplyCellCommentArchive;
class CommandApplyConditionalStyleSetArchive;
class CommandSetFormulaTokenizationArchive;
class CommandSetFilterEnabledArchive;
class CommandSetFilterRuleEnabledArchive;
class CommandSetFilterSetTypeArchive;
class CommandSetStyleNetworkArchive;
class CommandMutateCellsArchive;
class CommandDisableFilterRulesForColumnArchive;
class CommandSetTextStyleArchive;
class CommandNotifyForTransformingArchive;
class CommandSetStorageLanguageArchive;
class CommandSetSortOrderArchive;
class CommandRewriteSortOrderForTectonicShiftArchive;
class CommandRewriteSortOrderForSortArchive;
class CommandRewriteSortOrderForTableResizeArchive;

enum CommandDirectionArchive {
  directionRow = 0,
  directionColumn = 1
};
bool CommandDirectionArchive_IsValid(int value);
const CommandDirectionArchive CommandDirectionArchive_MIN = directionRow;
const CommandDirectionArchive CommandDirectionArchive_MAX = directionColumn;
const int CommandDirectionArchive_ARRAYSIZE = CommandDirectionArchive_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandDirectionArchive_descriptor();
inline const ::std::string& CommandDirectionArchive_Name(CommandDirectionArchive value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandDirectionArchive_descriptor(), value);
}
inline bool CommandDirectionArchive_Parse(
    const ::std::string& name, CommandDirectionArchive* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandDirectionArchive>(
    CommandDirectionArchive_descriptor(), name, value);
}
enum CommandRegionArchive {
  bodyRegion = 0,
  headerRowRegion = 1,
  headerColumnRegion = 2,
  footerRowRegion = 3
};
bool CommandRegionArchive_IsValid(int value);
const CommandRegionArchive CommandRegionArchive_MIN = bodyRegion;
const CommandRegionArchive CommandRegionArchive_MAX = footerRowRegion;
const int CommandRegionArchive_ARRAYSIZE = CommandRegionArchive_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandRegionArchive_descriptor();
inline const ::std::string& CommandRegionArchive_Name(CommandRegionArchive value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandRegionArchive_descriptor(), value);
}
inline bool CommandRegionArchive_Parse(
    const ::std::string& name, CommandRegionArchive* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandRegionArchive>(
    CommandRegionArchive_descriptor(), name, value);
}
// ===================================================================

class TableCommandArchive : public ::google::protobuf::Message {
 public:
  TableCommandArchive();
  virtual ~TableCommandArchive();

  TableCommandArchive(const TableCommandArchive& from);

  inline TableCommandArchive& operator=(const TableCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableCommandArchive& default_instance();

  void Swap(TableCommandArchive* other);

  // implements Message ----------------------------------------------

  TableCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableCommandArchive& from);
  void MergeFrom(const TableCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference tableInfo = 1;
  inline bool has_tableinfo() const;
  inline void clear_tableinfo();
  static const int kTableInfoFieldNumber = 1;
  inline const ::TSP::Reference& tableinfo() const;
  inline ::TSP::Reference* mutable_tableinfo();
  inline ::TSP::Reference* release_tableinfo();
  inline void set_allocated_tableinfo(::TSP::Reference* tableinfo);

  // optional string commandname = 2;
  inline bool has_commandname() const;
  inline void clear_commandname();
  static const int kCommandnameFieldNumber = 2;
  inline const ::std::string& commandname() const;
  inline void set_commandname(const ::std::string& value);
  inline void set_commandname(const char* value);
  inline void set_commandname(const char* value, size_t size);
  inline ::std::string* mutable_commandname();
  inline ::std::string* release_commandname();
  inline void set_allocated_commandname(::std::string* commandname);

  // required .TSK.CommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional uint32 editing_mode_at_start = 4;
  inline bool has_editing_mode_at_start() const;
  inline void clear_editing_mode_at_start();
  static const int kEditingModeAtStartFieldNumber = 4;
  inline ::google::protobuf::uint32 editing_mode_at_start() const;
  inline void set_editing_mode_at_start(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.TableCommandArchive)
 private:
  inline void set_has_tableinfo();
  inline void clear_has_tableinfo();
  inline void set_has_commandname();
  inline void clear_has_commandname();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_editing_mode_at_start();
  inline void clear_has_editing_mode_at_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* tableinfo_;
  ::std::string* commandname_;
  ::TSK::CommandArchive* super_;
  ::google::protobuf::uint32 editing_mode_at_start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static TableCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyCellDiffArchive : public ::google::protobuf::Message {
 public:
  CommandApplyCellDiffArchive();
  virtual ~CommandApplyCellDiffArchive();

  CommandApplyCellDiffArchive(const CommandApplyCellDiffArchive& from);

  inline CommandApplyCellDiffArchive& operator=(const CommandApplyCellDiffArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyCellDiffArchive& default_instance();

  void Swap(CommandApplyCellDiffArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyCellDiffArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyCellDiffArchive& from);
  void MergeFrom(const CommandApplyCellDiffArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellRegion cell_region = 2;
  inline bool has_cell_region() const;
  inline void clear_cell_region();
  static const int kCellRegionFieldNumber = 2;
  inline const ::TST::CellRegion& cell_region() const;
  inline ::TST::CellRegion* mutable_cell_region();
  inline ::TST::CellRegion* release_cell_region();
  inline void set_allocated_cell_region(::TST::CellRegion* cell_region);

  // required .TSP.Reference cell_diff = 3;
  inline bool has_cell_diff() const;
  inline void clear_cell_diff();
  static const int kCellDiffFieldNumber = 3;
  inline const ::TSP::Reference& cell_diff() const;
  inline ::TSP::Reference* mutable_cell_diff();
  inline ::TSP::Reference* release_cell_diff();
  inline void set_allocated_cell_diff(::TSP::Reference* cell_diff);

  // required .TSP.Reference inverse_cell_diff_map = 4;
  inline bool has_inverse_cell_diff_map() const;
  inline void clear_inverse_cell_diff_map();
  static const int kInverseCellDiffMapFieldNumber = 4;
  inline const ::TSP::Reference& inverse_cell_diff_map() const;
  inline ::TSP::Reference* mutable_inverse_cell_diff_map();
  inline ::TSP::Reference* release_inverse_cell_diff_map();
  inline void set_allocated_inverse_cell_diff_map(::TSP::Reference* inverse_cell_diff_map);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyCellDiffArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_cell_region();
  inline void clear_has_cell_region();
  inline void set_has_cell_diff();
  inline void clear_has_cell_diff();
  inline void set_has_inverse_cell_diff_map();
  inline void clear_has_inverse_cell_diff_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellRegion* cell_region_;
  ::TSP::Reference* cell_diff_;
  ::TSP::Reference* inverse_cell_diff_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyCellDiffArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandChangeFreezeHeaderStateArchive : public ::google::protobuf::Message {
 public:
  CommandChangeFreezeHeaderStateArchive();
  virtual ~CommandChangeFreezeHeaderStateArchive();

  CommandChangeFreezeHeaderStateArchive(const CommandChangeFreezeHeaderStateArchive& from);

  inline CommandChangeFreezeHeaderStateArchive& operator=(const CommandChangeFreezeHeaderStateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandChangeFreezeHeaderStateArchive& default_instance();

  void Swap(CommandChangeFreezeHeaderStateArchive* other);

  // implements Message ----------------------------------------------

  CommandChangeFreezeHeaderStateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandChangeFreezeHeaderStateArchive& from);
  void MergeFrom(const CommandChangeFreezeHeaderStateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandDirectionArchive direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required bool new_freeze_state = 2;
  inline bool has_new_freeze_state() const;
  inline void clear_new_freeze_state();
  static const int kNewFreezeStateFieldNumber = 2;
  inline bool new_freeze_state() const;
  inline void set_new_freeze_state(bool value);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandChangeFreezeHeaderStateArchive)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_new_freeze_state();
  inline void clear_has_new_freeze_state();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int direction_;
  bool new_freeze_state_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandChangeFreezeHeaderStateArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDeleteCellsArchive : public ::google::protobuf::Message {
 public:
  CommandDeleteCellsArchive();
  virtual ~CommandDeleteCellsArchive();

  CommandDeleteCellsArchive(const CommandDeleteCellsArchive& from);

  inline CommandDeleteCellsArchive& operator=(const CommandDeleteCellsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDeleteCellsArchive& default_instance();

  void Swap(CommandDeleteCellsArchive* other);

  // implements Message ----------------------------------------------

  CommandDeleteCellsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDeleteCellsArchive& from);
  void MergeFrom(const CommandDeleteCellsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellMapArchive redo_map = 4;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required bool invalidate_comments = 5;
  inline bool has_invalidate_comments() const;
  inline void clear_invalidate_comments();
  static const int kInvalidateCommentsFieldNumber = 5;
  inline bool invalidate_comments() const;
  inline void set_invalidate_comments(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandDeleteCellsArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_invalidate_comments();
  inline void clear_has_invalidate_comments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* redo_map_;
  bool invalidate_comments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDeleteCellsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDeleteCellContentsArchive : public ::google::protobuf::Message {
 public:
  CommandDeleteCellContentsArchive();
  virtual ~CommandDeleteCellContentsArchive();

  CommandDeleteCellContentsArchive(const CommandDeleteCellContentsArchive& from);

  inline CommandDeleteCellContentsArchive& operator=(const CommandDeleteCellContentsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDeleteCellContentsArchive& default_instance();

  void Swap(CommandDeleteCellContentsArchive* other);

  // implements Message ----------------------------------------------

  CommandDeleteCellContentsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDeleteCellContentsArchive& from);
  void MergeFrom(const CommandDeleteCellContentsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellMapArchive redo_map = 4;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required bool invalidate_comments = 5;
  inline bool has_invalidate_comments() const;
  inline void clear_invalidate_comments();
  static const int kInvalidateCommentsFieldNumber = 5;
  inline bool invalidate_comments() const;
  inline void set_invalidate_comments(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandDeleteCellContentsArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_invalidate_comments();
  inline void clear_has_invalidate_comments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* redo_map_;
  bool invalidate_comments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDeleteCellContentsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleCellsArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleCellsArchive();
  virtual ~CommandSetMultipleCellsArchive();

  CommandSetMultipleCellsArchive(const CommandSetMultipleCellsArchive& from);

  inline CommandSetMultipleCellsArchive& operator=(const CommandSetMultipleCellsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleCellsArchive& default_instance();

  void Swap(CommandSetMultipleCellsArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleCellsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleCellsArchive& from);
  void MergeFrom(const CommandSetMultipleCellsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // optional .TST.Cell source_cell = 4;
  inline bool has_source_cell() const;
  inline void clear_source_cell();
  static const int kSourceCellFieldNumber = 4;
  inline const ::TST::Cell& source_cell() const;
  inline ::TST::Cell* mutable_source_cell();
  inline ::TST::Cell* release_source_cell();
  inline void set_allocated_source_cell(::TST::Cell* source_cell);

  // optional bool only_if_format_differs = 6;
  inline bool has_only_if_format_differs() const;
  inline void clear_only_if_format_differs();
  static const int kOnlyIfFormatDiffersFieldNumber = 6;
  inline bool only_if_format_differs() const;
  inline void set_only_if_format_differs(bool value);

  // required .TST.TableCommandArchive super = 7;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 7;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleCellsArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_source_cell();
  inline void clear_has_source_cell();
  inline void set_has_only_if_format_differs();
  inline void clear_has_only_if_format_differs();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::Cell* source_cell_;
  ::TST::TableCommandArchive* super_;
  bool only_if_format_differs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleCellsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleCellsCustomArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleCellsCustomArchive();
  virtual ~CommandSetMultipleCellsCustomArchive();

  CommandSetMultipleCellsCustomArchive(const CommandSetMultipleCellsCustomArchive& from);

  inline CommandSetMultipleCellsCustomArchive& operator=(const CommandSetMultipleCellsCustomArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleCellsCustomArchive& default_instance();

  void Swap(CommandSetMultipleCellsCustomArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleCellsCustomArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleCellsCustomArchive& from);
  void MergeFrom(const CommandSetMultipleCellsCustomArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required .TSK.FormatStructArchive cell_format = 4;
  inline bool has_cell_format() const;
  inline void clear_cell_format();
  static const int kCellFormatFieldNumber = 4;
  inline const ::TSK::FormatStructArchive& cell_format() const;
  inline ::TSK::FormatStructArchive* mutable_cell_format();
  inline ::TSK::FormatStructArchive* release_cell_format();
  inline void set_allocated_cell_format(::TSK::FormatStructArchive* cell_format);

  // required .TST.TableCommandArchive super = 7;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 7;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleCellsCustomArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_cell_format();
  inline void clear_has_cell_format();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TSK::FormatStructArchive* cell_format_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleCellsCustomArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleCellsMultipleChoiceListArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleCellsMultipleChoiceListArchive();
  virtual ~CommandSetMultipleCellsMultipleChoiceListArchive();

  CommandSetMultipleCellsMultipleChoiceListArchive(const CommandSetMultipleCellsMultipleChoiceListArchive& from);

  inline CommandSetMultipleCellsMultipleChoiceListArchive& operator=(const CommandSetMultipleCellsMultipleChoiceListArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleCellsMultipleChoiceListArchive& default_instance();

  void Swap(CommandSetMultipleCellsMultipleChoiceListArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleCellsMultipleChoiceListArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleCellsMultipleChoiceListArchive& from);
  void MergeFrom(const CommandSetMultipleCellsMultipleChoiceListArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required .TST.TableCommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleCellsMultipleChoiceListArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandCoerceMultipleCellsArchive : public ::google::protobuf::Message {
 public:
  CommandCoerceMultipleCellsArchive();
  virtual ~CommandCoerceMultipleCellsArchive();

  CommandCoerceMultipleCellsArchive(const CommandCoerceMultipleCellsArchive& from);

  inline CommandCoerceMultipleCellsArchive& operator=(const CommandCoerceMultipleCellsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandCoerceMultipleCellsArchive& default_instance();

  void Swap(CommandCoerceMultipleCellsArchive* other);

  // implements Message ----------------------------------------------

  CommandCoerceMultipleCellsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandCoerceMultipleCellsArchive& from);
  void MergeFrom(const CommandCoerceMultipleCellsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required int32 desired_format = 4;
  inline bool has_desired_format() const;
  inline void clear_desired_format();
  static const int kDesiredFormatFieldNumber = 4;
  inline ::google::protobuf::int32 desired_format() const;
  inline void set_desired_format(::google::protobuf::int32 value);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandCoerceMultipleCellsArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_desired_format();
  inline void clear_has_desired_format();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::TableCommandArchive* super_;
  ::google::protobuf::int32 desired_format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandCoerceMultipleCellsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetControlCellsDisplayNumberFormatArchive : public ::google::protobuf::Message {
 public:
  CommandSetControlCellsDisplayNumberFormatArchive();
  virtual ~CommandSetControlCellsDisplayNumberFormatArchive();

  CommandSetControlCellsDisplayNumberFormatArchive(const CommandSetControlCellsDisplayNumberFormatArchive& from);

  inline CommandSetControlCellsDisplayNumberFormatArchive& operator=(const CommandSetControlCellsDisplayNumberFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetControlCellsDisplayNumberFormatArchive& default_instance();

  void Swap(CommandSetControlCellsDisplayNumberFormatArchive* other);

  // implements Message ----------------------------------------------

  CommandSetControlCellsDisplayNumberFormatArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetControlCellsDisplayNumberFormatArchive& from);
  void MergeFrom(const CommandSetControlCellsDisplayNumberFormatArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetControlCellsDisplayNumberFormatArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetControlCellsDisplayNumberFormatArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetAutomaticFormatArchive : public ::google::protobuf::Message {
 public:
  CommandSetAutomaticFormatArchive();
  virtual ~CommandSetAutomaticFormatArchive();

  CommandSetAutomaticFormatArchive(const CommandSetAutomaticFormatArchive& from);

  inline CommandSetAutomaticFormatArchive& operator=(const CommandSetAutomaticFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetAutomaticFormatArchive& default_instance();

  void Swap(CommandSetAutomaticFormatArchive* other);

  // implements Message ----------------------------------------------

  CommandSetAutomaticFormatArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetAutomaticFormatArchive& from);
  void MergeFrom(const CommandSetAutomaticFormatArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetAutomaticFormatArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetAutomaticFormatArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetAutomaticDurationUnitsArchive : public ::google::protobuf::Message {
 public:
  CommandSetAutomaticDurationUnitsArchive();
  virtual ~CommandSetAutomaticDurationUnitsArchive();

  CommandSetAutomaticDurationUnitsArchive(const CommandSetAutomaticDurationUnitsArchive& from);

  inline CommandSetAutomaticDurationUnitsArchive& operator=(const CommandSetAutomaticDurationUnitsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetAutomaticDurationUnitsArchive& default_instance();

  void Swap(CommandSetAutomaticDurationUnitsArchive* other);

  // implements Message ----------------------------------------------

  CommandSetAutomaticDurationUnitsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetAutomaticDurationUnitsArchive& from);
  void MergeFrom(const CommandSetAutomaticDurationUnitsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive selection = 1;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_map = 2;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 3;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // optional bool automatic_units = 4;
  inline bool has_automatic_units() const;
  inline void clear_automatic_units();
  static const int kAutomaticUnitsFieldNumber = 4;
  inline bool automatic_units() const;
  inline void set_automatic_units(bool value);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetAutomaticDurationUnitsArchive)
 private:
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_automatic_units();
  inline void clear_has_automatic_units();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::TableCommandArchive* super_;
  bool automatic_units_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetAutomaticDurationUnitsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandReplaceCustomFormatArchive : public ::google::protobuf::Message {
 public:
  CommandReplaceCustomFormatArchive();
  virtual ~CommandReplaceCustomFormatArchive();

  CommandReplaceCustomFormatArchive(const CommandReplaceCustomFormatArchive& from);

  inline CommandReplaceCustomFormatArchive& operator=(const CommandReplaceCustomFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReplaceCustomFormatArchive& default_instance();

  void Swap(CommandReplaceCustomFormatArchive* other);

  // implements Message ----------------------------------------------

  CommandReplaceCustomFormatArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReplaceCustomFormatArchive& from);
  void MergeFrom(const CommandReplaceCustomFormatArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellMapArchive undo_map = 1;
  inline bool has_undo_map() const;
  inline void clear_undo_map();
  static const int kUndoMapFieldNumber = 1;
  inline const ::TST::CellMapArchive& undo_map() const;
  inline ::TST::CellMapArchive* mutable_undo_map();
  inline ::TST::CellMapArchive* release_undo_map();
  inline void set_allocated_undo_map(::TST::CellMapArchive* undo_map);

  // required .TST.CellMapArchive redo_map = 2;
  inline bool has_redo_map() const;
  inline void clear_redo_map();
  static const int kRedoMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& redo_map() const;
  inline ::TST::CellMapArchive* mutable_redo_map();
  inline ::TST::CellMapArchive* release_redo_map();
  inline void set_allocated_redo_map(::TST::CellMapArchive* redo_map);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandReplaceCustomFormatArchive)
 private:
  inline void set_has_undo_map();
  inline void clear_has_undo_map();
  inline void set_has_redo_map();
  inline void clear_has_redo_map();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellMapArchive* undo_map_;
  ::TST::CellMapArchive* redo_map_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandReplaceCustomFormatArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandInsertColumnsOrRowsArchive_StyleIndexPair : public ::google::protobuf::Message {
 public:
  CommandInsertColumnsOrRowsArchive_StyleIndexPair();
  virtual ~CommandInsertColumnsOrRowsArchive_StyleIndexPair();

  CommandInsertColumnsOrRowsArchive_StyleIndexPair(const CommandInsertColumnsOrRowsArchive_StyleIndexPair& from);

  inline CommandInsertColumnsOrRowsArchive_StyleIndexPair& operator=(const CommandInsertColumnsOrRowsArchive_StyleIndexPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInsertColumnsOrRowsArchive_StyleIndexPair& default_instance();

  void Swap(CommandInsertColumnsOrRowsArchive_StyleIndexPair* other);

  // implements Message ----------------------------------------------

  CommandInsertColumnsOrRowsArchive_StyleIndexPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInsertColumnsOrRowsArchive_StyleIndexPair& from);
  void MergeFrom(const CommandInsertColumnsOrRowsArchive_StyleIndexPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference style = 1;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 1;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
 private:
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* style_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandInsertColumnsOrRowsArchive_StyleIndexPair* default_instance_;
};
// -------------------------------------------------------------------

class CommandInsertColumnsOrRowsArchive : public ::google::protobuf::Message {
 public:
  CommandInsertColumnsOrRowsArchive();
  virtual ~CommandInsertColumnsOrRowsArchive();

  CommandInsertColumnsOrRowsArchive(const CommandInsertColumnsOrRowsArchive& from);

  inline CommandInsertColumnsOrRowsArchive& operator=(const CommandInsertColumnsOrRowsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInsertColumnsOrRowsArchive& default_instance();

  void Swap(CommandInsertColumnsOrRowsArchive* other);

  // implements Message ----------------------------------------------

  CommandInsertColumnsOrRowsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInsertColumnsOrRowsArchive& from);
  void MergeFrom(const CommandInsertColumnsOrRowsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandInsertColumnsOrRowsArchive_StyleIndexPair StyleIndexPair;

  // accessors -------------------------------------------------------

  // required .TST.CommandDirectionArchive direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required float size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline float size() const;
  inline void set_size(float value);

  // required bool before = 5;
  inline bool has_before() const;
  inline void clear_before();
  static const int kBeforeFieldNumber = 5;
  inline bool before() const;
  inline void set_before(bool value);

  // required uint32 header_count = 11;
  inline bool has_header_count() const;
  inline void clear_header_count();
  static const int kHeaderCountFieldNumber = 11;
  inline ::google::protobuf::uint32 header_count() const;
  inline void set_header_count(::google::protobuf::uint32 value);

  // required uint32 headers_added = 12;
  inline bool has_headers_added() const;
  inline void clear_headers_added();
  static const int kHeadersAddedFieldNumber = 12;
  inline ::google::protobuf::uint32 headers_added() const;
  inline void set_headers_added(::google::protobuf::uint32 value);

  // required uint32 footer_count = 13;
  inline bool has_footer_count() const;
  inline void clear_footer_count();
  static const int kFooterCountFieldNumber = 13;
  inline ::google::protobuf::uint32 footer_count() const;
  inline void set_footer_count(::google::protobuf::uint32 value);

  // required uint32 footers_added = 14;
  inline bool has_footers_added() const;
  inline void clear_footers_added();
  static const int kFootersAddedFieldNumber = 14;
  inline ::google::protobuf::uint32 footers_added() const;
  inline void set_footers_added(::google::protobuf::uint32 value);

  // optional .TSP.Reference row_column_style = 8;
  inline bool has_row_column_style() const;
  inline void clear_row_column_style();
  static const int kRowColumnStyleFieldNumber = 8;
  inline const ::TSP::Reference& row_column_style() const;
  inline ::TSP::Reference* mutable_row_column_style();
  inline ::TSP::Reference* release_row_column_style();
  inline void set_allocated_row_column_style(::TSP::Reference* row_column_style);

  // optional .TST.CellMapArchive cell_style_redo = 9;
  inline bool has_cell_style_redo() const;
  inline void clear_cell_style_redo();
  static const int kCellStyleRedoFieldNumber = 9;
  inline const ::TST::CellMapArchive& cell_style_redo() const;
  inline ::TST::CellMapArchive* mutable_cell_style_redo();
  inline ::TST::CellMapArchive* release_cell_style_redo();
  inline void set_allocated_cell_style_redo(::TST::CellMapArchive* cell_style_redo);

  // required .TST.TableCommandArchive super = 10;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 10;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.Reference formula_rewrite_command = 15;
  inline bool has_formula_rewrite_command() const;
  inline void clear_formula_rewrite_command();
  static const int kFormulaRewriteCommandFieldNumber = 15;
  inline const ::TSP::Reference& formula_rewrite_command() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command();
  inline ::TSP::Reference* release_formula_rewrite_command();
  inline void set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command);

  // required float width_factor = 16;
  inline bool has_width_factor() const;
  inline void clear_width_factor();
  static const int kWidthFactorFieldNumber = 16;
  inline float width_factor() const;
  inline void set_width_factor(float value);

  // required float height_factor = 17;
  inline bool has_height_factor() const;
  inline void clear_height_factor();
  static const int kHeightFactorFieldNumber = 17;
  inline float height_factor() const;
  inline void set_height_factor(float value);

  // optional bool allow_horizontal_autosize = 18;
  inline bool has_allow_horizontal_autosize() const;
  inline void clear_allow_horizontal_autosize();
  static const int kAllowHorizontalAutosizeFieldNumber = 18;
  inline bool allow_horizontal_autosize() const;
  inline void set_allow_horizontal_autosize(bool value);

  // optional bool inherit_styles = 19;
  inline bool has_inherit_styles() const;
  inline void clear_inherit_styles();
  static const int kInheritStylesFieldNumber = 19;
  inline bool inherit_styles() const;
  inline void set_inherit_styles(bool value);

  // optional bool inherit_formats = 20;
  inline bool has_inherit_formats() const;
  inline void clear_inherit_formats();
  static const int kInheritFormatsFieldNumber = 20;
  inline bool inherit_formats() const;
  inline void set_inherit_formats(bool value);

  // optional bool inherit_formulas = 24;
  inline bool has_inherit_formulas() const;
  inline void clear_inherit_formulas();
  static const int kInheritFormulasFieldNumber = 24;
  inline bool inherit_formulas() const;
  inline void set_inherit_formulas(bool value);

  // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair cell_style_index_pairs = 21;
  inline int cell_style_index_pairs_size() const;
  inline void clear_cell_style_index_pairs();
  static const int kCellStyleIndexPairsFieldNumber = 21;
  inline const ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair& cell_style_index_pairs(int index) const;
  inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* mutable_cell_style_index_pairs(int index);
  inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* add_cell_style_index_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >&
      cell_style_index_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >*
      mutable_cell_style_index_pairs();

  // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair text_style_index_pairs = 22;
  inline int text_style_index_pairs_size() const;
  inline void clear_text_style_index_pairs();
  static const int kTextStyleIndexPairsFieldNumber = 22;
  inline const ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair& text_style_index_pairs(int index) const;
  inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* mutable_text_style_index_pairs(int index);
  inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* add_text_style_index_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >&
      text_style_index_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >*
      mutable_text_style_index_pairs();

  // repeated double sizes = 23;
  inline int sizes_size() const;
  inline void clear_sizes();
  static const int kSizesFieldNumber = 23;
  inline double sizes(int index) const;
  inline void set_sizes(int index, double value);
  inline void add_sizes(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      sizes() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_sizes();

  // @@protoc_insertion_point(class_scope:TST.CommandInsertColumnsOrRowsArchive)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_before();
  inline void clear_has_before();
  inline void set_has_header_count();
  inline void clear_has_header_count();
  inline void set_has_headers_added();
  inline void clear_has_headers_added();
  inline void set_has_footer_count();
  inline void clear_has_footer_count();
  inline void set_has_footers_added();
  inline void clear_has_footers_added();
  inline void set_has_row_column_style();
  inline void clear_has_row_column_style();
  inline void set_has_cell_style_redo();
  inline void clear_has_cell_style_redo();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_formula_rewrite_command();
  inline void clear_has_formula_rewrite_command();
  inline void set_has_width_factor();
  inline void clear_has_width_factor();
  inline void set_has_height_factor();
  inline void clear_has_height_factor();
  inline void set_has_allow_horizontal_autosize();
  inline void clear_has_allow_horizontal_autosize();
  inline void set_has_inherit_styles();
  inline void clear_has_inherit_styles();
  inline void set_has_inherit_formats();
  inline void clear_has_inherit_formats();
  inline void set_has_inherit_formulas();
  inline void clear_has_inherit_formulas();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int direction_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 count_;
  float size_;
  ::google::protobuf::uint32 header_count_;
  ::google::protobuf::uint32 headers_added_;
  ::google::protobuf::uint32 footer_count_;
  ::google::protobuf::uint32 footers_added_;
  ::TSP::Reference* row_column_style_;
  ::TST::CellMapArchive* cell_style_redo_;
  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* formula_rewrite_command_;
  float width_factor_;
  bool before_;
  bool allow_horizontal_autosize_;
  bool inherit_styles_;
  bool inherit_formats_;
  float height_factor_;
  bool inherit_formulas_;
  ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair > cell_style_index_pairs_;
  ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair > text_style_index_pairs_;
  ::google::protobuf::RepeatedField< double > sizes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandInsertColumnsOrRowsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandPasteArchive : public ::google::protobuf::Message {
 public:
  CommandPasteArchive();
  virtual ~CommandPasteArchive();

  CommandPasteArchive(const CommandPasteArchive& from);

  inline CommandPasteArchive& operator=(const CommandPasteArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandPasteArchive& default_instance();

  void Swap(CommandPasteArchive* other);

  // implements Message ----------------------------------------------

  CommandPasteArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandPasteArchive& from);
  void MergeFrom(const CommandPasteArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.SelectionArchive user_selection = 1;
  inline bool has_user_selection() const;
  inline void clear_user_selection();
  static const int kUserSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& user_selection() const;
  inline ::TST::SelectionArchive* mutable_user_selection();
  inline ::TST::SelectionArchive* release_user_selection();
  inline void set_allocated_user_selection(::TST::SelectionArchive* user_selection);

  // required .TST.SelectionArchive final_selection = 2;
  inline bool has_final_selection() const;
  inline void clear_final_selection();
  static const int kFinalSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& final_selection() const;
  inline ::TST::SelectionArchive* mutable_final_selection();
  inline ::TST::SelectionArchive* release_final_selection();
  inline void set_allocated_final_selection(::TST::SelectionArchive* final_selection);

  // required .TST.TiledCellMapArchive undo_cell_map = 3;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 3;
  inline const ::TST::TiledCellMapArchive& undo_cell_map() const;
  inline ::TST::TiledCellMapArchive* mutable_undo_cell_map();
  inline ::TST::TiledCellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::TiledCellMapArchive* undo_cell_map);

  // required .TST.TiledCellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::TiledCellMapArchive& redo_cell_map() const;
  inline ::TST::TiledCellMapArchive* mutable_redo_cell_map();
  inline ::TST::TiledCellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::TiledCellMapArchive* redo_cell_map);

  // optional .TSP.Reference command_undo = 6;
  inline bool has_command_undo() const;
  inline void clear_command_undo();
  static const int kCommandUndoFieldNumber = 6;
  inline const ::TSP::Reference& command_undo() const;
  inline ::TSP::Reference* mutable_command_undo();
  inline ::TSP::Reference* release_command_undo();
  inline void set_allocated_command_undo(::TSP::Reference* command_undo);

  // required bool invalidate_comments = 7;
  inline bool has_invalidate_comments() const;
  inline void clear_invalidate_comments();
  static const int kInvalidateCommentsFieldNumber = 7;
  inline bool invalidate_comments() const;
  inline void set_invalidate_comments(bool value);

  // required .TST.TableCommandArchive super = 11;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 11;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // repeated .TSP.Reference formula_rewrite_commands = 15;
  inline int formula_rewrite_commands_size() const;
  inline void clear_formula_rewrite_commands();
  static const int kFormulaRewriteCommandsFieldNumber = 15;
  inline const ::TSP::Reference& formula_rewrite_commands(int index) const;
  inline ::TSP::Reference* mutable_formula_rewrite_commands(int index);
  inline ::TSP::Reference* add_formula_rewrite_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      formula_rewrite_commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_formula_rewrite_commands();

  // @@protoc_insertion_point(class_scope:TST.CommandPasteArchive)
 private:
  inline void set_has_user_selection();
  inline void clear_has_user_selection();
  inline void set_has_final_selection();
  inline void clear_has_final_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_command_undo();
  inline void clear_has_command_undo();
  inline void set_has_invalidate_comments();
  inline void clear_has_invalidate_comments();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* user_selection_;
  ::TST::SelectionArchive* final_selection_;
  ::TST::TiledCellMapArchive* undo_cell_map_;
  ::TST::TiledCellMapArchive* redo_cell_map_;
  ::TSP::Reference* command_undo_;
  ::TST::TableCommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > formula_rewrite_commands_;
  bool invalidate_comments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandPasteArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRemoveColumnsOrRowsArchive : public ::google::protobuf::Message {
 public:
  CommandRemoveColumnsOrRowsArchive();
  virtual ~CommandRemoveColumnsOrRowsArchive();

  CommandRemoveColumnsOrRowsArchive(const CommandRemoveColumnsOrRowsArchive& from);

  inline CommandRemoveColumnsOrRowsArchive& operator=(const CommandRemoveColumnsOrRowsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRemoveColumnsOrRowsArchive& default_instance();

  void Swap(CommandRemoveColumnsOrRowsArchive* other);

  // implements Message ----------------------------------------------

  CommandRemoveColumnsOrRowsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRemoveColumnsOrRowsArchive& from);
  void MergeFrom(const CommandRemoveColumnsOrRowsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CommandDirectionArchive direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required .TSP.IndexSet indices_to_remove = 3;
  inline bool has_indices_to_remove() const;
  inline void clear_indices_to_remove();
  static const int kIndicesToRemoveFieldNumber = 3;
  inline const ::TSP::IndexSet& indices_to_remove() const;
  inline ::TSP::IndexSet* mutable_indices_to_remove();
  inline ::TSP::IndexSet* release_indices_to_remove();
  inline void set_allocated_indices_to_remove(::TSP::IndexSet* indices_to_remove);

  // optional .TST.CellMapArchive cellMap = 4;
  inline bool has_cellmap() const;
  inline void clear_cellmap();
  static const int kCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& cellmap() const;
  inline ::TST::CellMapArchive* mutable_cellmap();
  inline ::TST::CellMapArchive* release_cellmap();
  inline void set_allocated_cellmap(::TST::CellMapArchive* cellmap);

  // required .TSD.GeometryArchive oldgeom = 5;
  inline bool has_oldgeom() const;
  inline void clear_oldgeom();
  static const int kOldgeomFieldNumber = 5;
  inline const ::TSD::GeometryArchive& oldgeom() const;
  inline ::TSD::GeometryArchive* mutable_oldgeom();
  inline ::TSD::GeometryArchive* release_oldgeom();
  inline void set_allocated_oldgeom(::TSD::GeometryArchive* oldgeom);

  // required .TSD.GeometryArchive newgeom = 6;
  inline bool has_newgeom() const;
  inline void clear_newgeom();
  static const int kNewgeomFieldNumber = 6;
  inline const ::TSD::GeometryArchive& newgeom() const;
  inline ::TSD::GeometryArchive* mutable_newgeom();
  inline ::TSD::GeometryArchive* release_newgeom();
  inline void set_allocated_newgeom(::TSD::GeometryArchive* newgeom);

  // repeated float subsizes = 7;
  inline int subsizes_size() const;
  inline void clear_subsizes();
  static const int kSubsizesFieldNumber = 7;
  inline float subsizes(int index) const;
  inline void set_subsizes(int index, float value);
  inline void add_subsizes(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      subsizes() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_subsizes();

  // optional .TSP.Reference formula_rewrite_command = 8;
  inline bool has_formula_rewrite_command() const;
  inline void clear_formula_rewrite_command();
  static const int kFormulaRewriteCommandFieldNumber = 8;
  inline const ::TSP::Reference& formula_rewrite_command() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command();
  inline ::TSP::Reference* release_formula_rewrite_command();
  inline void set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command);

  // required float width_factor = 9;
  inline bool has_width_factor() const;
  inline void clear_width_factor();
  static const int kWidthFactorFieldNumber = 9;
  inline float width_factor() const;
  inline void set_width_factor(float value);

  // required float height_factor = 10;
  inline bool has_height_factor() const;
  inline void clear_height_factor();
  static const int kHeightFactorFieldNumber = 10;
  inline float height_factor() const;
  inline void set_height_factor(float value);

  // optional bool allow_horizontal_autosize = 11;
  inline bool has_allow_horizontal_autosize() const;
  inline void clear_allow_horizontal_autosize();
  static const int kAllowHorizontalAutosizeFieldNumber = 11;
  inline bool allow_horizontal_autosize() const;
  inline void set_allow_horizontal_autosize(bool value);

  // optional .TSP.Reference undo_merge_map = 12;
  inline bool has_undo_merge_map() const;
  inline void clear_undo_merge_map();
  static const int kUndoMergeMapFieldNumber = 12;
  inline const ::TSP::Reference& undo_merge_map() const;
  inline ::TSP::Reference* mutable_undo_merge_map();
  inline ::TSP::Reference* release_undo_merge_map();
  inline void set_allocated_undo_merge_map(::TSP::Reference* undo_merge_map);

  // optional .TSP.Reference redo_merge_map = 13;
  inline bool has_redo_merge_map() const;
  inline void clear_redo_merge_map();
  static const int kRedoMergeMapFieldNumber = 13;
  inline const ::TSP::Reference& redo_merge_map() const;
  inline ::TSP::Reference* mutable_redo_merge_map();
  inline ::TSP::Reference* release_redo_merge_map();
  inline void set_allocated_redo_merge_map(::TSP::Reference* redo_merge_map);

  // repeated uint32 hiding_actions = 14;
  inline int hiding_actions_size() const;
  inline void clear_hiding_actions();
  static const int kHidingActionsFieldNumber = 14;
  inline ::google::protobuf::uint32 hiding_actions(int index) const;
  inline void set_hiding_actions(int index, ::google::protobuf::uint32 value);
  inline void add_hiding_actions(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hiding_actions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hiding_actions();

  // optional .TSP.Reference orig_filter_set = 15;
  inline bool has_orig_filter_set() const;
  inline void clear_orig_filter_set();
  static const int kOrigFilterSetFieldNumber = 15;
  inline const ::TSP::Reference& orig_filter_set() const;
  inline ::TSP::Reference* mutable_orig_filter_set();
  inline ::TSP::Reference* release_orig_filter_set();
  inline void set_allocated_orig_filter_set(::TSP::Reference* orig_filter_set);

  // repeated .TSP.Reference undo_command_collector = 16;
  inline int undo_command_collector_size() const;
  inline void clear_undo_command_collector();
  static const int kUndoCommandCollectorFieldNumber = 16;
  inline const ::TSP::Reference& undo_command_collector(int index) const;
  inline ::TSP::Reference* mutable_undo_command_collector(int index);
  inline ::TSP::Reference* add_undo_command_collector();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      undo_command_collector() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_undo_command_collector();

  // @@protoc_insertion_point(class_scope:TST.CommandRemoveColumnsOrRowsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_indices_to_remove();
  inline void clear_has_indices_to_remove();
  inline void set_has_cellmap();
  inline void clear_has_cellmap();
  inline void set_has_oldgeom();
  inline void clear_has_oldgeom();
  inline void set_has_newgeom();
  inline void clear_has_newgeom();
  inline void set_has_formula_rewrite_command();
  inline void clear_has_formula_rewrite_command();
  inline void set_has_width_factor();
  inline void clear_has_width_factor();
  inline void set_has_height_factor();
  inline void clear_has_height_factor();
  inline void set_has_allow_horizontal_autosize();
  inline void clear_has_allow_horizontal_autosize();
  inline void set_has_undo_merge_map();
  inline void clear_has_undo_merge_map();
  inline void set_has_redo_merge_map();
  inline void clear_has_redo_merge_map();
  inline void set_has_orig_filter_set();
  inline void clear_has_orig_filter_set();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSP::IndexSet* indices_to_remove_;
  ::TST::CellMapArchive* cellmap_;
  ::TSD::GeometryArchive* oldgeom_;
  int direction_;
  float width_factor_;
  ::TSD::GeometryArchive* newgeom_;
  ::google::protobuf::RepeatedField< float > subsizes_;
  ::TSP::Reference* formula_rewrite_command_;
  float height_factor_;
  bool allow_horizontal_autosize_;
  ::TSP::Reference* undo_merge_map_;
  ::TSP::Reference* redo_merge_map_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hiding_actions_;
  ::TSP::Reference* orig_filter_set_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > undo_command_collector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRemoveColumnsOrRowsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandResizeColumnOrRowArchive : public ::google::protobuf::Message {
 public:
  CommandResizeColumnOrRowArchive();
  virtual ~CommandResizeColumnOrRowArchive();

  CommandResizeColumnOrRowArchive(const CommandResizeColumnOrRowArchive& from);

  inline CommandResizeColumnOrRowArchive& operator=(const CommandResizeColumnOrRowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandResizeColumnOrRowArchive& default_instance();

  void Swap(CommandResizeColumnOrRowArchive* other);

  // implements Message ----------------------------------------------

  CommandResizeColumnOrRowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandResizeColumnOrRowArchive& from);
  void MergeFrom(const CommandResizeColumnOrRowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandDirectionArchive direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required float newsize = 4;
  inline bool has_newsize() const;
  inline void clear_newsize();
  static const int kNewsizeFieldNumber = 4;
  inline float newsize() const;
  inline void set_newsize(float value);

  // optional .TSD.GeometryArchive oldgeom = 5;
  inline bool has_oldgeom() const;
  inline void clear_oldgeom();
  static const int kOldgeomFieldNumber = 5;
  inline const ::TSD::GeometryArchive& oldgeom() const;
  inline ::TSD::GeometryArchive* mutable_oldgeom();
  inline ::TSD::GeometryArchive* release_oldgeom();
  inline void set_allocated_oldgeom(::TSD::GeometryArchive* oldgeom);

  // optional .TSD.GeometryArchive newgeom = 6;
  inline bool has_newgeom() const;
  inline void clear_newgeom();
  static const int kNewgeomFieldNumber = 6;
  inline const ::TSD::GeometryArchive& newgeom() const;
  inline ::TSD::GeometryArchive* mutable_newgeom();
  inline ::TSD::GeometryArchive* release_newgeom();
  inline void set_allocated_newgeom(::TSD::GeometryArchive* newgeom);

  // repeated float subsizes = 7;
  inline int subsizes_size() const;
  inline void clear_subsizes();
  static const int kSubsizesFieldNumber = 7;
  inline float subsizes(int index) const;
  inline void set_subsizes(int index, float value);
  inline void add_subsizes(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      subsizes() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_subsizes();

  // optional float old_default = 8;
  inline bool has_old_default() const;
  inline void clear_old_default();
  static const int kOldDefaultFieldNumber = 8;
  inline float old_default() const;
  inline void set_old_default(float value);

  // optional bool uniformsizes = 9;
  inline bool has_uniformsizes() const;
  inline void clear_uniformsizes();
  static const int kUniformsizesFieldNumber = 9;
  inline bool uniformsizes() const;
  inline void set_uniformsizes(bool value);

  // optional uint32 resizemode = 10;
  inline bool has_resizemode() const;
  inline void clear_resizemode();
  static const int kResizemodeFieldNumber = 10;
  inline ::google::protobuf::uint32 resizemode() const;
  inline void set_resizemode(::google::protobuf::uint32 value);

  // required .TST.TableCommandArchive super = 11;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 11;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandResizeColumnOrRowArchive)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_newsize();
  inline void clear_has_newsize();
  inline void set_has_oldgeom();
  inline void clear_has_oldgeom();
  inline void set_has_newgeom();
  inline void clear_has_newgeom();
  inline void set_has_old_default();
  inline void clear_has_old_default();
  inline void set_has_uniformsizes();
  inline void clear_has_uniformsizes();
  inline void set_has_resizemode();
  inline void clear_has_resizemode();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int direction_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 count_;
  float newsize_;
  ::TSD::GeometryArchive* oldgeom_;
  ::TSD::GeometryArchive* newgeom_;
  ::google::protobuf::RepeatedField< float > subsizes_;
  float old_default_;
  bool uniformsizes_;
  ::TST::TableCommandArchive* super_;
  ::google::protobuf::uint32 resizemode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandResizeColumnOrRowArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetCellArchive : public ::google::protobuf::Message {
 public:
  CommandSetCellArchive();
  virtual ~CommandSetCellArchive();

  CommandSetCellArchive(const CommandSetCellArchive& from);

  inline CommandSetCellArchive& operator=(const CommandSetCellArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetCellArchive& default_instance();

  void Swap(CommandSetCellArchive* other);

  // implements Message ----------------------------------------------

  CommandSetCellArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetCellArchive& from);
  void MergeFrom(const CommandSetCellArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID cellID = 1;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellIDFieldNumber = 1;
  inline const ::TST::CellID& cellid() const;
  inline ::TST::CellID* mutable_cellid();
  inline ::TST::CellID* release_cellid();
  inline void set_allocated_cellid(::TST::CellID* cellid);

  // optional .TST.Cell newcell = 2;
  inline bool has_newcell() const;
  inline void clear_newcell();
  static const int kNewcellFieldNumber = 2;
  inline const ::TST::Cell& newcell() const;
  inline ::TST::Cell* mutable_newcell();
  inline ::TST::Cell* release_newcell();
  inline void set_allocated_newcell(::TST::Cell* newcell);

  // optional .TST.Cell oldcell = 3;
  inline bool has_oldcell() const;
  inline void clear_oldcell();
  static const int kOldcellFieldNumber = 3;
  inline const ::TST::Cell& oldcell() const;
  inline ::TST::Cell* mutable_oldcell();
  inline ::TST::Cell* release_oldcell();
  inline void set_allocated_oldcell(::TST::Cell* oldcell);

  // required .TST.TableCommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional bool post_undo_redo_selection = 6;
  inline bool has_post_undo_redo_selection() const;
  inline void clear_post_undo_redo_selection();
  static const int kPostUndoRedoSelectionFieldNumber = 6;
  inline bool post_undo_redo_selection() const;
  inline void set_post_undo_redo_selection(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetCellArchive)
 private:
  inline void set_has_cellid();
  inline void clear_has_cellid();
  inline void set_has_newcell();
  inline void clear_has_newcell();
  inline void set_has_oldcell();
  inline void clear_has_oldcell();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_post_undo_redo_selection();
  inline void clear_has_post_undo_redo_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* cellid_;
  ::TST::Cell* newcell_;
  ::TST::Cell* oldcell_;
  ::TST::TableCommandArchive* super_;
  bool post_undo_redo_selection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetCellArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandTextPreflightInsertCellArchive : public ::google::protobuf::Message {
 public:
  CommandTextPreflightInsertCellArchive();
  virtual ~CommandTextPreflightInsertCellArchive();

  CommandTextPreflightInsertCellArchive(const CommandTextPreflightInsertCellArchive& from);

  inline CommandTextPreflightInsertCellArchive& operator=(const CommandTextPreflightInsertCellArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandTextPreflightInsertCellArchive& default_instance();

  void Swap(CommandTextPreflightInsertCellArchive* other);

  // implements Message ----------------------------------------------

  CommandTextPreflightInsertCellArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandTextPreflightInsertCellArchive& from);
  void MergeFrom(const CommandTextPreflightInsertCellArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID editing_cellID = 1;
  inline bool has_editing_cellid() const;
  inline void clear_editing_cellid();
  static const int kEditingCellIDFieldNumber = 1;
  inline const ::TST::CellID& editing_cellid() const;
  inline ::TST::CellID* mutable_editing_cellid();
  inline ::TST::CellID* release_editing_cellid();
  inline void set_allocated_editing_cellid(::TST::CellID* editing_cellid);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.Reference coalesced_textcommand = 6;
  inline bool has_coalesced_textcommand() const;
  inline void clear_coalesced_textcommand();
  static const int kCoalescedTextcommandFieldNumber = 6;
  inline const ::TSP::Reference& coalesced_textcommand() const;
  inline ::TSP::Reference* mutable_coalesced_textcommand();
  inline ::TSP::Reference* release_coalesced_textcommand();
  inline void set_allocated_coalesced_textcommand(::TSP::Reference* coalesced_textcommand);

  // optional .TSP.Reference postflightcommand = 8;
  inline bool has_postflightcommand() const;
  inline void clear_postflightcommand();
  static const int kPostflightcommandFieldNumber = 8;
  inline const ::TSP::Reference& postflightcommand() const;
  inline ::TSP::Reference* mutable_postflightcommand();
  inline ::TSP::Reference* release_postflightcommand();
  inline void set_allocated_postflightcommand(::TSP::Reference* postflightcommand);

  // optional bool grouped_with_postflight = 9;
  inline bool has_grouped_with_postflight() const;
  inline void clear_grouped_with_postflight();
  static const int kGroupedWithPostflightFieldNumber = 9;
  inline bool grouped_with_postflight() const;
  inline void set_grouped_with_postflight(bool value);

  // required .TST.Cell editing_cell = 10;
  inline bool has_editing_cell() const;
  inline void clear_editing_cell();
  static const int kEditingCellFieldNumber = 10;
  inline const ::TST::Cell& editing_cell() const;
  inline ::TST::Cell* mutable_editing_cell();
  inline ::TST::Cell* release_editing_cell();
  inline void set_allocated_editing_cell(::TST::Cell* editing_cell);

  // required .TSP.Reference editing_storage = 11;
  inline bool has_editing_storage() const;
  inline void clear_editing_storage();
  static const int kEditingStorageFieldNumber = 11;
  inline const ::TSP::Reference& editing_storage() const;
  inline ::TSP::Reference* mutable_editing_storage();
  inline ::TSP::Reference* release_editing_storage();
  inline void set_allocated_editing_storage(::TSP::Reference* editing_storage);

  // optional uint32 last_column_hit_by_tap = 12;
  inline bool has_last_column_hit_by_tap() const;
  inline void clear_last_column_hit_by_tap();
  static const int kLastColumnHitByTapFieldNumber = 12;
  inline ::google::protobuf::uint32 last_column_hit_by_tap() const;
  inline void set_last_column_hit_by_tap(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandTextPreflightInsertCellArchive)
 private:
  inline void set_has_editing_cellid();
  inline void clear_has_editing_cellid();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_coalesced_textcommand();
  inline void clear_has_coalesced_textcommand();
  inline void set_has_postflightcommand();
  inline void clear_has_postflightcommand();
  inline void set_has_grouped_with_postflight();
  inline void clear_has_grouped_with_postflight();
  inline void set_has_editing_cell();
  inline void clear_has_editing_cell();
  inline void set_has_editing_storage();
  inline void clear_has_editing_storage();
  inline void set_has_last_column_hit_by_tap();
  inline void clear_has_last_column_hit_by_tap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* editing_cellid_;
  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* coalesced_textcommand_;
  ::TSP::Reference* postflightcommand_;
  ::TST::Cell* editing_cell_;
  bool grouped_with_postflight_;
  ::google::protobuf::uint32 last_column_hit_by_tap_;
  ::TSP::Reference* editing_storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandTextPreflightInsertCellArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandPostflightSetCellArchive : public ::google::protobuf::Message {
 public:
  CommandPostflightSetCellArchive();
  virtual ~CommandPostflightSetCellArchive();

  CommandPostflightSetCellArchive(const CommandPostflightSetCellArchive& from);

  inline CommandPostflightSetCellArchive& operator=(const CommandPostflightSetCellArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandPostflightSetCellArchive& default_instance();

  void Swap(CommandPostflightSetCellArchive* other);

  // implements Message ----------------------------------------------

  CommandPostflightSetCellArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandPostflightSetCellArchive& from);
  void MergeFrom(const CommandPostflightSetCellArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID cellID = 1;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellIDFieldNumber = 1;
  inline const ::TST::CellID& cellid() const;
  inline ::TST::CellID* mutable_cellid();
  inline ::TST::CellID* release_cellid();
  inline void set_allocated_cellid(::TST::CellID* cellid);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.Reference childcommandundo = 4;
  inline bool has_childcommandundo() const;
  inline void clear_childcommandundo();
  static const int kChildcommandundoFieldNumber = 4;
  inline const ::TSP::Reference& childcommandundo() const;
  inline ::TSP::Reference* mutable_childcommandundo();
  inline ::TSP::Reference* release_childcommandundo();
  inline void set_allocated_childcommandundo(::TSP::Reference* childcommandundo);

  // required .TST.Cell editing_cell = 6;
  inline bool has_editing_cell() const;
  inline void clear_editing_cell();
  static const int kEditingCellFieldNumber = 6;
  inline const ::TST::Cell& editing_cell() const;
  inline ::TST::Cell* mutable_editing_cell();
  inline ::TST::Cell* release_editing_cell();
  inline void set_allocated_editing_cell(::TST::Cell* editing_cell);

  // required .TST.Cell new_cell = 7;
  inline bool has_new_cell() const;
  inline void clear_new_cell();
  static const int kNewCellFieldNumber = 7;
  inline const ::TST::Cell& new_cell() const;
  inline ::TST::Cell* mutable_new_cell();
  inline ::TST::Cell* release_new_cell();
  inline void set_allocated_new_cell(::TST::Cell* new_cell);

  // required .TSP.Reference editing_storage = 8;
  inline bool has_editing_storage() const;
  inline void clear_editing_storage();
  static const int kEditingStorageFieldNumber = 8;
  inline const ::TSP::Reference& editing_storage() const;
  inline ::TSP::Reference* mutable_editing_storage();
  inline ::TSP::Reference* release_editing_storage();
  inline void set_allocated_editing_storage(::TSP::Reference* editing_storage);

  // optional uint32 last_column_hit_by_tap = 9;
  inline bool has_last_column_hit_by_tap() const;
  inline void clear_last_column_hit_by_tap();
  static const int kLastColumnHitByTapFieldNumber = 9;
  inline ::google::protobuf::uint32 last_column_hit_by_tap() const;
  inline void set_last_column_hit_by_tap(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandPostflightSetCellArchive)
 private:
  inline void set_has_cellid();
  inline void clear_has_cellid();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_childcommandundo();
  inline void clear_has_childcommandundo();
  inline void set_has_editing_cell();
  inline void clear_has_editing_cell();
  inline void set_has_new_cell();
  inline void clear_has_new_cell();
  inline void set_has_editing_storage();
  inline void clear_has_editing_storage();
  inline void set_has_last_column_hit_by_tap();
  inline void clear_has_last_column_hit_by_tap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* cellid_;
  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* childcommandundo_;
  ::TST::Cell* editing_cell_;
  ::TST::Cell* new_cell_;
  ::TSP::Reference* editing_storage_;
  ::google::protobuf::uint32 last_column_hit_by_tap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandPostflightSetCellArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetNumberOfHeadersOrFootersArchive : public ::google::protobuf::Message {
 public:
  CommandSetNumberOfHeadersOrFootersArchive();
  virtual ~CommandSetNumberOfHeadersOrFootersArchive();

  CommandSetNumberOfHeadersOrFootersArchive(const CommandSetNumberOfHeadersOrFootersArchive& from);

  inline CommandSetNumberOfHeadersOrFootersArchive& operator=(const CommandSetNumberOfHeadersOrFootersArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetNumberOfHeadersOrFootersArchive& default_instance();

  void Swap(CommandSetNumberOfHeadersOrFootersArchive* other);

  // implements Message ----------------------------------------------

  CommandSetNumberOfHeadersOrFootersArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetNumberOfHeadersOrFootersArchive& from);
  void MergeFrom(const CommandSetNumberOfHeadersOrFootersArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandRegionArchive region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::TST::CommandRegionArchive region() const;
  inline void set_region(::TST::CommandRegionArchive value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 oldcount = 3;
  inline bool has_oldcount() const;
  inline void clear_oldcount();
  static const int kOldcountFieldNumber = 3;
  inline ::google::protobuf::uint32 oldcount() const;
  inline void set_oldcount(::google::protobuf::uint32 value);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetNumberOfHeadersOrFootersArchive)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_oldcount();
  inline void clear_has_oldcount();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int region_;
  ::google::protobuf::uint32 count_;
  ::TST::TableCommandArchive* super_;
  ::google::protobuf::uint32 oldcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetNumberOfHeadersOrFootersArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandFixWPStylesInRowsOrColumnsArchive : public ::google::protobuf::Message {
 public:
  CommandFixWPStylesInRowsOrColumnsArchive();
  virtual ~CommandFixWPStylesInRowsOrColumnsArchive();

  CommandFixWPStylesInRowsOrColumnsArchive(const CommandFixWPStylesInRowsOrColumnsArchive& from);

  inline CommandFixWPStylesInRowsOrColumnsArchive& operator=(const CommandFixWPStylesInRowsOrColumnsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandFixWPStylesInRowsOrColumnsArchive& default_instance();

  void Swap(CommandFixWPStylesInRowsOrColumnsArchive* other);

  // implements Message ----------------------------------------------

  CommandFixWPStylesInRowsOrColumnsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandFixWPStylesInRowsOrColumnsArchive& from);
  void MergeFrom(const CommandFixWPStylesInRowsOrColumnsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandDirectionArchive direction = 1;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 1;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required .TST.CellMapArchive undo_cell_map = 3;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required uint32 reference_index = 7;
  inline bool has_reference_index() const;
  inline void clear_reference_index();
  static const int kReferenceIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 reference_index() const;
  inline void set_reference_index(::google::protobuf::uint32 value);

  // required bool inherit_styles = 8;
  inline bool has_inherit_styles() const;
  inline void clear_inherit_styles();
  static const int kInheritStylesFieldNumber = 8;
  inline bool inherit_styles() const;
  inline void set_inherit_styles(bool value);

  // optional uint32 count = 9;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 9;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandFixWPStylesInRowsOrColumnsArchive)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_reference_index();
  inline void clear_has_reference_index();
  inline void set_has_inherit_styles();
  inline void clear_has_inherit_styles();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int direction_;
  ::google::protobuf::uint32 index_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::TableCommandArchive* super_;
  ::google::protobuf::uint32 reference_index_;
  bool inherit_styles_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandFixWPStylesInRowsOrColumnsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandFixStylesInHeadersOrFootersArchive : public ::google::protobuf::Message {
 public:
  CommandFixStylesInHeadersOrFootersArchive();
  virtual ~CommandFixStylesInHeadersOrFootersArchive();

  CommandFixStylesInHeadersOrFootersArchive(const CommandFixStylesInHeadersOrFootersArchive& from);

  inline CommandFixStylesInHeadersOrFootersArchive& operator=(const CommandFixStylesInHeadersOrFootersArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandFixStylesInHeadersOrFootersArchive& default_instance();

  void Swap(CommandFixStylesInHeadersOrFootersArchive* other);

  // implements Message ----------------------------------------------

  CommandFixStylesInHeadersOrFootersArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandFixStylesInHeadersOrFootersArchive& from);
  void MergeFrom(const CommandFixStylesInHeadersOrFootersArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandRegionArchive region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::TST::CommandRegionArchive region() const;
  inline void set_region(::TST::CommandRegionArchive value);

  // required uint32 old_number = 2;
  inline bool has_old_number() const;
  inline void clear_old_number();
  static const int kOldNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 old_number() const;
  inline void set_old_number(::google::protobuf::uint32 value);

  // required uint32 new_number = 3;
  inline bool has_new_number() const;
  inline void clear_new_number();
  static const int kNewNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 new_number() const;
  inline void set_new_number(::google::protobuf::uint32 value);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // required .TST.CellMapArchive undo_cell_map = 5;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.TableCommandArchive super = 6;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 6;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.Reference textundo = 7;
  inline bool has_textundo() const;
  inline void clear_textundo();
  static const int kTextundoFieldNumber = 7;
  inline const ::TSP::Reference& textundo() const;
  inline ::TSP::Reference* mutable_textundo();
  inline ::TSP::Reference* release_textundo();
  inline void set_allocated_textundo(::TSP::Reference* textundo);

  // @@protoc_insertion_point(class_scope:TST.CommandFixStylesInHeadersOrFootersArchive)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_old_number();
  inline void clear_has_old_number();
  inline void set_has_new_number();
  inline void clear_has_new_number();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_textundo();
  inline void clear_has_textundo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int region_;
  ::google::protobuf::uint32 old_number_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* textundo_;
  ::google::protobuf::uint32 new_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandFixStylesInHeadersOrFootersArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetTableNameArchive : public ::google::protobuf::Message {
 public:
  CommandSetTableNameArchive();
  virtual ~CommandSetTableNameArchive();

  CommandSetTableNameArchive(const CommandSetTableNameArchive& from);

  inline CommandSetTableNameArchive& operator=(const CommandSetTableNameArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetTableNameArchive& default_instance();

  void Swap(CommandSetTableNameArchive* other);

  // implements Message ----------------------------------------------

  CommandSetTableNameArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetTableNameArchive& from);
  void MergeFrom(const CommandSetTableNameArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string newtablename = 1;
  inline bool has_newtablename() const;
  inline void clear_newtablename();
  static const int kNewtablenameFieldNumber = 1;
  inline const ::std::string& newtablename() const;
  inline void set_newtablename(const ::std::string& value);
  inline void set_newtablename(const char* value);
  inline void set_newtablename(const char* value, size_t size);
  inline ::std::string* mutable_newtablename();
  inline ::std::string* release_newtablename();
  inline void set_allocated_newtablename(::std::string* newtablename);

  // required string oldtablename = 2;
  inline bool has_oldtablename() const;
  inline void clear_oldtablename();
  static const int kOldtablenameFieldNumber = 2;
  inline const ::std::string& oldtablename() const;
  inline void set_oldtablename(const ::std::string& value);
  inline void set_oldtablename(const char* value);
  inline void set_oldtablename(const char* value, size_t size);
  inline ::std::string* mutable_oldtablename();
  inline ::std::string* release_oldtablename();
  inline void set_allocated_oldtablename(::std::string* oldtablename);

  // optional .TSP.Reference newstyle = 3;
  inline bool has_newstyle() const;
  inline void clear_newstyle();
  static const int kNewstyleFieldNumber = 3;
  inline const ::TSP::Reference& newstyle() const;
  inline ::TSP::Reference* mutable_newstyle();
  inline ::TSP::Reference* release_newstyle();
  inline void set_allocated_newstyle(::TSP::Reference* newstyle);

  // optional .TSP.Reference oldstyle = 4;
  inline bool has_oldstyle() const;
  inline void clear_oldstyle();
  static const int kOldstyleFieldNumber = 4;
  inline const ::TSP::Reference& oldstyle() const;
  inline ::TSP::Reference* mutable_oldstyle();
  inline ::TSP::Reference* release_oldstyle();
  inline void set_allocated_oldstyle(::TSP::Reference* oldstyle);

  // required .TST.TableCommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.Reference old_shape_style = 6;
  inline bool has_old_shape_style() const;
  inline void clear_old_shape_style();
  static const int kOldShapeStyleFieldNumber = 6;
  inline const ::TSP::Reference& old_shape_style() const;
  inline ::TSP::Reference* mutable_old_shape_style();
  inline ::TSP::Reference* release_old_shape_style();
  inline void set_allocated_old_shape_style(::TSP::Reference* old_shape_style);

  // optional .TSP.Reference new_shape_style = 7;
  inline bool has_new_shape_style() const;
  inline void clear_new_shape_style();
  static const int kNewShapeStyleFieldNumber = 7;
  inline const ::TSP::Reference& new_shape_style() const;
  inline ::TSP::Reference* mutable_new_shape_style();
  inline ::TSP::Reference* release_new_shape_style();
  inline void set_allocated_new_shape_style(::TSP::Reference* new_shape_style);

  // optional bool old_table_name_border_enabled = 8;
  inline bool has_old_table_name_border_enabled() const;
  inline void clear_old_table_name_border_enabled();
  static const int kOldTableNameBorderEnabledFieldNumber = 8;
  inline bool old_table_name_border_enabled() const;
  inline void set_old_table_name_border_enabled(bool value);

  // optional bool new_table_name_border_enabled = 9;
  inline bool has_new_table_name_border_enabled() const;
  inline void clear_new_table_name_border_enabled();
  static const int kNewTableNameBorderEnabledFieldNumber = 9;
  inline bool new_table_name_border_enabled() const;
  inline void set_new_table_name_border_enabled(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetTableNameArchive)
 private:
  inline void set_has_newtablename();
  inline void clear_has_newtablename();
  inline void set_has_oldtablename();
  inline void clear_has_oldtablename();
  inline void set_has_newstyle();
  inline void clear_has_newstyle();
  inline void set_has_oldstyle();
  inline void clear_has_oldstyle();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_shape_style();
  inline void clear_has_old_shape_style();
  inline void set_has_new_shape_style();
  inline void clear_has_new_shape_style();
  inline void set_has_old_table_name_border_enabled();
  inline void clear_has_old_table_name_border_enabled();
  inline void set_has_new_table_name_border_enabled();
  inline void clear_has_new_table_name_border_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* newtablename_;
  ::std::string* oldtablename_;
  ::TSP::Reference* newstyle_;
  ::TSP::Reference* oldstyle_;
  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* old_shape_style_;
  ::TSP::Reference* new_shape_style_;
  bool old_table_name_border_enabled_;
  bool new_table_name_border_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetTableNameArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetTableNameEnabledArchive : public ::google::protobuf::Message {
 public:
  CommandSetTableNameEnabledArchive();
  virtual ~CommandSetTableNameEnabledArchive();

  CommandSetTableNameEnabledArchive(const CommandSetTableNameEnabledArchive& from);

  inline CommandSetTableNameEnabledArchive& operator=(const CommandSetTableNameEnabledArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetTableNameEnabledArchive& default_instance();

  void Swap(CommandSetTableNameEnabledArchive* other);

  // implements Message ----------------------------------------------

  CommandSetTableNameEnabledArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetTableNameEnabledArchive& from);
  void MergeFrom(const CommandSetTableNameEnabledArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool table_name_enabled = 1;
  inline bool has_table_name_enabled() const;
  inline void clear_table_name_enabled();
  static const int kTableNameEnabledFieldNumber = 1;
  inline bool table_name_enabled() const;
  inline void set_table_name_enabled(bool value);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetTableNameEnabledArchive)
 private:
  inline void set_has_table_name_enabled();
  inline void clear_has_table_name_enabled();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  bool table_name_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetTableNameEnabledArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetTableFontSizeArchive : public ::google::protobuf::Message {
 public:
  CommandSetTableFontSizeArchive();
  virtual ~CommandSetTableFontSizeArchive();

  CommandSetTableFontSizeArchive(const CommandSetTableFontSizeArchive& from);

  inline CommandSetTableFontSizeArchive& operator=(const CommandSetTableFontSizeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetTableFontSizeArchive& default_instance();

  void Swap(CommandSetTableFontSizeArchive* other);

  // implements Message ----------------------------------------------

  CommandSetTableFontSizeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetTableFontSizeArchive& from);
  void MergeFrom(const CommandSetTableFontSizeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required float scale_factor = 9;
  inline bool has_scale_factor() const;
  inline void clear_scale_factor();
  static const int kScaleFactorFieldNumber = 9;
  inline float scale_factor() const;
  inline void set_scale_factor(float value);

  // optional .TST.CellMapArchive undo_cell_map = 5;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // optional .TST.CellMapArchive redo_cell_map = 6;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 6;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // optional bool resize_default_cells = 7;
  inline bool has_resize_default_cells() const;
  inline void clear_resize_default_cells();
  static const int kResizeDefaultCellsFieldNumber = 7;
  inline bool resize_default_cells() const;
  inline void set_resize_default_cells(bool value);

  // optional .TSP.Reference text_undo = 8;
  inline bool has_text_undo() const;
  inline void clear_text_undo();
  static const int kTextUndoFieldNumber = 8;
  inline const ::TSP::Reference& text_undo() const;
  inline ::TSP::Reference* mutable_text_undo();
  inline ::TSP::Reference* release_text_undo();
  inline void set_allocated_text_undo(::TSP::Reference* text_undo);

  // @@protoc_insertion_point(class_scope:TST.CommandSetTableFontSizeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_scale_factor();
  inline void clear_has_scale_factor();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_resize_default_cells();
  inline void clear_has_resize_default_cells();
  inline void set_has_text_undo();
  inline void clear_has_text_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* undo_cell_map_;
  float scale_factor_;
  bool resize_default_cells_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TSP::Reference* text_undo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetTableFontSizeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetTableFontNameArchive : public ::google::protobuf::Message {
 public:
  CommandSetTableFontNameArchive();
  virtual ~CommandSetTableFontNameArchive();

  CommandSetTableFontNameArchive(const CommandSetTableFontNameArchive& from);

  inline CommandSetTableFontNameArchive& operator=(const CommandSetTableFontNameArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetTableFontNameArchive& default_instance();

  void Swap(CommandSetTableFontNameArchive* other);

  // implements Message ----------------------------------------------

  CommandSetTableFontNameArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetTableFontNameArchive& from);
  void MergeFrom(const CommandSetTableFontNameArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required string font_name = 2;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 2;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  inline ::std::string* release_font_name();
  inline void set_allocated_font_name(::std::string* font_name);

  // required string old_font_name = 3;
  inline bool has_old_font_name() const;
  inline void clear_old_font_name();
  static const int kOldFontNameFieldNumber = 3;
  inline const ::std::string& old_font_name() const;
  inline void set_old_font_name(const ::std::string& value);
  inline void set_old_font_name(const char* value);
  inline void set_old_font_name(const char* value, size_t size);
  inline ::std::string* mutable_old_font_name();
  inline ::std::string* release_old_font_name();
  inline void set_allocated_old_font_name(::std::string* old_font_name);

  // optional bool preserve_face = 5;
  inline bool has_preserve_face() const;
  inline void clear_preserve_face();
  static const int kPreserveFaceFieldNumber = 5;
  inline bool preserve_face() const;
  inline void set_preserve_face(bool value);

  // optional .TST.CellMapArchive undo_cell_map = 6;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 6;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // optional .TST.CellMapArchive redo_cell_map = 7;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 7;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // optional .TSP.Reference text_undo = 8;
  inline bool has_text_undo() const;
  inline void clear_text_undo();
  static const int kTextUndoFieldNumber = 8;
  inline const ::TSP::Reference& text_undo() const;
  inline ::TSP::Reference* mutable_text_undo();
  inline ::TSP::Reference* release_text_undo();
  inline void set_allocated_text_undo(::TSP::Reference* text_undo);

  // @@protoc_insertion_point(class_scope:TST.CommandSetTableFontNameArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_old_font_name();
  inline void clear_has_old_font_name();
  inline void set_has_preserve_face();
  inline void clear_has_preserve_face();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_text_undo();
  inline void clear_has_text_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::std::string* font_name_;
  ::std::string* old_font_name_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TSP::Reference* text_undo_;
  bool preserve_face_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetTableFontNameArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetTableNameHeightArchive : public ::google::protobuf::Message {
 public:
  CommandSetTableNameHeightArchive();
  virtual ~CommandSetTableNameHeightArchive();

  CommandSetTableNameHeightArchive(const CommandSetTableNameHeightArchive& from);

  inline CommandSetTableNameHeightArchive& operator=(const CommandSetTableNameHeightArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetTableNameHeightArchive& default_instance();

  void Swap(CommandSetTableNameHeightArchive* other);

  // implements Message ----------------------------------------------

  CommandSetTableNameHeightArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetTableNameHeightArchive& from);
  void MergeFrom(const CommandSetTableNameHeightArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required double old_table_name_height = 2;
  inline bool has_old_table_name_height() const;
  inline void clear_old_table_name_height();
  static const int kOldTableNameHeightFieldNumber = 2;
  inline double old_table_name_height() const;
  inline void set_old_table_name_height(double value);

  // required double new_table_name_height = 3;
  inline bool has_new_table_name_height() const;
  inline void clear_new_table_name_height();
  static const int kNewTableNameHeightFieldNumber = 3;
  inline double new_table_name_height() const;
  inline void set_new_table_name_height(double value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetTableNameHeightArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_table_name_height();
  inline void clear_has_old_table_name_height();
  inline void set_has_new_table_name_height();
  inline void clear_has_new_table_name_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  double old_table_name_height_;
  double new_table_name_height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetTableNameHeightArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandStyleCellsArchive : public ::google::protobuf::Message {
 public:
  CommandStyleCellsArchive();
  virtual ~CommandStyleCellsArchive();

  CommandStyleCellsArchive(const CommandStyleCellsArchive& from);

  inline CommandStyleCellsArchive& operator=(const CommandStyleCellsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandStyleCellsArchive& default_instance();

  void Swap(CommandStyleCellsArchive* other);

  // implements Message ----------------------------------------------

  CommandStyleCellsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandStyleCellsArchive& from);
  void MergeFrom(const CommandStyleCellsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.ReferenceDictionary format_properties = 2;
  inline bool has_format_properties() const;
  inline void clear_format_properties();
  static const int kFormatPropertiesFieldNumber = 2;
  inline const ::TSP::ReferenceDictionary& format_properties() const;
  inline ::TSP::ReferenceDictionary* mutable_format_properties();
  inline ::TSP::ReferenceDictionary* release_format_properties();
  inline void set_allocated_format_properties(::TSP::ReferenceDictionary* format_properties);

  // required .TST.SelectionArchive selection = 3;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 3;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_cell_map = 4;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 5;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // optional .TSP.Reference text_undo = 6;
  inline bool has_text_undo() const;
  inline void clear_text_undo();
  static const int kTextUndoFieldNumber = 6;
  inline const ::TSP::Reference& text_undo() const;
  inline ::TSP::Reference* mutable_text_undo();
  inline ::TSP::Reference* release_text_undo();
  inline void set_allocated_text_undo(::TSP::Reference* text_undo);

  // @@protoc_insertion_point(class_scope:TST.CommandStyleCellsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_format_properties();
  inline void clear_has_format_properties();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_text_undo();
  inline void clear_has_text_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSP::ReferenceDictionary* format_properties_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TSP::Reference* text_undo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandStyleCellsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFillPropertyArchive : public ::google::protobuf::Message {
 public:
  CommandSetFillPropertyArchive();
  virtual ~CommandSetFillPropertyArchive();

  CommandSetFillPropertyArchive(const CommandSetFillPropertyArchive& from);

  inline CommandSetFillPropertyArchive& operator=(const CommandSetFillPropertyArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFillPropertyArchive& default_instance();

  void Swap(CommandSetFillPropertyArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFillPropertyArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFillPropertyArchive& from);
  void MergeFrom(const CommandSetFillPropertyArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSD.FillArchive fill = 2;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 2;
  inline const ::TSD::FillArchive& fill() const;
  inline ::TSD::FillArchive* mutable_fill();
  inline ::TSD::FillArchive* release_fill();
  inline void set_allocated_fill(::TSD::FillArchive* fill);

  // optional .TST.CellFillStandIn cell_fill_stand_in = 3;
  inline bool has_cell_fill_stand_in() const;
  inline void clear_cell_fill_stand_in();
  static const int kCellFillStandInFieldNumber = 3;
  inline const ::TST::CellFillStandIn& cell_fill_stand_in() const;
  inline ::TST::CellFillStandIn* mutable_cell_fill_stand_in();
  inline ::TST::CellFillStandIn* release_cell_fill_stand_in();
  inline void set_allocated_cell_fill_stand_in(::TST::CellFillStandIn* cell_fill_stand_in);

  // required .TST.SelectionArchive selection = 4;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 4;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_cell_map = 5;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 6;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 6;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFillPropertyArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_cell_fill_stand_in();
  inline void clear_has_cell_fill_stand_in();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSD::FillArchive* fill_;
  ::TST::CellFillStandIn* cell_fill_stand_in_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFillPropertyArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandStyleTableArchive : public ::google::protobuf::Message {
 public:
  CommandStyleTableArchive();
  virtual ~CommandStyleTableArchive();

  CommandStyleTableArchive(const CommandStyleTableArchive& from);

  inline CommandStyleTableArchive& operator=(const CommandStyleTableArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandStyleTableArchive& default_instance();

  void Swap(CommandStyleTableArchive* other);

  // implements Message ----------------------------------------------

  CommandStyleTableArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandStyleTableArchive& from);
  void MergeFrom(const CommandStyleTableArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.ReferenceDictionary format_properties = 2;
  inline bool has_format_properties() const;
  inline void clear_format_properties();
  static const int kFormatPropertiesFieldNumber = 2;
  inline const ::TSP::ReferenceDictionary& format_properties() const;
  inline ::TSP::ReferenceDictionary* mutable_format_properties();
  inline ::TSP::ReferenceDictionary* release_format_properties();
  inline void set_allocated_format_properties(::TSP::ReferenceDictionary* format_properties);

  // optional .TSP.Reference old_style = 3;
  inline bool has_old_style() const;
  inline void clear_old_style();
  static const int kOldStyleFieldNumber = 3;
  inline const ::TSP::Reference& old_style() const;
  inline ::TSP::Reference* mutable_old_style();
  inline ::TSP::Reference* release_old_style();
  inline void set_allocated_old_style(::TSP::Reference* old_style);

  // optional .TSP.Reference new_style = 4;
  inline bool has_new_style() const;
  inline void clear_new_style();
  static const int kNewStyleFieldNumber = 4;
  inline const ::TSP::Reference& new_style() const;
  inline ::TSP::Reference* mutable_new_style();
  inline ::TSP::Reference* release_new_style();
  inline void set_allocated_new_style(::TSP::Reference* new_style);

  // @@protoc_insertion_point(class_scope:TST.CommandStyleTableArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_format_properties();
  inline void clear_has_format_properties();
  inline void set_has_old_style();
  inline void clear_has_old_style();
  inline void set_has_new_style();
  inline void clear_has_new_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSP::ReferenceDictionary* format_properties_;
  ::TSP::Reference* old_style_;
  ::TSP::Reference* new_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandStyleTableArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandFillCellsArchive : public ::google::protobuf::Message {
 public:
  CommandFillCellsArchive();
  virtual ~CommandFillCellsArchive();

  CommandFillCellsArchive(const CommandFillCellsArchive& from);

  inline CommandFillCellsArchive& operator=(const CommandFillCellsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandFillCellsArchive& default_instance();

  void Swap(CommandFillCellsArchive* other);

  // implements Message ----------------------------------------------

  CommandFillCellsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandFillCellsArchive& from);
  void MergeFrom(const CommandFillCellsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.SelectionArchive sourceselection = 2;
  inline bool has_sourceselection() const;
  inline void clear_sourceselection();
  static const int kSourceselectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& sourceselection() const;
  inline ::TST::SelectionArchive* mutable_sourceselection();
  inline ::TST::SelectionArchive* release_sourceselection();
  inline void set_allocated_sourceselection(::TST::SelectionArchive* sourceselection);

  // required .TST.CellRange sourcecellrange = 3;
  inline bool has_sourcecellrange() const;
  inline void clear_sourcecellrange();
  static const int kSourcecellrangeFieldNumber = 3;
  inline const ::TST::CellRange& sourcecellrange() const;
  inline ::TST::CellRange* mutable_sourcecellrange();
  inline ::TST::CellRange* release_sourcecellrange();
  inline void set_allocated_sourcecellrange(::TST::CellRange* sourcecellrange);

  // required .TST.CellRange targetcellrange = 4;
  inline bool has_targetcellrange() const;
  inline void clear_targetcellrange();
  static const int kTargetcellrangeFieldNumber = 4;
  inline const ::TST::CellRange& targetcellrange() const;
  inline ::TST::CellRange* mutable_targetcellrange();
  inline ::TST::CellRange* release_targetcellrange();
  inline void set_allocated_targetcellrange(::TST::CellRange* targetcellrange);

  // required .TST.CellMapArchive undo_cell_map = 5;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.FillDirectionArchive fillDirection = 6;
  inline bool has_filldirection() const;
  inline void clear_filldirection();
  static const int kFillDirectionFieldNumber = 6;
  inline ::TST::FillDirectionArchive filldirection() const;
  inline void set_filldirection(::TST::FillDirectionArchive value);

  // required .TST.SelectionArchive targetselection = 7;
  inline bool has_targetselection() const;
  inline void clear_targetselection();
  static const int kTargetselectionFieldNumber = 7;
  inline const ::TST::SelectionArchive& targetselection() const;
  inline ::TST::SelectionArchive* mutable_targetselection();
  inline ::TST::SelectionArchive* release_targetselection();
  inline void set_allocated_targetselection(::TST::SelectionArchive* targetselection);

  // required .TST.CellMapArchive redo_cell_map = 8;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 8;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandFillCellsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sourceselection();
  inline void clear_has_sourceselection();
  inline void set_has_sourcecellrange();
  inline void clear_has_sourcecellrange();
  inline void set_has_targetcellrange();
  inline void clear_has_targetcellrange();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_filldirection();
  inline void clear_has_filldirection();
  inline void set_has_targetselection();
  inline void clear_has_targetselection();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* sourceselection_;
  ::TST::CellRange* sourcecellrange_;
  ::TST::CellRange* targetcellrange_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::SelectionArchive* targetselection_;
  ::TST::CellMapArchive* redo_cell_map_;
  int filldirection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandFillCellsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandReplaceTextArchive : public ::google::protobuf::Message {
 public:
  CommandReplaceTextArchive();
  virtual ~CommandReplaceTextArchive();

  CommandReplaceTextArchive(const CommandReplaceTextArchive& from);

  inline CommandReplaceTextArchive& operator=(const CommandReplaceTextArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReplaceTextArchive& default_instance();

  void Swap(CommandReplaceTextArchive* other);

  // implements Message ----------------------------------------------

  CommandReplaceTextArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReplaceTextArchive& from);
  void MergeFrom(const CommandReplaceTextArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CellID cellID = 1;
  inline bool has_cellid() const;
  inline void clear_cellid();
  static const int kCellIDFieldNumber = 1;
  inline const ::TST::CellID& cellid() const;
  inline ::TST::CellID* mutable_cellid();
  inline ::TST::CellID* release_cellid();
  inline void set_allocated_cellid(::TST::CellID* cellid);

  // required .TST.Cell newcell = 2;
  inline bool has_newcell() const;
  inline void clear_newcell();
  static const int kNewcellFieldNumber = 2;
  inline const ::TST::Cell& newcell() const;
  inline ::TST::Cell* mutable_newcell();
  inline ::TST::Cell* release_newcell();
  inline void set_allocated_newcell(::TST::Cell* newcell);

  // required .TST.Cell oldcell = 3;
  inline bool has_oldcell() const;
  inline void clear_oldcell();
  static const int kOldcellFieldNumber = 3;
  inline const ::TST::Cell& oldcell() const;
  inline ::TST::Cell* mutable_oldcell();
  inline ::TST::Cell* release_oldcell();
  inline void set_allocated_oldcell(::TST::Cell* oldcell);

  // required .TST.TableCommandArchive super = 4;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 4;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSP.Reference child_command_undo = 5;
  inline bool has_child_command_undo() const;
  inline void clear_child_command_undo();
  static const int kChildCommandUndoFieldNumber = 5;
  inline const ::TSP::Reference& child_command_undo() const;
  inline ::TSP::Reference* mutable_child_command_undo();
  inline ::TSP::Reference* release_child_command_undo();
  inline void set_allocated_child_command_undo(::TSP::Reference* child_command_undo);

  // @@protoc_insertion_point(class_scope:TST.CommandReplaceTextArchive)
 private:
  inline void set_has_cellid();
  inline void clear_has_cellid();
  inline void set_has_newcell();
  inline void clear_has_newcell();
  inline void set_has_oldcell();
  inline void clear_has_oldcell();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_child_command_undo();
  inline void clear_has_child_command_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CellID* cellid_;
  ::TST::Cell* newcell_;
  ::TST::Cell* oldcell_;
  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* child_command_undo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandReplaceTextArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandReplaceAllTextArchive : public ::google::protobuf::Message {
 public:
  CommandReplaceAllTextArchive();
  virtual ~CommandReplaceAllTextArchive();

  CommandReplaceAllTextArchive(const CommandReplaceAllTextArchive& from);

  inline CommandReplaceAllTextArchive& operator=(const CommandReplaceAllTextArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReplaceAllTextArchive& default_instance();

  void Swap(CommandReplaceAllTextArchive* other);

  // implements Message ----------------------------------------------

  CommandReplaceAllTextArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReplaceAllTextArchive& from);
  void MergeFrom(const CommandReplaceAllTextArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference tableInfo = 1;
  inline bool has_tableinfo() const;
  inline void clear_tableinfo();
  static const int kTableInfoFieldNumber = 1;
  inline const ::TSP::Reference& tableinfo() const;
  inline ::TSP::Reference* mutable_tableinfo();
  inline ::TSP::Reference* release_tableinfo();
  inline void set_allocated_tableinfo(::TSP::Reference* tableinfo);

  // required .TST.CellMapArchive undo_cell_map = 2;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 3;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandReplaceAllTextArchive)
 private:
  inline void set_has_tableinfo();
  inline void clear_has_tableinfo();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* tableinfo_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandReplaceAllTextArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetRepeatingHeaderEnabledArchive : public ::google::protobuf::Message {
 public:
  CommandSetRepeatingHeaderEnabledArchive();
  virtual ~CommandSetRepeatingHeaderEnabledArchive();

  CommandSetRepeatingHeaderEnabledArchive(const CommandSetRepeatingHeaderEnabledArchive& from);

  inline CommandSetRepeatingHeaderEnabledArchive& operator=(const CommandSetRepeatingHeaderEnabledArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetRepeatingHeaderEnabledArchive& default_instance();

  void Swap(CommandSetRepeatingHeaderEnabledArchive* other);

  // implements Message ----------------------------------------------

  CommandSetRepeatingHeaderEnabledArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetRepeatingHeaderEnabledArchive& from);
  void MergeFrom(const CommandSetRepeatingHeaderEnabledArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool repeating_header_enabled = 1;
  inline bool has_repeating_header_enabled() const;
  inline void clear_repeating_header_enabled();
  static const int kRepeatingHeaderEnabledFieldNumber = 1;
  inline bool repeating_header_enabled() const;
  inline void set_repeating_header_enabled(bool value);

  // required .TST.CommandDirectionArchive direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required .TST.TableCommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetRepeatingHeaderEnabledArchive)
 private:
  inline void set_has_repeating_header_enabled();
  inline void clear_has_repeating_header_enabled();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool repeating_header_enabled_;
  int direction_;
  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetRepeatingHeaderEnabledArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFiltersEnabledArchive : public ::google::protobuf::Message {
 public:
  CommandSetFiltersEnabledArchive();
  virtual ~CommandSetFiltersEnabledArchive();

  CommandSetFiltersEnabledArchive(const CommandSetFiltersEnabledArchive& from);

  inline CommandSetFiltersEnabledArchive& operator=(const CommandSetFiltersEnabledArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFiltersEnabledArchive& default_instance();

  void Swap(CommandSetFiltersEnabledArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFiltersEnabledArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFiltersEnabledArchive& from);
  void MergeFrom(const CommandSetFiltersEnabledArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enable_filters = 1;
  inline bool has_enable_filters() const;
  inline void clear_enable_filters();
  static const int kEnableFiltersFieldNumber = 1;
  inline bool enable_filters() const;
  inline void set_enable_filters(bool value);

  // required .TST.TableCommandArchive super = 2;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 2;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFiltersEnabledArchive)
 private:
  inline void set_has_enable_filters();
  inline void clear_has_enable_filters();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  bool enable_filters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFiltersEnabledArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandAddQuickFilterRulesArchive : public ::google::protobuf::Message {
 public:
  CommandAddQuickFilterRulesArchive();
  virtual ~CommandAddQuickFilterRulesArchive();

  CommandAddQuickFilterRulesArchive(const CommandAddQuickFilterRulesArchive& from);

  inline CommandAddQuickFilterRulesArchive& operator=(const CommandAddQuickFilterRulesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandAddQuickFilterRulesArchive& default_instance();

  void Swap(CommandAddQuickFilterRulesArchive* other);

  // implements Message ----------------------------------------------

  CommandAddQuickFilterRulesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandAddQuickFilterRulesArchive& from);
  void MergeFrom(const CommandAddQuickFilterRulesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // repeated .TST.FilterRuleArchive rules = 2;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 2;
  inline const ::TST::FilterRuleArchive& rules(int index) const;
  inline ::TST::FilterRuleArchive* mutable_rules(int index);
  inline ::TST::FilterRuleArchive* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >*
      mutable_rules();

  // required uint32 filter_index = 3;
  inline bool has_filter_index() const;
  inline void clear_filter_index();
  static const int kFilterIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 filter_index() const;
  inline void set_filter_index(::google::protobuf::uint32 value);

  // repeated uint32 rule_indices = 4;
  inline int rule_indices_size() const;
  inline void clear_rule_indices();
  static const int kRuleIndicesFieldNumber = 4;
  inline ::google::protobuf::uint32 rule_indices(int index) const;
  inline void set_rule_indices(int index, ::google::protobuf::uint32 value);
  inline void add_rule_indices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rule_indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rule_indices();

  // required bool filter_set_enabled = 5;
  inline bool has_filter_set_enabled() const;
  inline void clear_filter_set_enabled();
  static const int kFilterSetEnabledFieldNumber = 5;
  inline bool filter_set_enabled() const;
  inline void set_filter_set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandAddQuickFilterRulesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_filter_index();
  inline void clear_has_filter_index();
  inline void set_has_filter_set_enabled();
  inline void clear_has_filter_set_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive > rules_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rule_indices_;
  ::google::protobuf::uint32 filter_index_;
  bool filter_set_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandAddQuickFilterRulesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDeleteFilterRulesArchive : public ::google::protobuf::Message {
 public:
  CommandDeleteFilterRulesArchive();
  virtual ~CommandDeleteFilterRulesArchive();

  CommandDeleteFilterRulesArchive(const CommandDeleteFilterRulesArchive& from);

  inline CommandDeleteFilterRulesArchive& operator=(const CommandDeleteFilterRulesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDeleteFilterRulesArchive& default_instance();

  void Swap(CommandDeleteFilterRulesArchive* other);

  // implements Message ----------------------------------------------

  CommandDeleteFilterRulesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDeleteFilterRulesArchive& from);
  void MergeFrom(const CommandDeleteFilterRulesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // repeated .TST.FilterRuleArchive undo_rules = 2;
  inline int undo_rules_size() const;
  inline void clear_undo_rules();
  static const int kUndoRulesFieldNumber = 2;
  inline const ::TST::FilterRuleArchive& undo_rules(int index) const;
  inline ::TST::FilterRuleArchive* mutable_undo_rules(int index);
  inline ::TST::FilterRuleArchive* add_undo_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >&
      undo_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >*
      mutable_undo_rules();

  // repeated uint32 rule_indices = 3;
  inline int rule_indices_size() const;
  inline void clear_rule_indices();
  static const int kRuleIndicesFieldNumber = 3;
  inline ::google::protobuf::uint32 rule_indices(int index) const;
  inline void set_rule_indices(int index, ::google::protobuf::uint32 value);
  inline void add_rule_indices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rule_indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rule_indices();

  // required bool filter_removed = 4;
  inline bool has_filter_removed() const;
  inline void clear_filter_removed();
  static const int kFilterRemovedFieldNumber = 4;
  inline bool filter_removed() const;
  inline void set_filter_removed(bool value);

  // required uint32 filter_index = 5;
  inline bool has_filter_index() const;
  inline void clear_filter_index();
  static const int kFilterIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 filter_index() const;
  inline void set_filter_index(::google::protobuf::uint32 value);

  // required bool filter_set_enabled = 6;
  inline bool has_filter_set_enabled() const;
  inline void clear_filter_set_enabled();
  static const int kFilterSetEnabledFieldNumber = 6;
  inline bool filter_set_enabled() const;
  inline void set_filter_set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandDeleteFilterRulesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_filter_removed();
  inline void clear_has_filter_removed();
  inline void set_has_filter_index();
  inline void clear_has_filter_index();
  inline void set_has_filter_set_enabled();
  inline void clear_has_filter_set_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive > undo_rules_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rule_indices_;
  ::google::protobuf::uint32 filter_index_;
  bool filter_removed_;
  bool filter_set_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDeleteFilterRulesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandModifyFilterRuleArchive : public ::google::protobuf::Message {
 public:
  CommandModifyFilterRuleArchive();
  virtual ~CommandModifyFilterRuleArchive();

  CommandModifyFilterRuleArchive(const CommandModifyFilterRuleArchive& from);

  inline CommandModifyFilterRuleArchive& operator=(const CommandModifyFilterRuleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandModifyFilterRuleArchive& default_instance();

  void Swap(CommandModifyFilterRuleArchive* other);

  // implements Message ----------------------------------------------

  CommandModifyFilterRuleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandModifyFilterRuleArchive& from);
  void MergeFrom(const CommandModifyFilterRuleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.FilterRuleArchive undo_rule = 2;
  inline bool has_undo_rule() const;
  inline void clear_undo_rule();
  static const int kUndoRuleFieldNumber = 2;
  inline const ::TST::FilterRuleArchive& undo_rule() const;
  inline ::TST::FilterRuleArchive* mutable_undo_rule();
  inline ::TST::FilterRuleArchive* release_undo_rule();
  inline void set_allocated_undo_rule(::TST::FilterRuleArchive* undo_rule);

  // required .TST.FilterRuleArchive redo_rule = 3;
  inline bool has_redo_rule() const;
  inline void clear_redo_rule();
  static const int kRedoRuleFieldNumber = 3;
  inline const ::TST::FilterRuleArchive& redo_rule() const;
  inline ::TST::FilterRuleArchive* mutable_redo_rule();
  inline ::TST::FilterRuleArchive* release_redo_rule();
  inline void set_allocated_redo_rule(::TST::FilterRuleArchive* redo_rule);

  // required uint32 rule_index = 4;
  inline bool has_rule_index() const;
  inline void clear_rule_index();
  static const int kRuleIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 rule_index() const;
  inline void set_rule_index(::google::protobuf::uint32 value);

  // required uint32 filter_index = 5;
  inline bool has_filter_index() const;
  inline void clear_filter_index();
  static const int kFilterIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 filter_index() const;
  inline void set_filter_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandModifyFilterRuleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undo_rule();
  inline void clear_has_undo_rule();
  inline void set_has_redo_rule();
  inline void clear_has_redo_rule();
  inline void set_has_rule_index();
  inline void clear_has_rule_index();
  inline void set_has_filter_index();
  inline void clear_has_filter_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::FilterRuleArchive* undo_rule_;
  ::TST::FilterRuleArchive* redo_rule_;
  ::google::protobuf::uint32 rule_index_;
  ::google::protobuf::uint32 filter_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandModifyFilterRuleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyStrokePresetArchive : public ::google::protobuf::Message {
 public:
  CommandApplyStrokePresetArchive();
  virtual ~CommandApplyStrokePresetArchive();

  CommandApplyStrokePresetArchive(const CommandApplyStrokePresetArchive& from);

  inline CommandApplyStrokePresetArchive& operator=(const CommandApplyStrokePresetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyStrokePresetArchive& default_instance();

  void Swap(CommandApplyStrokePresetArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyStrokePresetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyStrokePresetArchive& from);
  void MergeFrom(const CommandApplyStrokePresetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellMapArchive undo_cell_map = 2;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // required .TST.SelectionArchive selection = 3;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 3;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // optional .TST.SelectionArchive expanded_selection = 6;
  inline bool has_expanded_selection() const;
  inline void clear_expanded_selection();
  static const int kExpandedSelectionFieldNumber = 6;
  inline const ::TST::SelectionArchive& expanded_selection() const;
  inline ::TST::SelectionArchive* mutable_expanded_selection();
  inline ::TST::SelectionArchive* release_expanded_selection();
  inline void set_allocated_expanded_selection(::TST::SelectionArchive* expanded_selection);

  // required int32 preset_index = 5;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 5;
  inline ::google::protobuf::int32 preset_index() const;
  inline void set_preset_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyStrokePresetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_expanded_selection();
  inline void clear_has_expanded_selection();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::SelectionArchive* selection_;
  ::TST::SelectionArchive* expanded_selection_;
  ::google::protobuf::int32 preset_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyStrokePresetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandAddTableStylePresetArchive : public ::google::protobuf::Message {
 public:
  CommandAddTableStylePresetArchive();
  virtual ~CommandAddTableStylePresetArchive();

  CommandAddTableStylePresetArchive(const CommandAddTableStylePresetArchive& from);

  inline CommandAddTableStylePresetArchive& operator=(const CommandAddTableStylePresetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandAddTableStylePresetArchive& default_instance();

  void Swap(CommandAddTableStylePresetArchive* other);

  // implements Message ----------------------------------------------

  CommandAddTableStylePresetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandAddTableStylePresetArchive& from);
  void MergeFrom(const CommandAddTableStylePresetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required int32 preset_index = 2;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 2;
  inline ::google::protobuf::int32 preset_index() const;
  inline void set_preset_index(::google::protobuf::int32 value);

  // required .TST.TableStyleNetworkArchive table_styles = 3;
  inline bool has_table_styles() const;
  inline void clear_table_styles();
  static const int kTableStylesFieldNumber = 3;
  inline const ::TST::TableStyleNetworkArchive& table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_table_styles();
  inline void set_allocated_table_styles(::TST::TableStyleNetworkArchive* table_styles);

  // required bool send_notification = 4;
  inline bool has_send_notification() const;
  inline void clear_send_notification();
  static const int kSendNotificationFieldNumber = 4;
  inline bool send_notification() const;
  inline void set_send_notification(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandAddTableStylePresetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();
  inline void set_has_table_styles();
  inline void clear_has_table_styles();
  inline void set_has_send_notification();
  inline void clear_has_send_notification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::TableStyleNetworkArchive* table_styles_;
  ::google::protobuf::int32 preset_index_;
  bool send_notification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandAddTableStylePresetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRemoveTableStylePresetArchive : public ::google::protobuf::Message {
 public:
  CommandRemoveTableStylePresetArchive();
  virtual ~CommandRemoveTableStylePresetArchive();

  CommandRemoveTableStylePresetArchive(const CommandRemoveTableStylePresetArchive& from);

  inline CommandRemoveTableStylePresetArchive& operator=(const CommandRemoveTableStylePresetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRemoveTableStylePresetArchive& default_instance();

  void Swap(CommandRemoveTableStylePresetArchive* other);

  // implements Message ----------------------------------------------

  CommandRemoveTableStylePresetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRemoveTableStylePresetArchive& from);
  void MergeFrom(const CommandRemoveTableStylePresetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .TST.TableStyleNetworkArchive removed_table_styles = 3;
  inline bool has_removed_table_styles() const;
  inline void clear_removed_table_styles();
  static const int kRemovedTableStylesFieldNumber = 3;
  inline const ::TST::TableStyleNetworkArchive& removed_table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_removed_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_removed_table_styles();
  inline void set_allocated_removed_table_styles(::TST::TableStyleNetworkArchive* removed_table_styles);

  // required int32 preset_id = 4;
  inline bool has_preset_id() const;
  inline void clear_preset_id();
  static const int kPresetIdFieldNumber = 4;
  inline ::google::protobuf::int32 preset_id() const;
  inline void set_preset_id(::google::protobuf::int32 value);

  // required int32 preset_index_in_theme = 5;
  inline bool has_preset_index_in_theme() const;
  inline void clear_preset_index_in_theme();
  static const int kPresetIndexInThemeFieldNumber = 5;
  inline ::google::protobuf::int32 preset_index_in_theme() const;
  inline void set_preset_index_in_theme(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandRemoveTableStylePresetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_removed_table_styles();
  inline void clear_has_removed_table_styles();
  inline void set_has_preset_id();
  inline void clear_has_preset_id();
  inline void set_has_preset_index_in_theme();
  inline void clear_has_preset_index_in_theme();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TST::TableStyleNetworkArchive* removed_table_styles_;
  ::google::protobuf::int32 preset_id_;
  ::google::protobuf::int32 preset_index_in_theme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRemoveTableStylePresetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandReplaceTableStylePresetArchive : public ::google::protobuf::Message {
 public:
  CommandReplaceTableStylePresetArchive();
  virtual ~CommandReplaceTableStylePresetArchive();

  CommandReplaceTableStylePresetArchive(const CommandReplaceTableStylePresetArchive& from);

  inline CommandReplaceTableStylePresetArchive& operator=(const CommandReplaceTableStylePresetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReplaceTableStylePresetArchive& default_instance();

  void Swap(CommandReplaceTableStylePresetArchive* other);

  // implements Message ----------------------------------------------

  CommandReplaceTableStylePresetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReplaceTableStylePresetArchive& from);
  void MergeFrom(const CommandReplaceTableStylePresetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .TST.TableStyleNetworkArchive old_table_styles = 3;
  inline bool has_old_table_styles() const;
  inline void clear_old_table_styles();
  static const int kOldTableStylesFieldNumber = 3;
  inline const ::TST::TableStyleNetworkArchive& old_table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_old_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_old_table_styles();
  inline void set_allocated_old_table_styles(::TST::TableStyleNetworkArchive* old_table_styles);

  // required .TST.TableStyleNetworkArchive new_table_styles = 4;
  inline bool has_new_table_styles() const;
  inline void clear_new_table_styles();
  static const int kNewTableStylesFieldNumber = 4;
  inline const ::TST::TableStyleNetworkArchive& new_table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_new_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_new_table_styles();
  inline void set_allocated_new_table_styles(::TST::TableStyleNetworkArchive* new_table_styles);

  // @@protoc_insertion_point(class_scope:TST.CommandReplaceTableStylePresetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_old_table_styles();
  inline void clear_has_old_table_styles();
  inline void set_has_new_table_styles();
  inline void clear_has_new_table_styles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TST::TableStyleNetworkArchive* old_table_styles_;
  ::TST::TableStyleNetworkArchive* new_table_styles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandReplaceTableStylePresetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyTableStylePresetArchive_StyleIndexTuple : public ::google::protobuf::Message {
 public:
  CommandApplyTableStylePresetArchive_StyleIndexTuple();
  virtual ~CommandApplyTableStylePresetArchive_StyleIndexTuple();

  CommandApplyTableStylePresetArchive_StyleIndexTuple(const CommandApplyTableStylePresetArchive_StyleIndexTuple& from);

  inline CommandApplyTableStylePresetArchive_StyleIndexTuple& operator=(const CommandApplyTableStylePresetArchive_StyleIndexTuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyTableStylePresetArchive_StyleIndexTuple& default_instance();

  void Swap(CommandApplyTableStylePresetArchive_StyleIndexTuple* other);

  // implements Message ----------------------------------------------

  CommandApplyTableStylePresetArchive_StyleIndexTuple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyTableStylePresetArchive_StyleIndexTuple& from);
  void MergeFrom(const CommandApplyTableStylePresetArchive_StyleIndexTuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .TSP.Reference cell_style = 5;
  inline bool has_cell_style() const;
  inline void clear_cell_style();
  static const int kCellStyleFieldNumber = 5;
  inline const ::TSP::Reference& cell_style() const;
  inline ::TSP::Reference* mutable_cell_style();
  inline ::TSP::Reference* release_cell_style();
  inline void set_allocated_cell_style(::TSP::Reference* cell_style);

  // optional .TSP.Reference text_style = 6;
  inline bool has_text_style() const;
  inline void clear_text_style();
  static const int kTextStyleFieldNumber = 6;
  inline const ::TSP::Reference& text_style() const;
  inline ::TSP::Reference* mutable_text_style();
  inline ::TSP::Reference* release_text_style();
  inline void set_allocated_text_style(::TSP::Reference* text_style);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_cell_style();
  inline void clear_has_cell_style();
  inline void set_has_text_style();
  inline void clear_has_text_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* cell_style_;
  ::TSP::Reference* text_style_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyTableStylePresetArchive_StyleIndexTuple* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyTableStylePresetArchive : public ::google::protobuf::Message {
 public:
  CommandApplyTableStylePresetArchive();
  virtual ~CommandApplyTableStylePresetArchive();

  CommandApplyTableStylePresetArchive(const CommandApplyTableStylePresetArchive& from);

  inline CommandApplyTableStylePresetArchive& operator=(const CommandApplyTableStylePresetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyTableStylePresetArchive& default_instance();

  void Swap(CommandApplyTableStylePresetArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyTableStylePresetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyTableStylePresetArchive& from);
  void MergeFrom(const CommandApplyTableStylePresetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandApplyTableStylePresetArchive_StyleIndexTuple StyleIndexTuple;

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellMapArchive undo_cell_map = 2;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // required int32 preset_index = 5;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 5;
  inline ::google::protobuf::int32 preset_index() const;
  inline void set_preset_index(::google::protobuf::int32 value);

  // required .TST.TableStyleNetworkArchive old_table_styles = 7;
  inline bool has_old_table_styles() const;
  inline void clear_old_table_styles();
  static const int kOldTableStylesFieldNumber = 7;
  inline const ::TST::TableStyleNetworkArchive& old_table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_old_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_old_table_styles();
  inline void set_allocated_old_table_styles(::TST::TableStyleNetworkArchive* old_table_styles);

  // optional .TST.TableStyleNetworkArchive new_table_styles = 8 [deprecated = true];
  inline bool has_new_table_styles() const PROTOBUF_DEPRECATED;
  inline void clear_new_table_styles() PROTOBUF_DEPRECATED;
  static const int kNewTableStylesFieldNumber = 8;
  inline const ::TST::TableStyleNetworkArchive& new_table_styles() const PROTOBUF_DEPRECATED;
  inline ::TST::TableStyleNetworkArchive* mutable_new_table_styles() PROTOBUF_DEPRECATED;
  inline ::TST::TableStyleNetworkArchive* release_new_table_styles() PROTOBUF_DEPRECATED;
  inline void set_allocated_new_table_styles(::TST::TableStyleNetworkArchive* new_table_styles) PROTOBUF_DEPRECATED;

  // optional bool apply_clears_all = 10;
  inline bool has_apply_clears_all() const;
  inline void clear_apply_clears_all();
  static const int kApplyClearsAllFieldNumber = 10;
  inline bool apply_clears_all() const;
  inline void set_apply_clears_all(bool value);

  // optional .TSP.Reference font_size_command = 11;
  inline bool has_font_size_command() const;
  inline void clear_font_size_command();
  static const int kFontSizeCommandFieldNumber = 11;
  inline const ::TSP::Reference& font_size_command() const;
  inline ::TSP::Reference* mutable_font_size_command();
  inline ::TSP::Reference* release_font_size_command();
  inline void set_allocated_font_size_command(::TSP::Reference* font_size_command);

  // optional .TSP.Reference set_style_apply_clears_all_flag_command = 12;
  inline bool has_set_style_apply_clears_all_flag_command() const;
  inline void clear_set_style_apply_clears_all_flag_command();
  static const int kSetStyleApplyClearsAllFlagCommandFieldNumber = 12;
  inline const ::TSP::Reference& set_style_apply_clears_all_flag_command() const;
  inline ::TSP::Reference* mutable_set_style_apply_clears_all_flag_command();
  inline ::TSP::Reference* release_set_style_apply_clears_all_flag_command();
  inline void set_allocated_set_style_apply_clears_all_flag_command(::TSP::Reference* set_style_apply_clears_all_flag_command);

  // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple row_style_index_tuples = 13;
  inline int row_style_index_tuples_size() const;
  inline void clear_row_style_index_tuples();
  static const int kRowStyleIndexTuplesFieldNumber = 13;
  inline const ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple& row_style_index_tuples(int index) const;
  inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* mutable_row_style_index_tuples(int index);
  inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* add_row_style_index_tuples();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >&
      row_style_index_tuples() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >*
      mutable_row_style_index_tuples();

  // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple col_style_index_tuples = 14;
  inline int col_style_index_tuples_size() const;
  inline void clear_col_style_index_tuples();
  static const int kColStyleIndexTuplesFieldNumber = 14;
  inline const ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple& col_style_index_tuples(int index) const;
  inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* mutable_col_style_index_tuples(int index);
  inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* add_col_style_index_tuples();
  inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >&
      col_style_index_tuples() const;
  inline ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >*
      mutable_col_style_index_tuples();

  // @@protoc_insertion_point(class_scope:TST.CommandApplyTableStylePresetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();
  inline void set_has_old_table_styles();
  inline void clear_has_old_table_styles();
  inline void set_has_new_table_styles();
  inline void clear_has_new_table_styles();
  inline void set_has_apply_clears_all();
  inline void clear_has_apply_clears_all();
  inline void set_has_font_size_command();
  inline void clear_has_font_size_command();
  inline void set_has_set_style_apply_clears_all_flag_command();
  inline void clear_has_set_style_apply_clears_all_flag_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::TableStyleNetworkArchive* old_table_styles_;
  ::google::protobuf::int32 preset_index_;
  bool apply_clears_all_;
  ::TST::TableStyleNetworkArchive* new_table_styles_;
  ::TSP::Reference* font_size_command_;
  ::TSP::Reference* set_style_apply_clears_all_flag_command_;
  ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple > row_style_index_tuples_;
  ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple > col_style_index_tuples_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyTableStylePresetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetStyleApplyClearsAllFlagArchive : public ::google::protobuf::Message {
 public:
  CommandSetStyleApplyClearsAllFlagArchive();
  virtual ~CommandSetStyleApplyClearsAllFlagArchive();

  CommandSetStyleApplyClearsAllFlagArchive(const CommandSetStyleApplyClearsAllFlagArchive& from);

  inline CommandSetStyleApplyClearsAllFlagArchive& operator=(const CommandSetStyleApplyClearsAllFlagArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetStyleApplyClearsAllFlagArchive& default_instance();

  void Swap(CommandSetStyleApplyClearsAllFlagArchive* other);

  // implements Message ----------------------------------------------

  CommandSetStyleApplyClearsAllFlagArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetStyleApplyClearsAllFlagArchive& from);
  void MergeFrom(const CommandSetStyleApplyClearsAllFlagArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required bool apply_clears_all = 2;
  inline bool has_apply_clears_all() const;
  inline void clear_apply_clears_all();
  static const int kApplyClearsAllFieldNumber = 2;
  inline bool apply_clears_all() const;
  inline void set_apply_clears_all(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetStyleApplyClearsAllFlagArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_apply_clears_all();
  inline void clear_has_apply_clears_all();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  bool apply_clears_all_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetStyleApplyClearsAllFlagArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyThemeToTableArchive : public ::google::protobuf::Message {
 public:
  CommandApplyThemeToTableArchive();
  virtual ~CommandApplyThemeToTableArchive();

  CommandApplyThemeToTableArchive(const CommandApplyThemeToTableArchive& from);

  inline CommandApplyThemeToTableArchive& operator=(const CommandApplyThemeToTableArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyThemeToTableArchive& default_instance();

  void Swap(CommandApplyThemeToTableArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyThemeToTableArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyThemeToTableArchive& from);
  void MergeFrom(const CommandApplyThemeToTableArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellMapArchive undo_cell_map = 2;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // required .TST.TableStyleNetworkArchive old_table_styles = 7;
  inline bool has_old_table_styles() const;
  inline void clear_old_table_styles();
  static const int kOldTableStylesFieldNumber = 7;
  inline const ::TST::TableStyleNetworkArchive& old_table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_old_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_old_table_styles();
  inline void set_allocated_old_table_styles(::TST::TableStyleNetworkArchive* old_table_styles);

  // required .TST.TableStyleNetworkArchive new_table_styles = 8;
  inline bool has_new_table_styles() const;
  inline void clear_new_table_styles();
  static const int kNewTableStylesFieldNumber = 8;
  inline const ::TST::TableStyleNetworkArchive& new_table_styles() const;
  inline ::TST::TableStyleNetworkArchive* mutable_new_table_styles();
  inline ::TST::TableStyleNetworkArchive* release_new_table_styles();
  inline void set_allocated_new_table_styles(::TST::TableStyleNetworkArchive* new_table_styles);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyThemeToTableArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_old_table_styles();
  inline void clear_has_old_table_styles();
  inline void set_has_new_table_styles();
  inline void clear_has_new_table_styles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::TableStyleNetworkArchive* old_table_styles_;
  ::TST::TableStyleNetworkArchive* new_table_styles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyThemeToTableArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyThemeChildForTableArchive : public ::google::protobuf::Message {
 public:
  CommandApplyThemeChildForTableArchive();
  virtual ~CommandApplyThemeChildForTableArchive();

  CommandApplyThemeChildForTableArchive(const CommandApplyThemeChildForTableArchive& from);

  inline CommandApplyThemeChildForTableArchive& operator=(const CommandApplyThemeChildForTableArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyThemeChildForTableArchive& default_instance();

  void Swap(CommandApplyThemeChildForTableArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyThemeChildForTableArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyThemeChildForTableArchive& from);
  void MergeFrom(const CommandApplyThemeChildForTableArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.ApplyThemeChildCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::ApplyThemeChildCommandArchive& super() const;
  inline ::TSS::ApplyThemeChildCommandArchive* mutable_super();
  inline ::TSS::ApplyThemeChildCommandArchive* release_super();
  inline void set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super);

  // required .TSP.Reference apply_command = 2;
  inline bool has_apply_command() const;
  inline void clear_apply_command();
  static const int kApplyCommandFieldNumber = 2;
  inline const ::TSP::Reference& apply_command() const;
  inline ::TSP::Reference* mutable_apply_command();
  inline ::TSP::Reference* release_apply_command();
  inline void set_allocated_apply_command(::TSP::Reference* apply_command);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyThemeChildForTableArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_apply_command();
  inline void clear_has_apply_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::ApplyThemeChildCommandArchive* super_;
  ::TSP::Reference* apply_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyThemeChildForTableArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandToggleTextPropertyArchive : public ::google::protobuf::Message {
 public:
  CommandToggleTextPropertyArchive();
  virtual ~CommandToggleTextPropertyArchive();

  CommandToggleTextPropertyArchive(const CommandToggleTextPropertyArchive& from);

  inline CommandToggleTextPropertyArchive& operator=(const CommandToggleTextPropertyArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandToggleTextPropertyArchive& default_instance();

  void Swap(CommandToggleTextPropertyArchive* other);

  // implements Message ----------------------------------------------

  CommandToggleTextPropertyArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandToggleTextPropertyArchive& from);
  void MergeFrom(const CommandToggleTextPropertyArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required uint32 property = 3;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 3;
  inline ::google::protobuf::uint32 property() const;
  inline void set_property(::google::protobuf::uint32 value);

  // required .TST.CellMapArchive undo_cell_map = 4;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 5;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // required .TST.Cell default_body_cell = 6;
  inline bool has_default_body_cell() const;
  inline void clear_default_body_cell();
  static const int kDefaultBodyCellFieldNumber = 6;
  inline const ::TST::Cell& default_body_cell() const;
  inline ::TST::Cell* mutable_default_body_cell();
  inline ::TST::Cell* release_default_body_cell();
  inline void set_allocated_default_body_cell(::TST::Cell* default_body_cell);

  // required .TST.Cell default_hr_cell = 7;
  inline bool has_default_hr_cell() const;
  inline void clear_default_hr_cell();
  static const int kDefaultHrCellFieldNumber = 7;
  inline const ::TST::Cell& default_hr_cell() const;
  inline ::TST::Cell* mutable_default_hr_cell();
  inline ::TST::Cell* release_default_hr_cell();
  inline void set_allocated_default_hr_cell(::TST::Cell* default_hr_cell);

  // required .TST.Cell default_hc_cell = 8;
  inline bool has_default_hc_cell() const;
  inline void clear_default_hc_cell();
  static const int kDefaultHcCellFieldNumber = 8;
  inline const ::TST::Cell& default_hc_cell() const;
  inline ::TST::Cell* mutable_default_hc_cell();
  inline ::TST::Cell* release_default_hc_cell();
  inline void set_allocated_default_hc_cell(::TST::Cell* default_hc_cell);

  // required .TST.Cell default_fr_cell = 9;
  inline bool has_default_fr_cell() const;
  inline void clear_default_fr_cell();
  static const int kDefaultFrCellFieldNumber = 9;
  inline const ::TST::Cell& default_fr_cell() const;
  inline ::TST::Cell* mutable_default_fr_cell();
  inline ::TST::Cell* release_default_fr_cell();
  inline void set_allocated_default_fr_cell(::TST::Cell* default_fr_cell);

  // optional .TSP.Reference text_undo = 10;
  inline bool has_text_undo() const;
  inline void clear_text_undo();
  static const int kTextUndoFieldNumber = 10;
  inline const ::TSP::Reference& text_undo() const;
  inline ::TSP::Reference* mutable_text_undo();
  inline ::TSP::Reference* release_text_undo();
  inline void set_allocated_text_undo(::TSP::Reference* text_undo);

  // @@protoc_insertion_point(class_scope:TST.CommandToggleTextPropertyArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_default_body_cell();
  inline void clear_has_default_body_cell();
  inline void set_has_default_hr_cell();
  inline void clear_has_default_hr_cell();
  inline void set_has_default_hc_cell();
  inline void clear_has_default_hc_cell();
  inline void set_has_default_fr_cell();
  inline void clear_has_default_fr_cell();
  inline void set_has_text_undo();
  inline void clear_has_text_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::Cell* default_body_cell_;
  ::TST::Cell* default_hr_cell_;
  ::TST::Cell* default_hc_cell_;
  ::TST::Cell* default_fr_cell_;
  ::TSP::Reference* text_undo_;
  ::google::protobuf::uint32 property_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandToggleTextPropertyArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandResetFillPropertyToDefault : public ::google::protobuf::Message {
 public:
  CommandResetFillPropertyToDefault();
  virtual ~CommandResetFillPropertyToDefault();

  CommandResetFillPropertyToDefault(const CommandResetFillPropertyToDefault& from);

  inline CommandResetFillPropertyToDefault& operator=(const CommandResetFillPropertyToDefault& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandResetFillPropertyToDefault& default_instance();

  void Swap(CommandResetFillPropertyToDefault* other);

  // implements Message ----------------------------------------------

  CommandResetFillPropertyToDefault* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandResetFillPropertyToDefault& from);
  void MergeFrom(const CommandResetFillPropertyToDefault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_cell_map = 4;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 5;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandResetFillPropertyToDefault)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandResetFillPropertyToDefault* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetSingleNumberFormatParameterArchive : public ::google::protobuf::Message {
 public:
  CommandSetSingleNumberFormatParameterArchive();
  virtual ~CommandSetSingleNumberFormatParameterArchive();

  CommandSetSingleNumberFormatParameterArchive(const CommandSetSingleNumberFormatParameterArchive& from);

  inline CommandSetSingleNumberFormatParameterArchive& operator=(const CommandSetSingleNumberFormatParameterArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetSingleNumberFormatParameterArchive& default_instance();

  void Swap(CommandSetSingleNumberFormatParameterArchive* other);

  // implements Message ----------------------------------------------

  CommandSetSingleNumberFormatParameterArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetSingleNumberFormatParameterArchive& from);
  void MergeFrom(const CommandSetSingleNumberFormatParameterArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_cell_map = 3;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandSetSingleNumberFormatParameterArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetSingleNumberFormatParameterArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetBaseArchive : public ::google::protobuf::Message {
 public:
  CommandSetBaseArchive();
  virtual ~CommandSetBaseArchive();

  CommandSetBaseArchive(const CommandSetBaseArchive& from);

  inline CommandSetBaseArchive& operator=(const CommandSetBaseArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetBaseArchive& default_instance();

  void Swap(CommandSetBaseArchive* other);

  // implements Message ----------------------------------------------

  CommandSetBaseArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetBaseArchive& from);
  void MergeFrom(const CommandSetBaseArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required uint32 base = 2;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 2;
  inline ::google::protobuf::uint32 base() const;
  inline void set_base(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetBaseArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  ::google::protobuf::uint32 base_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetBaseArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetBasePlacesArchive : public ::google::protobuf::Message {
 public:
  CommandSetBasePlacesArchive();
  virtual ~CommandSetBasePlacesArchive();

  CommandSetBasePlacesArchive(const CommandSetBasePlacesArchive& from);

  inline CommandSetBasePlacesArchive& operator=(const CommandSetBasePlacesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetBasePlacesArchive& default_instance();

  void Swap(CommandSetBasePlacesArchive* other);

  // implements Message ----------------------------------------------

  CommandSetBasePlacesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetBasePlacesArchive& from);
  void MergeFrom(const CommandSetBasePlacesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required uint32 base_places = 2;
  inline bool has_base_places() const;
  inline void clear_base_places();
  static const int kBasePlacesFieldNumber = 2;
  inline ::google::protobuf::uint32 base_places() const;
  inline void set_base_places(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetBasePlacesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_base_places();
  inline void clear_has_base_places();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  ::google::protobuf::uint32 base_places_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetBasePlacesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetBaseUseMinusSignArchive : public ::google::protobuf::Message {
 public:
  CommandSetBaseUseMinusSignArchive();
  virtual ~CommandSetBaseUseMinusSignArchive();

  CommandSetBaseUseMinusSignArchive(const CommandSetBaseUseMinusSignArchive& from);

  inline CommandSetBaseUseMinusSignArchive& operator=(const CommandSetBaseUseMinusSignArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetBaseUseMinusSignArchive& default_instance();

  void Swap(CommandSetBaseUseMinusSignArchive* other);

  // implements Message ----------------------------------------------

  CommandSetBaseUseMinusSignArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetBaseUseMinusSignArchive& from);
  void MergeFrom(const CommandSetBaseUseMinusSignArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required bool base_use_minus_sign = 2;
  inline bool has_base_use_minus_sign() const;
  inline void clear_base_use_minus_sign();
  static const int kBaseUseMinusSignFieldNumber = 2;
  inline bool base_use_minus_sign() const;
  inline void set_base_use_minus_sign(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetBaseUseMinusSignArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_base_use_minus_sign();
  inline void clear_has_base_use_minus_sign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  bool base_use_minus_sign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetBaseUseMinusSignArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetControlMinimumArchive : public ::google::protobuf::Message {
 public:
  CommandSetControlMinimumArchive();
  virtual ~CommandSetControlMinimumArchive();

  CommandSetControlMinimumArchive(const CommandSetControlMinimumArchive& from);

  inline CommandSetControlMinimumArchive& operator=(const CommandSetControlMinimumArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetControlMinimumArchive& default_instance();

  void Swap(CommandSetControlMinimumArchive* other);

  // implements Message ----------------------------------------------

  CommandSetControlMinimumArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetControlMinimumArchive& from);
  void MergeFrom(const CommandSetControlMinimumArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required double minimum = 2;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 2;
  inline double minimum() const;
  inline void set_minimum(double value);

  // required uint32 format_type = 3;
  inline bool has_format_type() const;
  inline void clear_format_type();
  static const int kFormatTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 format_type() const;
  inline void set_format_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetControlMinimumArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  inline void set_has_format_type();
  inline void clear_has_format_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  double minimum_;
  ::google::protobuf::uint32 format_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetControlMinimumArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetControlMaximumArchive : public ::google::protobuf::Message {
 public:
  CommandSetControlMaximumArchive();
  virtual ~CommandSetControlMaximumArchive();

  CommandSetControlMaximumArchive(const CommandSetControlMaximumArchive& from);

  inline CommandSetControlMaximumArchive& operator=(const CommandSetControlMaximumArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetControlMaximumArchive& default_instance();

  void Swap(CommandSetControlMaximumArchive* other);

  // implements Message ----------------------------------------------

  CommandSetControlMaximumArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetControlMaximumArchive& from);
  void MergeFrom(const CommandSetControlMaximumArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required double maximum = 2;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 2;
  inline double maximum() const;
  inline void set_maximum(double value);

  // required uint32 format_type = 3;
  inline bool has_format_type() const;
  inline void clear_format_type();
  static const int kFormatTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 format_type() const;
  inline void set_format_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetControlMaximumArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_format_type();
  inline void clear_has_format_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  double maximum_;
  ::google::protobuf::uint32 format_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetControlMaximumArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetControlIncrementArchive : public ::google::protobuf::Message {
 public:
  CommandSetControlIncrementArchive();
  virtual ~CommandSetControlIncrementArchive();

  CommandSetControlIncrementArchive(const CommandSetControlIncrementArchive& from);

  inline CommandSetControlIncrementArchive& operator=(const CommandSetControlIncrementArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetControlIncrementArchive& default_instance();

  void Swap(CommandSetControlIncrementArchive* other);

  // implements Message ----------------------------------------------

  CommandSetControlIncrementArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetControlIncrementArchive& from);
  void MergeFrom(const CommandSetControlIncrementArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required double increment = 2;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 2;
  inline double increment() const;
  inline void set_increment(double value);

  // required uint32 format_type = 3;
  inline bool has_format_type() const;
  inline void clear_format_type();
  static const int kFormatTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 format_type() const;
  inline void set_format_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetControlIncrementArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_format_type();
  inline void clear_has_format_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  double increment_;
  ::google::protobuf::uint32 format_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetControlIncrementArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetCurrencyCodeArchive : public ::google::protobuf::Message {
 public:
  CommandSetCurrencyCodeArchive();
  virtual ~CommandSetCurrencyCodeArchive();

  CommandSetCurrencyCodeArchive(const CommandSetCurrencyCodeArchive& from);

  inline CommandSetCurrencyCodeArchive& operator=(const CommandSetCurrencyCodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetCurrencyCodeArchive& default_instance();

  void Swap(CommandSetCurrencyCodeArchive* other);

  // implements Message ----------------------------------------------

  CommandSetCurrencyCodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetCurrencyCodeArchive& from);
  void MergeFrom(const CommandSetCurrencyCodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required string currency_code = 2;
  inline bool has_currency_code() const;
  inline void clear_currency_code();
  static const int kCurrencyCodeFieldNumber = 2;
  inline const ::std::string& currency_code() const;
  inline void set_currency_code(const ::std::string& value);
  inline void set_currency_code(const char* value);
  inline void set_currency_code(const char* value, size_t size);
  inline ::std::string* mutable_currency_code();
  inline ::std::string* release_currency_code();
  inline void set_allocated_currency_code(::std::string* currency_code);

  // @@protoc_insertion_point(class_scope:TST.CommandSetCurrencyCodeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_currency_code();
  inline void clear_has_currency_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  ::std::string* currency_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetCurrencyCodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFractionAccuracyArchive : public ::google::protobuf::Message {
 public:
  CommandSetFractionAccuracyArchive();
  virtual ~CommandSetFractionAccuracyArchive();

  CommandSetFractionAccuracyArchive(const CommandSetFractionAccuracyArchive& from);

  inline CommandSetFractionAccuracyArchive& operator=(const CommandSetFractionAccuracyArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFractionAccuracyArchive& default_instance();

  void Swap(CommandSetFractionAccuracyArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFractionAccuracyArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFractionAccuracyArchive& from);
  void MergeFrom(const CommandSetFractionAccuracyArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required uint32 fraction_accuracy = 2;
  inline bool has_fraction_accuracy() const;
  inline void clear_fraction_accuracy();
  static const int kFractionAccuracyFieldNumber = 2;
  inline ::google::protobuf::uint32 fraction_accuracy() const;
  inline void set_fraction_accuracy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFractionAccuracyArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_fraction_accuracy();
  inline void clear_has_fraction_accuracy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  ::google::protobuf::uint32 fraction_accuracy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFractionAccuracyArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleChoiceListFormatForEditedItemArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleChoiceListFormatForEditedItemArchive();
  virtual ~CommandSetMultipleChoiceListFormatForEditedItemArchive();

  CommandSetMultipleChoiceListFormatForEditedItemArchive(const CommandSetMultipleChoiceListFormatForEditedItemArchive& from);

  inline CommandSetMultipleChoiceListFormatForEditedItemArchive& operator=(const CommandSetMultipleChoiceListFormatForEditedItemArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleChoiceListFormatForEditedItemArchive& default_instance();

  void Swap(CommandSetMultipleChoiceListFormatForEditedItemArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleChoiceListFormatForEditedItemArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleChoiceListFormatForEditedItemArchive& from);
  void MergeFrom(const CommandSetMultipleChoiceListFormatForEditedItemArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleChoiceListFormatForEditedItemArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleChoiceListFormatForDeleteItemArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleChoiceListFormatForDeleteItemArchive();
  virtual ~CommandSetMultipleChoiceListFormatForDeleteItemArchive();

  CommandSetMultipleChoiceListFormatForDeleteItemArchive(const CommandSetMultipleChoiceListFormatForDeleteItemArchive& from);

  inline CommandSetMultipleChoiceListFormatForDeleteItemArchive& operator=(const CommandSetMultipleChoiceListFormatForDeleteItemArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleChoiceListFormatForDeleteItemArchive& default_instance();

  void Swap(CommandSetMultipleChoiceListFormatForDeleteItemArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleChoiceListFormatForDeleteItemArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleChoiceListFormatForDeleteItemArchive& from);
  void MergeFrom(const CommandSetMultipleChoiceListFormatForDeleteItemArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleChoiceListFormatForDeleteItemArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleChoiceListFormatForReorderItemArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleChoiceListFormatForReorderItemArchive();
  virtual ~CommandSetMultipleChoiceListFormatForReorderItemArchive();

  CommandSetMultipleChoiceListFormatForReorderItemArchive(const CommandSetMultipleChoiceListFormatForReorderItemArchive& from);

  inline CommandSetMultipleChoiceListFormatForReorderItemArchive& operator=(const CommandSetMultipleChoiceListFormatForReorderItemArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleChoiceListFormatForReorderItemArchive& default_instance();

  void Swap(CommandSetMultipleChoiceListFormatForReorderItemArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleChoiceListFormatForReorderItemArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleChoiceListFormatForReorderItemArchive& from);
  void MergeFrom(const CommandSetMultipleChoiceListFormatForReorderItemArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleChoiceListFormatForReorderItemArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetMultipleChoiceListFormatForInitialValueArchive : public ::google::protobuf::Message {
 public:
  CommandSetMultipleChoiceListFormatForInitialValueArchive();
  virtual ~CommandSetMultipleChoiceListFormatForInitialValueArchive();

  CommandSetMultipleChoiceListFormatForInitialValueArchive(const CommandSetMultipleChoiceListFormatForInitialValueArchive& from);

  inline CommandSetMultipleChoiceListFormatForInitialValueArchive& operator=(const CommandSetMultipleChoiceListFormatForInitialValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetMultipleChoiceListFormatForInitialValueArchive& default_instance();

  void Swap(CommandSetMultipleChoiceListFormatForInitialValueArchive* other);

  // implements Message ----------------------------------------------

  CommandSetMultipleChoiceListFormatForInitialValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetMultipleChoiceListFormatForInitialValueArchive& from);
  void MergeFrom(const CommandSetMultipleChoiceListFormatForInitialValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetMultipleChoiceListFormatForInitialValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetNegativeNumberStyleArchive : public ::google::protobuf::Message {
 public:
  CommandSetNegativeNumberStyleArchive();
  virtual ~CommandSetNegativeNumberStyleArchive();

  CommandSetNegativeNumberStyleArchive(const CommandSetNegativeNumberStyleArchive& from);

  inline CommandSetNegativeNumberStyleArchive& operator=(const CommandSetNegativeNumberStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetNegativeNumberStyleArchive& default_instance();

  void Swap(CommandSetNegativeNumberStyleArchive* other);

  // implements Message ----------------------------------------------

  CommandSetNegativeNumberStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetNegativeNumberStyleArchive& from);
  void MergeFrom(const CommandSetNegativeNumberStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required uint32 negative_number_style = 2;
  inline bool has_negative_number_style() const;
  inline void clear_negative_number_style();
  static const int kNegativeNumberStyleFieldNumber = 2;
  inline ::google::protobuf::uint32 negative_number_style() const;
  inline void set_negative_number_style(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetNegativeNumberStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_negative_number_style();
  inline void clear_has_negative_number_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  ::google::protobuf::uint32 negative_number_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetNegativeNumberStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetExplicitFormatArchive : public ::google::protobuf::Message {
 public:
  CommandSetExplicitFormatArchive();
  virtual ~CommandSetExplicitFormatArchive();

  CommandSetExplicitFormatArchive(const CommandSetExplicitFormatArchive& from);

  inline CommandSetExplicitFormatArchive& operator=(const CommandSetExplicitFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetExplicitFormatArchive& default_instance();

  void Swap(CommandSetExplicitFormatArchive* other);

  // implements Message ----------------------------------------------

  CommandSetExplicitFormatArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetExplicitFormatArchive& from);
  void MergeFrom(const CommandSetExplicitFormatArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TSK.FormatStructArchive cell_format = 3;
  inline bool has_cell_format() const;
  inline void clear_cell_format();
  static const int kCellFormatFieldNumber = 3;
  inline const ::TSK::FormatStructArchive& cell_format() const;
  inline ::TSK::FormatStructArchive* mutable_cell_format();
  inline ::TSK::FormatStructArchive* release_cell_format();
  inline void set_allocated_cell_format(::TSK::FormatStructArchive* cell_format);

  // required .TST.CellMapArchive undo_cell_map = 4;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 5;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandSetExplicitFormatArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_cell_format();
  inline void clear_has_cell_format();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::TSK::FormatStructArchive* cell_format_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetExplicitFormatArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetNumberOfDecimalPlacesArchive : public ::google::protobuf::Message {
 public:
  CommandSetNumberOfDecimalPlacesArchive();
  virtual ~CommandSetNumberOfDecimalPlacesArchive();

  CommandSetNumberOfDecimalPlacesArchive(const CommandSetNumberOfDecimalPlacesArchive& from);

  inline CommandSetNumberOfDecimalPlacesArchive& operator=(const CommandSetNumberOfDecimalPlacesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetNumberOfDecimalPlacesArchive& default_instance();

  void Swap(CommandSetNumberOfDecimalPlacesArchive* other);

  // implements Message ----------------------------------------------

  CommandSetNumberOfDecimalPlacesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetNumberOfDecimalPlacesArchive& from);
  void MergeFrom(const CommandSetNumberOfDecimalPlacesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required uint32 decimal_places = 2;
  inline bool has_decimal_places() const;
  inline void clear_decimal_places();
  static const int kDecimalPlacesFieldNumber = 2;
  inline ::google::protobuf::uint32 decimal_places() const;
  inline void set_decimal_places(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetNumberOfDecimalPlacesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_decimal_places();
  inline void clear_has_decimal_places();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  ::google::protobuf::uint32 decimal_places_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetNumberOfDecimalPlacesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetDateTimeFormatArchive : public ::google::protobuf::Message {
 public:
  CommandSetDateTimeFormatArchive();
  virtual ~CommandSetDateTimeFormatArchive();

  CommandSetDateTimeFormatArchive(const CommandSetDateTimeFormatArchive& from);

  inline CommandSetDateTimeFormatArchive& operator=(const CommandSetDateTimeFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetDateTimeFormatArchive& default_instance();

  void Swap(CommandSetDateTimeFormatArchive* other);

  // implements Message ----------------------------------------------

  CommandSetDateTimeFormatArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetDateTimeFormatArchive& from);
  void MergeFrom(const CommandSetDateTimeFormatArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandSetDateTimeFormatArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetDateTimeFormatArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetShowThousandsSeparatorArchive : public ::google::protobuf::Message {
 public:
  CommandSetShowThousandsSeparatorArchive();
  virtual ~CommandSetShowThousandsSeparatorArchive();

  CommandSetShowThousandsSeparatorArchive(const CommandSetShowThousandsSeparatorArchive& from);

  inline CommandSetShowThousandsSeparatorArchive& operator=(const CommandSetShowThousandsSeparatorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetShowThousandsSeparatorArchive& default_instance();

  void Swap(CommandSetShowThousandsSeparatorArchive* other);

  // implements Message ----------------------------------------------

  CommandSetShowThousandsSeparatorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetShowThousandsSeparatorArchive& from);
  void MergeFrom(const CommandSetShowThousandsSeparatorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required bool show_thousands_separator = 2;
  inline bool has_show_thousands_separator() const;
  inline void clear_show_thousands_separator();
  static const int kShowThousandsSeparatorFieldNumber = 2;
  inline bool show_thousands_separator() const;
  inline void set_show_thousands_separator(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetShowThousandsSeparatorArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_show_thousands_separator();
  inline void clear_has_show_thousands_separator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  bool show_thousands_separator_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetShowThousandsSeparatorArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetUseAccountingStyleArchive : public ::google::protobuf::Message {
 public:
  CommandSetUseAccountingStyleArchive();
  virtual ~CommandSetUseAccountingStyleArchive();

  CommandSetUseAccountingStyleArchive(const CommandSetUseAccountingStyleArchive& from);

  inline CommandSetUseAccountingStyleArchive& operator=(const CommandSetUseAccountingStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetUseAccountingStyleArchive& default_instance();

  void Swap(CommandSetUseAccountingStyleArchive* other);

  // implements Message ----------------------------------------------

  CommandSetUseAccountingStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetUseAccountingStyleArchive& from);
  void MergeFrom(const CommandSetUseAccountingStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::CommandSetSingleNumberFormatParameterArchive& super() const;
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* mutable_super();
  inline ::TST::CommandSetSingleNumberFormatParameterArchive* release_super();
  inline void set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super);

  // required bool use_accounting_style = 2;
  inline bool has_use_accounting_style() const;
  inline void clear_use_accounting_style();
  static const int kUseAccountingStyleFieldNumber = 2;
  inline bool use_accounting_style() const;
  inline void set_use_accounting_style(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetUseAccountingStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_use_accounting_style();
  inline void clear_has_use_accounting_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::CommandSetSingleNumberFormatParameterArchive* super_;
  bool use_accounting_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetUseAccountingStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMoveRowsArchive : public ::google::protobuf::Message {
 public:
  CommandMoveRowsArchive();
  virtual ~CommandMoveRowsArchive();

  CommandMoveRowsArchive(const CommandMoveRowsArchive& from);

  inline CommandMoveRowsArchive& operator=(const CommandMoveRowsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMoveRowsArchive& default_instance();

  void Swap(CommandMoveRowsArchive* other);

  // implements Message ----------------------------------------------

  CommandMoveRowsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMoveRowsArchive& from);
  void MergeFrom(const CommandMoveRowsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required uint32 start_row_index = 3;
  inline bool has_start_row_index() const;
  inline void clear_start_row_index();
  static const int kStartRowIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 start_row_index() const;
  inline void set_start_row_index(::google::protobuf::uint32 value);

  // required uint32 dest_row_index = 4;
  inline bool has_dest_row_index() const;
  inline void clear_dest_row_index();
  static const int kDestRowIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 dest_row_index() const;
  inline void set_dest_row_index(::google::protobuf::uint32 value);

  // required uint32 number_of_rows = 5;
  inline bool has_number_of_rows() const;
  inline void clear_number_of_rows();
  static const int kNumberOfRowsFieldNumber = 5;
  inline ::google::protobuf::uint32 number_of_rows() const;
  inline void set_number_of_rows(::google::protobuf::uint32 value);

  // optional .TSP.Reference formula_rewrite_command = 7;
  inline bool has_formula_rewrite_command() const;
  inline void clear_formula_rewrite_command();
  static const int kFormulaRewriteCommandFieldNumber = 7;
  inline const ::TSP::Reference& formula_rewrite_command() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command();
  inline ::TSP::Reference* release_formula_rewrite_command();
  inline void set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command);

  // optional .TSP.Reference show_command = 8;
  inline bool has_show_command() const;
  inline void clear_show_command();
  static const int kShowCommandFieldNumber = 8;
  inline const ::TSP::Reference& show_command() const;
  inline ::TSP::Reference* mutable_show_command();
  inline ::TSP::Reference* release_show_command();
  inline void set_allocated_show_command(::TSP::Reference* show_command);

  // optional .TSP.Reference unmerge_invalid_ranges_command = 9;
  inline bool has_unmerge_invalid_ranges_command() const;
  inline void clear_unmerge_invalid_ranges_command();
  static const int kUnmergeInvalidRangesCommandFieldNumber = 9;
  inline const ::TSP::Reference& unmerge_invalid_ranges_command() const;
  inline ::TSP::Reference* mutable_unmerge_invalid_ranges_command();
  inline ::TSP::Reference* release_unmerge_invalid_ranges_command();
  inline void set_allocated_unmerge_invalid_ranges_command(::TSP::Reference* unmerge_invalid_ranges_command);

  // @@protoc_insertion_point(class_scope:TST.CommandMoveRowsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_start_row_index();
  inline void clear_has_start_row_index();
  inline void set_has_dest_row_index();
  inline void clear_has_dest_row_index();
  inline void set_has_number_of_rows();
  inline void clear_has_number_of_rows();
  inline void set_has_formula_rewrite_command();
  inline void clear_has_formula_rewrite_command();
  inline void set_has_show_command();
  inline void clear_has_show_command();
  inline void set_has_unmerge_invalid_ranges_command();
  inline void clear_has_unmerge_invalid_ranges_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::google::protobuf::uint32 start_row_index_;
  ::google::protobuf::uint32 dest_row_index_;
  ::TSP::Reference* formula_rewrite_command_;
  ::TSP::Reference* show_command_;
  ::TSP::Reference* unmerge_invalid_ranges_command_;
  ::google::protobuf::uint32 number_of_rows_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMoveRowsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMoveColumnsArchive : public ::google::protobuf::Message {
 public:
  CommandMoveColumnsArchive();
  virtual ~CommandMoveColumnsArchive();

  CommandMoveColumnsArchive(const CommandMoveColumnsArchive& from);

  inline CommandMoveColumnsArchive& operator=(const CommandMoveColumnsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMoveColumnsArchive& default_instance();

  void Swap(CommandMoveColumnsArchive* other);

  // implements Message ----------------------------------------------

  CommandMoveColumnsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMoveColumnsArchive& from);
  void MergeFrom(const CommandMoveColumnsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required uint32 start_column_index = 3;
  inline bool has_start_column_index() const;
  inline void clear_start_column_index();
  static const int kStartColumnIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 start_column_index() const;
  inline void set_start_column_index(::google::protobuf::uint32 value);

  // required uint32 dest_column_index = 4;
  inline bool has_dest_column_index() const;
  inline void clear_dest_column_index();
  static const int kDestColumnIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 dest_column_index() const;
  inline void set_dest_column_index(::google::protobuf::uint32 value);

  // required uint32 number_of_columns = 5;
  inline bool has_number_of_columns() const;
  inline void clear_number_of_columns();
  static const int kNumberOfColumnsFieldNumber = 5;
  inline ::google::protobuf::uint32 number_of_columns() const;
  inline void set_number_of_columns(::google::protobuf::uint32 value);

  // optional .TSP.Reference formula_rewrite_command = 7;
  inline bool has_formula_rewrite_command() const;
  inline void clear_formula_rewrite_command();
  static const int kFormulaRewriteCommandFieldNumber = 7;
  inline const ::TSP::Reference& formula_rewrite_command() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command();
  inline ::TSP::Reference* release_formula_rewrite_command();
  inline void set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command);

  // optional .TSP.Reference show_command = 8;
  inline bool has_show_command() const;
  inline void clear_show_command();
  static const int kShowCommandFieldNumber = 8;
  inline const ::TSP::Reference& show_command() const;
  inline ::TSP::Reference* mutable_show_command();
  inline ::TSP::Reference* release_show_command();
  inline void set_allocated_show_command(::TSP::Reference* show_command);

  // @@protoc_insertion_point(class_scope:TST.CommandMoveColumnsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_start_column_index();
  inline void clear_has_start_column_index();
  inline void set_has_dest_column_index();
  inline void clear_has_dest_column_index();
  inline void set_has_number_of_columns();
  inline void clear_has_number_of_columns();
  inline void set_has_formula_rewrite_command();
  inline void clear_has_formula_rewrite_command();
  inline void set_has_show_command();
  inline void clear_has_show_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::google::protobuf::uint32 start_column_index_;
  ::google::protobuf::uint32 dest_column_index_;
  ::TSP::Reference* formula_rewrite_command_;
  ::TSP::Reference* show_command_;
  ::google::protobuf::uint32 number_of_columns_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMoveColumnsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSortArchive : public ::google::protobuf::Message {
 public:
  CommandSortArchive();
  virtual ~CommandSortArchive();

  CommandSortArchive(const CommandSortArchive& from);

  inline CommandSortArchive& operator=(const CommandSortArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSortArchive& default_instance();

  void Swap(CommandSortArchive* other);

  // implements Message ----------------------------------------------

  CommandSortArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSortArchive& from);
  void MergeFrom(const CommandSortArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSK.ShuffleMappingArchive mapping = 5;
  inline bool has_mapping() const;
  inline void clear_mapping();
  static const int kMappingFieldNumber = 5;
  inline const ::TSK::ShuffleMappingArchive& mapping() const;
  inline ::TSK::ShuffleMappingArchive* mutable_mapping();
  inline ::TSK::ShuffleMappingArchive* release_mapping();
  inline void set_allocated_mapping(::TSK::ShuffleMappingArchive* mapping);

  // optional .TSP.Reference formula_rewrite_command = 7;
  inline bool has_formula_rewrite_command() const;
  inline void clear_formula_rewrite_command();
  static const int kFormulaRewriteCommandFieldNumber = 7;
  inline const ::TSP::Reference& formula_rewrite_command() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command();
  inline ::TSP::Reference* release_formula_rewrite_command();
  inline void set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command);

  // @@protoc_insertion_point(class_scope:TST.CommandSortArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_mapping();
  inline void clear_has_mapping();
  inline void set_has_formula_rewrite_command();
  inline void clear_has_formula_rewrite_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSK::ShuffleMappingArchive* mapping_;
  ::TSP::Reference* formula_rewrite_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSortArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFormulasForSortArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFormulasForSortArchive();
  virtual ~CommandRewriteFormulasForSortArchive();

  CommandRewriteFormulasForSortArchive(const CommandRewriteFormulasForSortArchive& from);

  inline CommandRewriteFormulasForSortArchive& operator=(const CommandRewriteFormulasForSortArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFormulasForSortArchive& default_instance();

  void Swap(CommandRewriteFormulasForSortArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFormulasForSortArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFormulasForSortArchive& from);
  void MergeFrom(const CommandRewriteFormulasForSortArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  inline bool has_formula_map() const;
  inline void clear_formula_map();
  static const int kFormulaMapFieldNumber = 2;
  inline const ::TSCE::OwnerFormulaMapArchive& formula_map() const;
  inline ::TSCE::OwnerFormulaMapArchive* mutable_formula_map();
  inline ::TSCE::OwnerFormulaMapArchive* release_formula_map();
  inline void set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map);

  // required .TSK.ShuffleMappingArchive sort_mapping = 3;
  inline bool has_sort_mapping() const;
  inline void clear_sort_mapping();
  static const int kSortMappingFieldNumber = 3;
  inline const ::TSK::ShuffleMappingArchive& sort_mapping() const;
  inline ::TSK::ShuffleMappingArchive* mutable_sort_mapping();
  inline ::TSK::ShuffleMappingArchive* release_sort_mapping();
  inline void set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping);

  // required .TSCE.CFUUIDArchive sorted_table_id = 4;
  inline bool has_sorted_table_id() const;
  inline void clear_sorted_table_id();
  static const int kSortedTableIdFieldNumber = 4;
  inline const ::TSCE::CFUUIDArchive& sorted_table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_sorted_table_id();
  inline ::TSCE::CFUUIDArchive* release_sorted_table_id();
  inline void set_allocated_sorted_table_id(::TSCE::CFUUIDArchive* sorted_table_id);

  // required bool explode_ranges = 5;
  inline bool has_explode_ranges() const;
  inline void clear_explode_ranges();
  static const int kExplodeRangesFieldNumber = 5;
  inline bool explode_ranges() const;
  inline void set_explode_ranges(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFormulasForSortArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_formula_map();
  inline void clear_has_formula_map();
  inline void set_has_sort_mapping();
  inline void clear_has_sort_mapping();
  inline void set_has_sorted_table_id();
  inline void clear_has_sorted_table_id();
  inline void set_has_explode_ranges();
  inline void clear_has_explode_ranges();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::OwnerFormulaMapArchive* formula_map_;
  ::TSK::ShuffleMappingArchive* sort_mapping_;
  ::TSCE::CFUUIDArchive* sorted_table_id_;
  bool explode_ranges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFormulasForSortArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFormulasForTectonicShiftArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFormulasForTectonicShiftArchive();
  virtual ~CommandRewriteFormulasForTectonicShiftArchive();

  CommandRewriteFormulasForTectonicShiftArchive(const CommandRewriteFormulasForTectonicShiftArchive& from);

  inline CommandRewriteFormulasForTectonicShiftArchive& operator=(const CommandRewriteFormulasForTectonicShiftArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFormulasForTectonicShiftArchive& default_instance();

  void Swap(CommandRewriteFormulasForTectonicShiftArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFormulasForTectonicShiftArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFormulasForTectonicShiftArchive& from);
  void MergeFrom(const CommandRewriteFormulasForTectonicShiftArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  inline bool has_formula_map() const;
  inline void clear_formula_map();
  static const int kFormulaMapFieldNumber = 2;
  inline const ::TSCE::OwnerFormulaMapArchive& formula_map() const;
  inline ::TSCE::OwnerFormulaMapArchive* mutable_formula_map();
  inline ::TSCE::OwnerFormulaMapArchive* release_formula_map();
  inline void set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map);

  // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
  inline bool has_tectonic_shift() const;
  inline void clear_tectonic_shift();
  static const int kTectonicShiftFieldNumber = 3;
  inline const ::TSCE::TectonicShiftArchive& tectonic_shift() const;
  inline ::TSCE::TectonicShiftArchive* mutable_tectonic_shift();
  inline ::TSCE::TectonicShiftArchive* release_tectonic_shift();
  inline void set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFormulasForTectonicShiftArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_formula_map();
  inline void clear_has_formula_map();
  inline void set_has_tectonic_shift();
  inline void clear_has_tectonic_shift();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::OwnerFormulaMapArchive* formula_map_;
  ::TSCE::TectonicShiftArchive* tectonic_shift_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFormulasForTectonicShiftArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFormulasForMoveArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFormulasForMoveArchive();
  virtual ~CommandRewriteFormulasForMoveArchive();

  CommandRewriteFormulasForMoveArchive(const CommandRewriteFormulasForMoveArchive& from);

  inline CommandRewriteFormulasForMoveArchive& operator=(const CommandRewriteFormulasForMoveArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFormulasForMoveArchive& default_instance();

  void Swap(CommandRewriteFormulasForMoveArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFormulasForMoveArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFormulasForMoveArchive& from);
  void MergeFrom(const CommandRewriteFormulasForMoveArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  inline bool has_formula_map() const;
  inline void clear_formula_map();
  static const int kFormulaMapFieldNumber = 2;
  inline const ::TSCE::OwnerFormulaMapArchive& formula_map() const;
  inline ::TSCE::OwnerFormulaMapArchive* mutable_formula_map();
  inline ::TSCE::OwnerFormulaMapArchive* release_formula_map();
  inline void set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map);

  // required .TSCE.RangeReferenceArchive from_reference = 6;
  inline bool has_from_reference() const;
  inline void clear_from_reference();
  static const int kFromReferenceFieldNumber = 6;
  inline const ::TSCE::RangeReferenceArchive& from_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_from_reference();
  inline ::TSCE::RangeReferenceArchive* release_from_reference();
  inline void set_allocated_from_reference(::TSCE::RangeReferenceArchive* from_reference);

  // required .TSCE.RangeReferenceArchive to_reference = 7;
  inline bool has_to_reference() const;
  inline void clear_to_reference();
  static const int kToReferenceFieldNumber = 7;
  inline const ::TSCE::RangeReferenceArchive& to_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_to_reference();
  inline ::TSCE::RangeReferenceArchive* release_to_reference();
  inline void set_allocated_to_reference(::TSCE::RangeReferenceArchive* to_reference);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFormulasForMoveArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_formula_map();
  inline void clear_has_formula_map();
  inline void set_has_from_reference();
  inline void clear_has_from_reference();
  inline void set_has_to_reference();
  inline void clear_has_to_reference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::OwnerFormulaMapArchive* formula_map_;
  ::TSCE::RangeReferenceArchive* from_reference_;
  ::TSCE::RangeReferenceArchive* to_reference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFormulasForMoveArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFormulasForCellMergeArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFormulasForCellMergeArchive();
  virtual ~CommandRewriteFormulasForCellMergeArchive();

  CommandRewriteFormulasForCellMergeArchive(const CommandRewriteFormulasForCellMergeArchive& from);

  inline CommandRewriteFormulasForCellMergeArchive& operator=(const CommandRewriteFormulasForCellMergeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFormulasForCellMergeArchive& default_instance();

  void Swap(CommandRewriteFormulasForCellMergeArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFormulasForCellMergeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFormulasForCellMergeArchive& from);
  void MergeFrom(const CommandRewriteFormulasForCellMergeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  inline bool has_formula_map() const;
  inline void clear_formula_map();
  static const int kFormulaMapFieldNumber = 2;
  inline const ::TSCE::OwnerFormulaMapArchive& formula_map() const;
  inline ::TSCE::OwnerFormulaMapArchive* mutable_formula_map();
  inline ::TSCE::OwnerFormulaMapArchive* release_formula_map();
  inline void set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map);

  // required .TSCE.RangeCoordinateArchive merged_range = 3;
  inline bool has_merged_range() const;
  inline void clear_merged_range();
  static const int kMergedRangeFieldNumber = 3;
  inline const ::TSCE::RangeCoordinateArchive& merged_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_merged_range();
  inline ::TSCE::RangeCoordinateArchive* release_merged_range();
  inline void set_allocated_merged_range(::TSCE::RangeCoordinateArchive* merged_range);

  // required .TSCE.CFUUIDArchive table_id = 4;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 4;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFormulasForCellMergeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_formula_map();
  inline void clear_has_formula_map();
  inline void set_has_merged_range();
  inline void clear_has_merged_range();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::OwnerFormulaMapArchive* formula_map_;
  ::TSCE::RangeCoordinateArchive* merged_range_;
  ::TSCE::CFUUIDArchive* table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFormulasForCellMergeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFilterFormulasForTableResizeArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFilterFormulasForTableResizeArchive();
  virtual ~CommandRewriteFilterFormulasForTableResizeArchive();

  CommandRewriteFilterFormulasForTableResizeArchive(const CommandRewriteFilterFormulasForTableResizeArchive& from);

  inline CommandRewriteFilterFormulasForTableResizeArchive& operator=(const CommandRewriteFilterFormulasForTableResizeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFilterFormulasForTableResizeArchive& default_instance();

  void Swap(CommandRewriteFilterFormulasForTableResizeArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFilterFormulasForTableResizeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFilterFormulasForTableResizeArchive& from);
  void MergeFrom(const CommandRewriteFilterFormulasForTableResizeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFilterFormulasForTableResizeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFilterFormulasForTableResizeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFilterFormulasForTectonicShiftArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFilterFormulasForTectonicShiftArchive();
  virtual ~CommandRewriteFilterFormulasForTectonicShiftArchive();

  CommandRewriteFilterFormulasForTectonicShiftArchive(const CommandRewriteFilterFormulasForTectonicShiftArchive& from);

  inline CommandRewriteFilterFormulasForTectonicShiftArchive& operator=(const CommandRewriteFilterFormulasForTectonicShiftArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFilterFormulasForTectonicShiftArchive& default_instance();

  void Swap(CommandRewriteFilterFormulasForTectonicShiftArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFilterFormulasForTectonicShiftArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFilterFormulasForTectonicShiftArchive& from);
  void MergeFrom(const CommandRewriteFilterFormulasForTectonicShiftArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSP.Reference filter_set = 2;
  inline bool has_filter_set() const;
  inline void clear_filter_set();
  static const int kFilterSetFieldNumber = 2;
  inline const ::TSP::Reference& filter_set() const;
  inline ::TSP::Reference* mutable_filter_set();
  inline ::TSP::Reference* release_filter_set();
  inline void set_allocated_filter_set(::TSP::Reference* filter_set);

  // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
  inline bool has_tectonic_shift() const;
  inline void clear_tectonic_shift();
  static const int kTectonicShiftFieldNumber = 3;
  inline const ::TSCE::TectonicShiftArchive& tectonic_shift() const;
  inline ::TSCE::TectonicShiftArchive* mutable_tectonic_shift();
  inline ::TSCE::TectonicShiftArchive* release_tectonic_shift();
  inline void set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_filter_set();
  inline void clear_has_filter_set();
  inline void set_has_tectonic_shift();
  inline void clear_has_tectonic_shift();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* filter_set_;
  ::TSCE::TectonicShiftArchive* tectonic_shift_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFilterFormulasForTectonicShiftArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteFilterFormulasForSortArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteFilterFormulasForSortArchive();
  virtual ~CommandRewriteFilterFormulasForSortArchive();

  CommandRewriteFilterFormulasForSortArchive(const CommandRewriteFilterFormulasForSortArchive& from);

  inline CommandRewriteFilterFormulasForSortArchive& operator=(const CommandRewriteFilterFormulasForSortArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteFilterFormulasForSortArchive& default_instance();

  void Swap(CommandRewriteFilterFormulasForSortArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteFilterFormulasForSortArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteFilterFormulasForSortArchive& from);
  void MergeFrom(const CommandRewriteFilterFormulasForSortArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSP.Reference filter_set = 2;
  inline bool has_filter_set() const;
  inline void clear_filter_set();
  static const int kFilterSetFieldNumber = 2;
  inline const ::TSP::Reference& filter_set() const;
  inline ::TSP::Reference* mutable_filter_set();
  inline ::TSP::Reference* release_filter_set();
  inline void set_allocated_filter_set(::TSP::Reference* filter_set);

  // required .TSK.ShuffleMappingArchive sort_mapping = 3;
  inline bool has_sort_mapping() const;
  inline void clear_sort_mapping();
  static const int kSortMappingFieldNumber = 3;
  inline const ::TSK::ShuffleMappingArchive& sort_mapping() const;
  inline ::TSK::ShuffleMappingArchive* mutable_sort_mapping();
  inline ::TSK::ShuffleMappingArchive* release_sort_mapping();
  inline void set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping);

  // required .TSCE.CFUUIDArchive sorted_table_id = 4;
  inline bool has_sorted_table_id() const;
  inline void clear_sorted_table_id();
  static const int kSortedTableIdFieldNumber = 4;
  inline const ::TSCE::CFUUIDArchive& sorted_table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_sorted_table_id();
  inline ::TSCE::CFUUIDArchive* release_sorted_table_id();
  inline void set_allocated_sorted_table_id(::TSCE::CFUUIDArchive* sorted_table_id);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteFilterFormulasForSortArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_filter_set();
  inline void clear_has_filter_set();
  inline void set_has_sort_mapping();
  inline void clear_has_sort_mapping();
  inline void set_has_sorted_table_id();
  inline void clear_has_sorted_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSP::Reference* filter_set_;
  ::TSK::ShuffleMappingArchive* sort_mapping_;
  ::TSCE::CFUUIDArchive* sorted_table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteFilterFormulasForSortArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteConditionalStylesForTectonicShiftArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteConditionalStylesForTectonicShiftArchive();
  virtual ~CommandRewriteConditionalStylesForTectonicShiftArchive();

  CommandRewriteConditionalStylesForTectonicShiftArchive(const CommandRewriteConditionalStylesForTectonicShiftArchive& from);

  inline CommandRewriteConditionalStylesForTectonicShiftArchive& operator=(const CommandRewriteConditionalStylesForTectonicShiftArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteConditionalStylesForTectonicShiftArchive& default_instance();

  void Swap(CommandRewriteConditionalStylesForTectonicShiftArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteConditionalStylesForTectonicShiftArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteConditionalStylesForTectonicShiftArchive& from);
  void MergeFrom(const CommandRewriteConditionalStylesForTectonicShiftArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.TectonicShiftArchive tectonic_shift = 2;
  inline bool has_tectonic_shift() const;
  inline void clear_tectonic_shift();
  static const int kTectonicShiftFieldNumber = 2;
  inline const ::TSCE::TectonicShiftArchive& tectonic_shift() const;
  inline ::TSCE::TectonicShiftArchive* mutable_tectonic_shift();
  inline ::TSCE::TectonicShiftArchive* release_tectonic_shift();
  inline void set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift);

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 3;
  inline bool has_cells_to_rewrite() const;
  inline void clear_cells_to_rewrite();
  static const int kCellsToRewriteFieldNumber = 3;
  inline const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite() const;
  inline ::TSCE::CellCoordinateVectorArchive* mutable_cells_to_rewrite();
  inline ::TSCE::CellCoordinateVectorArchive* release_cells_to_rewrite();
  inline void set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite);

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 4;
  inline bool has_conditional_style_sets() const;
  inline void clear_conditional_style_sets();
  static const int kConditionalStyleSetsFieldNumber = 4;
  inline const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets() const;
  inline ::TSCE::CellCoordinateObjectMapArchive* mutable_conditional_style_sets();
  inline ::TSCE::CellCoordinateObjectMapArchive* release_conditional_style_sets();
  inline void set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_tectonic_shift();
  inline void clear_has_tectonic_shift();
  inline void set_has_cells_to_rewrite();
  inline void clear_has_cells_to_rewrite();
  inline void set_has_conditional_style_sets();
  inline void clear_has_conditional_style_sets();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::TectonicShiftArchive* tectonic_shift_;
  ::TSCE::CellCoordinateVectorArchive* cells_to_rewrite_;
  ::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteConditionalStylesForTectonicShiftArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteConditionalStylesForSortArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteConditionalStylesForSortArchive();
  virtual ~CommandRewriteConditionalStylesForSortArchive();

  CommandRewriteConditionalStylesForSortArchive(const CommandRewriteConditionalStylesForSortArchive& from);

  inline CommandRewriteConditionalStylesForSortArchive& operator=(const CommandRewriteConditionalStylesForSortArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteConditionalStylesForSortArchive& default_instance();

  void Swap(CommandRewriteConditionalStylesForSortArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteConditionalStylesForSortArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteConditionalStylesForSortArchive& from);
  void MergeFrom(const CommandRewriteConditionalStylesForSortArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSK.ShuffleMappingArchive sort_mapping = 2;
  inline bool has_sort_mapping() const;
  inline void clear_sort_mapping();
  static const int kSortMappingFieldNumber = 2;
  inline const ::TSK::ShuffleMappingArchive& sort_mapping() const;
  inline ::TSK::ShuffleMappingArchive* mutable_sort_mapping();
  inline ::TSK::ShuffleMappingArchive* release_sort_mapping();
  inline void set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping);

  // required .TSCE.CFUUIDArchive sorted_table_id = 3;
  inline bool has_sorted_table_id() const;
  inline void clear_sorted_table_id();
  static const int kSortedTableIdFieldNumber = 3;
  inline const ::TSCE::CFUUIDArchive& sorted_table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_sorted_table_id();
  inline ::TSCE::CFUUIDArchive* release_sorted_table_id();
  inline void set_allocated_sorted_table_id(::TSCE::CFUUIDArchive* sorted_table_id);

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
  inline bool has_cells_to_rewrite() const;
  inline void clear_cells_to_rewrite();
  static const int kCellsToRewriteFieldNumber = 4;
  inline const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite() const;
  inline ::TSCE::CellCoordinateVectorArchive* mutable_cells_to_rewrite();
  inline ::TSCE::CellCoordinateVectorArchive* release_cells_to_rewrite();
  inline void set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite);

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
  inline bool has_conditional_style_sets() const;
  inline void clear_conditional_style_sets();
  static const int kConditionalStyleSetsFieldNumber = 5;
  inline const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets() const;
  inline ::TSCE::CellCoordinateObjectMapArchive* mutable_conditional_style_sets();
  inline ::TSCE::CellCoordinateObjectMapArchive* release_conditional_style_sets();
  inline void set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteConditionalStylesForSortArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sort_mapping();
  inline void clear_has_sort_mapping();
  inline void set_has_sorted_table_id();
  inline void clear_has_sorted_table_id();
  inline void set_has_cells_to_rewrite();
  inline void clear_has_cells_to_rewrite();
  inline void set_has_conditional_style_sets();
  inline void clear_has_conditional_style_sets();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSK::ShuffleMappingArchive* sort_mapping_;
  ::TSCE::CFUUIDArchive* sorted_table_id_;
  ::TSCE::CellCoordinateVectorArchive* cells_to_rewrite_;
  ::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteConditionalStylesForSortArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteConditionalStylesForRangeMoveArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteConditionalStylesForRangeMoveArchive();
  virtual ~CommandRewriteConditionalStylesForRangeMoveArchive();

  CommandRewriteConditionalStylesForRangeMoveArchive(const CommandRewriteConditionalStylesForRangeMoveArchive& from);

  inline CommandRewriteConditionalStylesForRangeMoveArchive& operator=(const CommandRewriteConditionalStylesForRangeMoveArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteConditionalStylesForRangeMoveArchive& default_instance();

  void Swap(CommandRewriteConditionalStylesForRangeMoveArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteConditionalStylesForRangeMoveArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteConditionalStylesForRangeMoveArchive& from);
  void MergeFrom(const CommandRewriteConditionalStylesForRangeMoveArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TSCE.RangeReferenceArchive from_range_reference = 7;
  inline bool has_from_range_reference() const;
  inline void clear_from_range_reference();
  static const int kFromRangeReferenceFieldNumber = 7;
  inline const ::TSCE::RangeReferenceArchive& from_range_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_from_range_reference();
  inline ::TSCE::RangeReferenceArchive* release_from_range_reference();
  inline void set_allocated_from_range_reference(::TSCE::RangeReferenceArchive* from_range_reference);

  // optional .TSCE.RangeReferenceArchive to_range_reference = 8;
  inline bool has_to_range_reference() const;
  inline void clear_to_range_reference();
  static const int kToRangeReferenceFieldNumber = 8;
  inline const ::TSCE::RangeReferenceArchive& to_range_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_to_range_reference();
  inline ::TSCE::RangeReferenceArchive* release_to_range_reference();
  inline void set_allocated_to_range_reference(::TSCE::RangeReferenceArchive* to_range_reference);

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 5;
  inline bool has_cells_to_rewrite() const;
  inline void clear_cells_to_rewrite();
  static const int kCellsToRewriteFieldNumber = 5;
  inline const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite() const;
  inline ::TSCE::CellCoordinateVectorArchive* mutable_cells_to_rewrite();
  inline ::TSCE::CellCoordinateVectorArchive* release_cells_to_rewrite();
  inline void set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite);

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 6;
  inline bool has_conditional_style_sets() const;
  inline void clear_conditional_style_sets();
  static const int kConditionalStyleSetsFieldNumber = 6;
  inline const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets() const;
  inline ::TSCE::CellCoordinateObjectMapArchive* mutable_conditional_style_sets();
  inline ::TSCE::CellCoordinateObjectMapArchive* release_conditional_style_sets();
  inline void set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_from_range_reference();
  inline void clear_has_from_range_reference();
  inline void set_has_to_range_reference();
  inline void clear_has_to_range_reference();
  inline void set_has_cells_to_rewrite();
  inline void clear_has_cells_to_rewrite();
  inline void set_has_conditional_style_sets();
  inline void clear_has_conditional_style_sets();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::RangeReferenceArchive* from_range_reference_;
  ::TSCE::RangeReferenceArchive* to_range_reference_;
  ::TSCE::CellCoordinateVectorArchive* cells_to_rewrite_;
  ::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteConditionalStylesForRangeMoveArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteConditionalStylesForCellMergeArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteConditionalStylesForCellMergeArchive();
  virtual ~CommandRewriteConditionalStylesForCellMergeArchive();

  CommandRewriteConditionalStylesForCellMergeArchive(const CommandRewriteConditionalStylesForCellMergeArchive& from);

  inline CommandRewriteConditionalStylesForCellMergeArchive& operator=(const CommandRewriteConditionalStylesForCellMergeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteConditionalStylesForCellMergeArchive& default_instance();

  void Swap(CommandRewriteConditionalStylesForCellMergeArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteConditionalStylesForCellMergeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteConditionalStylesForCellMergeArchive& from);
  void MergeFrom(const CommandRewriteConditionalStylesForCellMergeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.CFUUIDArchive merged_table_id = 2;
  inline bool has_merged_table_id() const;
  inline void clear_merged_table_id();
  static const int kMergedTableIdFieldNumber = 2;
  inline const ::TSCE::CFUUIDArchive& merged_table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_merged_table_id();
  inline ::TSCE::CFUUIDArchive* release_merged_table_id();
  inline void set_allocated_merged_table_id(::TSCE::CFUUIDArchive* merged_table_id);

  // required .TSCE.RangeCoordinateArchive merged_range = 3;
  inline bool has_merged_range() const;
  inline void clear_merged_range();
  static const int kMergedRangeFieldNumber = 3;
  inline const ::TSCE::RangeCoordinateArchive& merged_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_merged_range();
  inline ::TSCE::RangeCoordinateArchive* release_merged_range();
  inline void set_allocated_merged_range(::TSCE::RangeCoordinateArchive* merged_range);

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
  inline bool has_cells_to_rewrite() const;
  inline void clear_cells_to_rewrite();
  static const int kCellsToRewriteFieldNumber = 4;
  inline const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite() const;
  inline ::TSCE::CellCoordinateVectorArchive* mutable_cells_to_rewrite();
  inline ::TSCE::CellCoordinateVectorArchive* release_cells_to_rewrite();
  inline void set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite);

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
  inline bool has_conditional_style_sets() const;
  inline void clear_conditional_style_sets();
  static const int kConditionalStyleSetsFieldNumber = 5;
  inline const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets() const;
  inline ::TSCE::CellCoordinateObjectMapArchive* mutable_conditional_style_sets();
  inline ::TSCE::CellCoordinateObjectMapArchive* release_conditional_style_sets();
  inline void set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteConditionalStylesForCellMergeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_merged_table_id();
  inline void clear_has_merged_table_id();
  inline void set_has_merged_range();
  inline void clear_has_merged_range();
  inline void set_has_cells_to_rewrite();
  inline void clear_has_cells_to_rewrite();
  inline void set_has_conditional_style_sets();
  inline void clear_has_conditional_style_sets();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::CFUUIDArchive* merged_table_id_;
  ::TSCE::RangeCoordinateArchive* merged_range_;
  ::TSCE::CellCoordinateVectorArchive* cells_to_rewrite_;
  ::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteConditionalStylesForCellMergeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMergeUnmergeArchive : public ::google::protobuf::Message {
 public:
  CommandMergeUnmergeArchive();
  virtual ~CommandMergeUnmergeArchive();

  CommandMergeUnmergeArchive(const CommandMergeUnmergeArchive& from);

  inline CommandMergeUnmergeArchive& operator=(const CommandMergeUnmergeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMergeUnmergeArchive& default_instance();

  void Swap(CommandMergeUnmergeArchive* other);

  // implements Message ----------------------------------------------

  CommandMergeUnmergeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMergeUnmergeArchive& from);
  void MergeFrom(const CommandMergeUnmergeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.MergeActionArchive merge_action = 2;
  inline bool has_merge_action() const;
  inline void clear_merge_action();
  static const int kMergeActionFieldNumber = 2;
  inline ::TST::MergeActionArchive merge_action() const;
  inline void set_merge_action(::TST::MergeActionArchive value);

  // required .TST.SelectionArchive selection = 3;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 3;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_cell_map = 4;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 5;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 5;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // optional .TSP.Reference old_merge_ranges = 8;
  inline bool has_old_merge_ranges() const;
  inline void clear_old_merge_ranges();
  static const int kOldMergeRangesFieldNumber = 8;
  inline const ::TSP::Reference& old_merge_ranges() const;
  inline ::TSP::Reference* mutable_old_merge_ranges();
  inline ::TSP::Reference* release_old_merge_ranges();
  inline void set_allocated_old_merge_ranges(::TSP::Reference* old_merge_ranges);

  // optional .TSP.Reference undo_formula_rewrite_command = 9;
  inline bool has_undo_formula_rewrite_command() const;
  inline void clear_undo_formula_rewrite_command();
  static const int kUndoFormulaRewriteCommandFieldNumber = 9;
  inline const ::TSP::Reference& undo_formula_rewrite_command() const;
  inline ::TSP::Reference* mutable_undo_formula_rewrite_command();
  inline ::TSP::Reference* release_undo_formula_rewrite_command();
  inline void set_allocated_undo_formula_rewrite_command(::TSP::Reference* undo_formula_rewrite_command);

  // @@protoc_insertion_point(class_scope:TST.CommandMergeUnmergeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_merge_action();
  inline void clear_has_merge_action();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_old_merge_ranges();
  inline void clear_has_old_merge_ranges();
  inline void set_has_undo_formula_rewrite_command();
  inline void clear_has_undo_formula_rewrite_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TSP::Reference* old_merge_ranges_;
  ::TSP::Reference* undo_formula_rewrite_command_;
  int merge_action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMergeUnmergeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandHideShowArchive : public ::google::protobuf::Message {
 public:
  CommandHideShowArchive();
  virtual ~CommandHideShowArchive();

  CommandHideShowArchive(const CommandHideShowArchive& from);

  inline CommandHideShowArchive& operator=(const CommandHideShowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandHideShowArchive& default_instance();

  void Swap(CommandHideShowArchive* other);

  // implements Message ----------------------------------------------

  CommandHideShowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandHideShowArchive& from);
  void MergeFrom(const CommandHideShowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CommandDirectionArchive direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::TST::CommandDirectionArchive direction() const;
  inline void set_direction(::TST::CommandDirectionArchive value);

  // required .TST.HideShowActionArchive hide_show_action = 3;
  inline bool has_hide_show_action() const;
  inline void clear_hide_show_action();
  static const int kHideShowActionFieldNumber = 3;
  inline ::TST::HideShowActionArchive hide_show_action() const;
  inline void set_hide_show_action(::TST::HideShowActionArchive value);

  // required uint32 hiding_action = 4;
  inline bool has_hiding_action() const;
  inline void clear_hiding_action();
  static const int kHidingActionFieldNumber = 4;
  inline ::google::protobuf::uint32 hiding_action() const;
  inline void set_hiding_action(::google::protobuf::uint32 value);

  // required .TSP.IndexSet elements_affected = 5;
  inline bool has_elements_affected() const;
  inline void clear_elements_affected();
  static const int kElementsAffectedFieldNumber = 5;
  inline const ::TSP::IndexSet& elements_affected() const;
  inline ::TSP::IndexSet* mutable_elements_affected();
  inline ::TSP::IndexSet* release_elements_affected();
  inline void set_allocated_elements_affected(::TSP::IndexSet* elements_affected);

  // repeated uint32 old_hiding_states = 7;
  inline int old_hiding_states_size() const;
  inline void clear_old_hiding_states();
  static const int kOldHidingStatesFieldNumber = 7;
  inline ::google::protobuf::uint32 old_hiding_states(int index) const;
  inline void set_old_hiding_states(int index, ::google::protobuf::uint32 value);
  inline void add_old_hiding_states(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      old_hiding_states() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_old_hiding_states();

  // @@protoc_insertion_point(class_scope:TST.CommandHideShowArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_hide_show_action();
  inline void clear_has_hide_show_action();
  inline void set_has_hiding_action();
  inline void clear_has_hiding_action();
  inline void set_has_elements_affected();
  inline void clear_has_elements_affected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  int direction_;
  int hide_show_action_;
  ::TSP::IndexSet* elements_affected_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > old_hiding_states_;
  ::google::protobuf::uint32 hiding_action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandHideShowArchive* default_instance_;
};
// -------------------------------------------------------------------

class TableInfoGeometryCommandArchive : public ::google::protobuf::Message {
 public:
  TableInfoGeometryCommandArchive();
  virtual ~TableInfoGeometryCommandArchive();

  TableInfoGeometryCommandArchive(const TableInfoGeometryCommandArchive& from);

  inline TableInfoGeometryCommandArchive& operator=(const TableInfoGeometryCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableInfoGeometryCommandArchive& default_instance();

  void Swap(TableInfoGeometryCommandArchive* other);

  // implements Message ----------------------------------------------

  TableInfoGeometryCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableInfoGeometryCommandArchive& from);
  void MergeFrom(const TableInfoGeometryCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Size scale_factor = 2;
  inline bool has_scale_factor() const;
  inline void clear_scale_factor();
  static const int kScaleFactorFieldNumber = 2;
  inline const ::TSP::Size& scale_factor() const;
  inline ::TSP::Size* mutable_scale_factor();
  inline ::TSP::Size* release_scale_factor();
  inline void set_allocated_scale_factor(::TSP::Size* scale_factor);

  // optional .TSP.Reference table_info = 3;
  inline bool has_table_info() const;
  inline void clear_table_info();
  static const int kTableInfoFieldNumber = 3;
  inline const ::TSP::Reference& table_info() const;
  inline ::TSP::Reference* mutable_table_info();
  inline ::TSP::Reference* release_table_info();
  inline void set_allocated_table_info(::TSP::Reference* table_info);

  // optional .TSD.GeometryArchive new_geometry = 4;
  inline bool has_new_geometry() const;
  inline void clear_new_geometry();
  static const int kNewGeometryFieldNumber = 4;
  inline const ::TSD::GeometryArchive& new_geometry() const;
  inline ::TSD::GeometryArchive* mutable_new_geometry();
  inline ::TSD::GeometryArchive* release_new_geometry();
  inline void set_allocated_new_geometry(::TSD::GeometryArchive* new_geometry);

  // optional .TSD.GeometryArchive old_geometry = 5;
  inline bool has_old_geometry() const;
  inline void clear_old_geometry();
  static const int kOldGeometryFieldNumber = 5;
  inline const ::TSD::GeometryArchive& old_geometry() const;
  inline ::TSD::GeometryArchive* mutable_old_geometry();
  inline ::TSD::GeometryArchive* release_old_geometry();
  inline void set_allocated_old_geometry(::TSD::GeometryArchive* old_geometry);

  // optional bool turn_off_auto_resize = 6;
  inline bool has_turn_off_auto_resize() const;
  inline void clear_turn_off_auto_resize();
  static const int kTurnOffAutoResizeFieldNumber = 6;
  inline bool turn_off_auto_resize() const;
  inline void set_turn_off_auto_resize(bool value);

  // optional bool should_clear_object_placeholder_flag = 7;
  inline bool has_should_clear_object_placeholder_flag() const;
  inline void clear_should_clear_object_placeholder_flag();
  static const int kShouldClearObjectPlaceholderFlagFieldNumber = 7;
  inline bool should_clear_object_placeholder_flag() const;
  inline void set_should_clear_object_placeholder_flag(bool value);

  // optional bool did_match_object_placeholder_geometry = 8;
  inline bool has_did_match_object_placeholder_geometry() const;
  inline void clear_did_match_object_placeholder_geometry();
  static const int kDidMatchObjectPlaceholderGeometryFieldNumber = 8;
  inline bool did_match_object_placeholder_geometry() const;
  inline void set_did_match_object_placeholder_geometry(bool value);

  // @@protoc_insertion_point(class_scope:TST.TableInfoGeometryCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_scale_factor();
  inline void clear_has_scale_factor();
  inline void set_has_table_info();
  inline void clear_has_table_info();
  inline void set_has_new_geometry();
  inline void clear_has_new_geometry();
  inline void set_has_old_geometry();
  inline void clear_has_old_geometry();
  inline void set_has_turn_off_auto_resize();
  inline void clear_has_turn_off_auto_resize();
  inline void set_has_should_clear_object_placeholder_flag();
  inline void clear_has_should_clear_object_placeholder_flag();
  inline void set_has_did_match_object_placeholder_geometry();
  inline void clear_has_did_match_object_placeholder_geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Size* scale_factor_;
  ::TSP::Reference* table_info_;
  ::TSD::GeometryArchive* new_geometry_;
  ::TSD::GeometryArchive* old_geometry_;
  bool turn_off_auto_resize_;
  bool should_clear_object_placeholder_flag_;
  bool did_match_object_placeholder_geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static TableInfoGeometryCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaEditingCommandGroupArchive : public ::google::protobuf::Message {
 public:
  FormulaEditingCommandGroupArchive();
  virtual ~FormulaEditingCommandGroupArchive();

  FormulaEditingCommandGroupArchive(const FormulaEditingCommandGroupArchive& from);

  inline FormulaEditingCommandGroupArchive& operator=(const FormulaEditingCommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaEditingCommandGroupArchive& default_instance();

  void Swap(FormulaEditingCommandGroupArchive* other);

  // implements Message ----------------------------------------------

  FormulaEditingCommandGroupArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaEditingCommandGroupArchive& from);
  void MergeFrom(const FormulaEditingCommandGroupArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.ProgressiveCommandGroupArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::ProgressiveCommandGroupArchive& super() const;
  inline ::TSK::ProgressiveCommandGroupArchive* mutable_super();
  inline ::TSK::ProgressiveCommandGroupArchive* release_super();
  inline void set_allocated_super(::TSK::ProgressiveCommandGroupArchive* super);

  // required bool undoSelectionValid = 2;
  inline bool has_undoselectionvalid() const;
  inline void clear_undoselectionvalid();
  static const int kUndoSelectionValidFieldNumber = 2;
  inline bool undoselectionvalid() const;
  inline void set_undoselectionvalid(bool value);

  // required uint32 undoSelectionStart = 3;
  inline bool has_undoselectionstart() const;
  inline void clear_undoselectionstart();
  static const int kUndoSelectionStartFieldNumber = 3;
  inline ::google::protobuf::uint32 undoselectionstart() const;
  inline void set_undoselectionstart(::google::protobuf::uint32 value);

  // required uint32 undoSelectionLength = 4;
  inline bool has_undoselectionlength() const;
  inline void clear_undoselectionlength();
  static const int kUndoSelectionLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 undoselectionlength() const;
  inline void set_undoselectionlength(::google::protobuf::uint32 value);

  // required uint32 undoActiveToken = 5;
  inline bool has_undoactivetoken() const;
  inline void clear_undoactivetoken();
  static const int kUndoActiveTokenFieldNumber = 5;
  inline ::google::protobuf::uint32 undoactivetoken() const;
  inline void set_undoactivetoken(::google::protobuf::uint32 value);

  // required bool redoSelectionValid = 6;
  inline bool has_redoselectionvalid() const;
  inline void clear_redoselectionvalid();
  static const int kRedoSelectionValidFieldNumber = 6;
  inline bool redoselectionvalid() const;
  inline void set_redoselectionvalid(bool value);

  // required uint32 redoSelectionStart = 7;
  inline bool has_redoselectionstart() const;
  inline void clear_redoselectionstart();
  static const int kRedoSelectionStartFieldNumber = 7;
  inline ::google::protobuf::uint32 redoselectionstart() const;
  inline void set_redoselectionstart(::google::protobuf::uint32 value);

  // required uint32 redoSelectionLength = 8;
  inline bool has_redoselectionlength() const;
  inline void clear_redoselectionlength();
  static const int kRedoSelectionLengthFieldNumber = 8;
  inline ::google::protobuf::uint32 redoselectionlength() const;
  inline void set_redoselectionlength(::google::protobuf::uint32 value);

  // required uint32 redoActiveToken = 9;
  inline bool has_redoactivetoken() const;
  inline void clear_redoactivetoken();
  static const int kRedoActiveTokenFieldNumber = 9;
  inline ::google::protobuf::uint32 redoactivetoken() const;
  inline void set_redoactivetoken(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.FormulaEditingCommandGroupArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undoselectionvalid();
  inline void clear_has_undoselectionvalid();
  inline void set_has_undoselectionstart();
  inline void clear_has_undoselectionstart();
  inline void set_has_undoselectionlength();
  inline void clear_has_undoselectionlength();
  inline void set_has_undoactivetoken();
  inline void clear_has_undoactivetoken();
  inline void set_has_redoselectionvalid();
  inline void clear_has_redoselectionvalid();
  inline void set_has_redoselectionstart();
  inline void clear_has_redoselectionstart();
  inline void set_has_redoselectionlength();
  inline void clear_has_redoselectionlength();
  inline void set_has_redoactivetoken();
  inline void clear_has_redoactivetoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::ProgressiveCommandGroupArchive* super_;
  ::google::protobuf::uint32 undoselectionstart_;
  ::google::protobuf::uint32 undoselectionlength_;
  bool undoselectionvalid_;
  bool redoselectionvalid_;
  ::google::protobuf::uint32 undoactivetoken_;
  ::google::protobuf::uint32 redoselectionstart_;
  ::google::protobuf::uint32 redoselectionlength_;
  ::google::protobuf::uint32 redoactivetoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaEditingCommandGroupArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaEditingCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  FormulaEditingCommandSelectionBehaviorArchive();
  virtual ~FormulaEditingCommandSelectionBehaviorArchive();

  FormulaEditingCommandSelectionBehaviorArchive(const FormulaEditingCommandSelectionBehaviorArchive& from);

  inline FormulaEditingCommandSelectionBehaviorArchive& operator=(const FormulaEditingCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaEditingCommandSelectionBehaviorArchive& default_instance();

  void Swap(FormulaEditingCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  FormulaEditingCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaEditingCommandSelectionBehaviorArchive& from);
  void MergeFrom(const FormulaEditingCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool undoSelectionValid = 2;
  inline bool has_undoselectionvalid() const;
  inline void clear_undoselectionvalid();
  static const int kUndoSelectionValidFieldNumber = 2;
  inline bool undoselectionvalid() const;
  inline void set_undoselectionvalid(bool value);

  // optional uint32 undoSelectionStart = 3;
  inline bool has_undoselectionstart() const;
  inline void clear_undoselectionstart();
  static const int kUndoSelectionStartFieldNumber = 3;
  inline ::google::protobuf::uint32 undoselectionstart() const;
  inline void set_undoselectionstart(::google::protobuf::uint32 value);

  // optional uint32 undoSelectionLength = 4;
  inline bool has_undoselectionlength() const;
  inline void clear_undoselectionlength();
  static const int kUndoSelectionLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 undoselectionlength() const;
  inline void set_undoselectionlength(::google::protobuf::uint32 value);

  // optional uint32 undoActiveToken = 5;
  inline bool has_undoactivetoken() const;
  inline void clear_undoactivetoken();
  static const int kUndoActiveTokenFieldNumber = 5;
  inline ::google::protobuf::uint32 undoactivetoken() const;
  inline void set_undoactivetoken(::google::protobuf::uint32 value);

  // optional bool redoSelectionValid = 6;
  inline bool has_redoselectionvalid() const;
  inline void clear_redoselectionvalid();
  static const int kRedoSelectionValidFieldNumber = 6;
  inline bool redoselectionvalid() const;
  inline void set_redoselectionvalid(bool value);

  // optional uint32 redoSelectionStart = 7;
  inline bool has_redoselectionstart() const;
  inline void clear_redoselectionstart();
  static const int kRedoSelectionStartFieldNumber = 7;
  inline ::google::protobuf::uint32 redoselectionstart() const;
  inline void set_redoselectionstart(::google::protobuf::uint32 value);

  // optional uint32 redoSelectionLength = 8;
  inline bool has_redoselectionlength() const;
  inline void clear_redoselectionlength();
  static const int kRedoSelectionLengthFieldNumber = 8;
  inline ::google::protobuf::uint32 redoselectionlength() const;
  inline void set_redoselectionlength(::google::protobuf::uint32 value);

  // optional uint32 redoActiveToken = 9;
  inline bool has_redoactivetoken() const;
  inline void clear_redoactivetoken();
  static const int kRedoActiveTokenFieldNumber = 9;
  inline ::google::protobuf::uint32 redoactivetoken() const;
  inline void set_redoactivetoken(::google::protobuf::uint32 value);

  // optional .TSP.Reference storage = 10;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 10;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // @@protoc_insertion_point(class_scope:TST.FormulaEditingCommandSelectionBehaviorArchive)
 private:
  inline void set_has_undoselectionvalid();
  inline void clear_has_undoselectionvalid();
  inline void set_has_undoselectionstart();
  inline void clear_has_undoselectionstart();
  inline void set_has_undoselectionlength();
  inline void clear_has_undoselectionlength();
  inline void set_has_undoactivetoken();
  inline void clear_has_undoactivetoken();
  inline void set_has_redoselectionvalid();
  inline void clear_has_redoselectionvalid();
  inline void set_has_redoselectionstart();
  inline void clear_has_redoselectionstart();
  inline void set_has_redoselectionlength();
  inline void clear_has_redoselectionlength();
  inline void set_has_redoactivetoken();
  inline void clear_has_redoactivetoken();
  inline void set_has_storage();
  inline void clear_has_storage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 undoselectionstart_;
  ::google::protobuf::uint32 undoselectionlength_;
  bool undoselectionvalid_;
  bool redoselectionvalid_;
  ::google::protobuf::uint32 undoactivetoken_;
  ::google::protobuf::uint32 redoselectionstart_;
  ::google::protobuf::uint32 redoselectionlength_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 redoactivetoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaEditingCommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class UndoRedoStateCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  UndoRedoStateCommandSelectionBehaviorArchive();
  virtual ~UndoRedoStateCommandSelectionBehaviorArchive();

  UndoRedoStateCommandSelectionBehaviorArchive(const UndoRedoStateCommandSelectionBehaviorArchive& from);

  inline UndoRedoStateCommandSelectionBehaviorArchive& operator=(const UndoRedoStateCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoRedoStateCommandSelectionBehaviorArchive& default_instance();

  void Swap(UndoRedoStateCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  UndoRedoStateCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from);
  void MergeFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference before_undo_redo_state = 1 [deprecated = true];
  inline bool has_before_undo_redo_state() const PROTOBUF_DEPRECATED;
  inline void clear_before_undo_redo_state() PROTOBUF_DEPRECATED;
  static const int kBeforeUndoRedoStateFieldNumber = 1;
  inline const ::TSP::Reference& before_undo_redo_state() const PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* mutable_before_undo_redo_state() PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* release_before_undo_redo_state() PROTOBUF_DEPRECATED;
  inline void set_allocated_before_undo_redo_state(::TSP::Reference* before_undo_redo_state) PROTOBUF_DEPRECATED;

  // optional .TSP.Reference after_undo_redo_state = 2 [deprecated = true];
  inline bool has_after_undo_redo_state() const PROTOBUF_DEPRECATED;
  inline void clear_after_undo_redo_state() PROTOBUF_DEPRECATED;
  static const int kAfterUndoRedoStateFieldNumber = 2;
  inline const ::TSP::Reference& after_undo_redo_state() const PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* mutable_after_undo_redo_state() PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* release_after_undo_redo_state() PROTOBUF_DEPRECATED;
  inline void set_allocated_after_undo_redo_state(::TSP::Reference* after_undo_redo_state) PROTOBUF_DEPRECATED;

  // optional .TSP.Reference table_info = 3;
  inline bool has_table_info() const;
  inline void clear_table_info();
  static const int kTableInfoFieldNumber = 3;
  inline const ::TSP::Reference& table_info() const;
  inline ::TSP::Reference* mutable_table_info();
  inline ::TSP::Reference* release_table_info();
  inline void set_allocated_table_info(::TSP::Reference* table_info);

  // optional .TST.SelectionArchive before_table_selection = 4;
  inline bool has_before_table_selection() const;
  inline void clear_before_table_selection();
  static const int kBeforeTableSelectionFieldNumber = 4;
  inline const ::TST::SelectionArchive& before_table_selection() const;
  inline ::TST::SelectionArchive* mutable_before_table_selection();
  inline ::TST::SelectionArchive* release_before_table_selection();
  inline void set_allocated_before_table_selection(::TST::SelectionArchive* before_table_selection);

  // optional .TST.SelectionArchive after_table_selection = 6;
  inline bool has_after_table_selection() const;
  inline void clear_after_table_selection();
  static const int kAfterTableSelectionFieldNumber = 6;
  inline const ::TST::SelectionArchive& after_table_selection() const;
  inline ::TST::SelectionArchive* mutable_after_table_selection();
  inline ::TST::SelectionArchive* release_after_table_selection();
  inline void set_allocated_after_table_selection(::TST::SelectionArchive* after_table_selection);

  // @@protoc_insertion_point(class_scope:TST.UndoRedoStateCommandSelectionBehaviorArchive)
 private:
  inline void set_has_before_undo_redo_state();
  inline void clear_has_before_undo_redo_state();
  inline void set_has_after_undo_redo_state();
  inline void clear_has_after_undo_redo_state();
  inline void set_has_table_info();
  inline void clear_has_table_info();
  inline void set_has_before_table_selection();
  inline void clear_has_before_table_selection();
  inline void set_has_after_table_selection();
  inline void clear_has_after_table_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* before_undo_redo_state_;
  ::TSP::Reference* after_undo_redo_state_;
  ::TSP::Reference* table_info_;
  ::TST::SelectionArchive* before_table_selection_;
  ::TST::SelectionArchive* after_table_selection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoRedoStateCommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class TableCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  TableCommandSelectionBehaviorArchive();
  virtual ~TableCommandSelectionBehaviorArchive();

  TableCommandSelectionBehaviorArchive(const TableCommandSelectionBehaviorArchive& from);

  inline TableCommandSelectionBehaviorArchive& operator=(const TableCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableCommandSelectionBehaviorArchive& default_instance();

  void Swap(TableCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  TableCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableCommandSelectionBehaviorArchive& from);
  void MergeFrom(const TableCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TST.SelectionArchive before_table_selection = 1;
  inline bool has_before_table_selection() const;
  inline void clear_before_table_selection();
  static const int kBeforeTableSelectionFieldNumber = 1;
  inline const ::TST::SelectionArchive& before_table_selection() const;
  inline ::TST::SelectionArchive* mutable_before_table_selection();
  inline ::TST::SelectionArchive* release_before_table_selection();
  inline void set_allocated_before_table_selection(::TST::SelectionArchive* before_table_selection);

  // optional .TST.SelectionArchive after_table_selection = 2;
  inline bool has_after_table_selection() const;
  inline void clear_after_table_selection();
  static const int kAfterTableSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& after_table_selection() const;
  inline ::TST::SelectionArchive* mutable_after_table_selection();
  inline ::TST::SelectionArchive* release_after_table_selection();
  inline void set_allocated_after_table_selection(::TST::SelectionArchive* after_table_selection);

  // optional .TSP.Reference table_info = 3;
  inline bool has_table_info() const;
  inline void clear_table_info();
  static const int kTableInfoFieldNumber = 3;
  inline const ::TSP::Reference& table_info() const;
  inline ::TSP::Reference* mutable_table_info();
  inline ::TSP::Reference* release_table_info();
  inline void set_allocated_table_info(::TSP::Reference* table_info);

  // optional uint32 last_column_hit_by_tap = 4;
  inline bool has_last_column_hit_by_tap() const;
  inline void clear_last_column_hit_by_tap();
  static const int kLastColumnHitByTapFieldNumber = 4;
  inline ::google::protobuf::uint32 last_column_hit_by_tap() const;
  inline void set_last_column_hit_by_tap(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TST.TableCommandSelectionBehaviorArchive)
 private:
  inline void set_has_before_table_selection();
  inline void clear_has_before_table_selection();
  inline void set_has_after_table_selection();
  inline void clear_has_after_table_selection();
  inline void set_has_table_info();
  inline void clear_has_table_info();
  inline void set_has_last_column_hit_by_tap();
  inline void clear_has_last_column_hit_by_tap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::SelectionArchive* before_table_selection_;
  ::TST::SelectionArchive* after_table_selection_;
  ::TSP::Reference* table_info_;
  ::google::protobuf::uint32 last_column_hit_by_tap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static TableCommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class DisableTableNameSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  DisableTableNameSelectionBehaviorArchive();
  virtual ~DisableTableNameSelectionBehaviorArchive();

  DisableTableNameSelectionBehaviorArchive(const DisableTableNameSelectionBehaviorArchive& from);

  inline DisableTableNameSelectionBehaviorArchive& operator=(const DisableTableNameSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisableTableNameSelectionBehaviorArchive& default_instance();

  void Swap(DisableTableNameSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  DisableTableNameSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisableTableNameSelectionBehaviorArchive& from);
  void MergeFrom(const DisableTableNameSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandSelectionBehaviorArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandSelectionBehaviorArchive& super() const;
  inline ::TST::TableCommandSelectionBehaviorArchive* mutable_super();
  inline ::TST::TableCommandSelectionBehaviorArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandSelectionBehaviorArchive* super);

  // @@protoc_insertion_point(class_scope:TST.DisableTableNameSelectionBehaviorArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandSelectionBehaviorArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DisableTableNameSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyCellCommentArchive : public ::google::protobuf::Message {
 public:
  CommandApplyCellCommentArchive();
  virtual ~CommandApplyCellCommentArchive();

  CommandApplyCellCommentArchive(const CommandApplyCellCommentArchive& from);

  inline CommandApplyCellCommentArchive& operator=(const CommandApplyCellCommentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyCellCommentArchive& default_instance();

  void Swap(CommandApplyCellCommentArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyCellCommentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyCellCommentArchive& from);
  void MergeFrom(const CommandApplyCellCommentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellID cell_id = 2;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 2;
  inline const ::TST::CellID& cell_id() const;
  inline ::TST::CellID* mutable_cell_id();
  inline ::TST::CellID* release_cell_id();
  inline void set_allocated_cell_id(::TST::CellID* cell_id);

  // optional .TSP.Reference old_comment_storage = 3;
  inline bool has_old_comment_storage() const;
  inline void clear_old_comment_storage();
  static const int kOldCommentStorageFieldNumber = 3;
  inline const ::TSP::Reference& old_comment_storage() const;
  inline ::TSP::Reference* mutable_old_comment_storage();
  inline ::TSP::Reference* release_old_comment_storage();
  inline void set_allocated_old_comment_storage(::TSP::Reference* old_comment_storage);

  // optional .TSP.Reference new_comment_storage = 4;
  inline bool has_new_comment_storage() const;
  inline void clear_new_comment_storage();
  static const int kNewCommentStorageFieldNumber = 4;
  inline const ::TSP::Reference& new_comment_storage() const;
  inline ::TSP::Reference* mutable_new_comment_storage();
  inline ::TSP::Reference* release_new_comment_storage();
  inline void set_allocated_new_comment_storage(::TSP::Reference* new_comment_storage);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyCellCommentArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_old_comment_storage();
  inline void clear_has_old_comment_storage();
  inline void set_has_new_comment_storage();
  inline void clear_has_new_comment_storage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellID* cell_id_;
  ::TSP::Reference* old_comment_storage_;
  ::TSP::Reference* new_comment_storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyCellCommentArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandApplyConditionalStyleSetArchive : public ::google::protobuf::Message {
 public:
  CommandApplyConditionalStyleSetArchive();
  virtual ~CommandApplyConditionalStyleSetArchive();

  CommandApplyConditionalStyleSetArchive(const CommandApplyConditionalStyleSetArchive& from);

  inline CommandApplyConditionalStyleSetArchive& operator=(const CommandApplyConditionalStyleSetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandApplyConditionalStyleSetArchive& default_instance();

  void Swap(CommandApplyConditionalStyleSetArchive* other);

  // implements Message ----------------------------------------------

  CommandApplyConditionalStyleSetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandApplyConditionalStyleSetArchive& from);
  void MergeFrom(const CommandApplyConditionalStyleSetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.SelectionArchive selection = 2;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 2;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // required .TST.CellMapArchive undo_cell_map = 3;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // @@protoc_insertion_point(class_scope:TST.CommandApplyConditionalStyleSetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::SelectionArchive* selection_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandApplyConditionalStyleSetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFormulaTokenizationArchive : public ::google::protobuf::Message {
 public:
  CommandSetFormulaTokenizationArchive();
  virtual ~CommandSetFormulaTokenizationArchive();

  CommandSetFormulaTokenizationArchive(const CommandSetFormulaTokenizationArchive& from);

  inline CommandSetFormulaTokenizationArchive& operator=(const CommandSetFormulaTokenizationArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFormulaTokenizationArchive& default_instance();

  void Swap(CommandSetFormulaTokenizationArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFormulaTokenizationArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFormulaTokenizationArchive& from);
  void MergeFrom(const CommandSetFormulaTokenizationArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required bool tokenization = 2;
  inline bool has_tokenization() const;
  inline void clear_tokenization();
  static const int kTokenizationFieldNumber = 2;
  inline bool tokenization() const;
  inline void set_tokenization(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFormulaTokenizationArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_tokenization();
  inline void clear_has_tokenization();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool tokenization_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFormulaTokenizationArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFilterEnabledArchive : public ::google::protobuf::Message {
 public:
  CommandSetFilterEnabledArchive();
  virtual ~CommandSetFilterEnabledArchive();

  CommandSetFilterEnabledArchive(const CommandSetFilterEnabledArchive& from);

  inline CommandSetFilterEnabledArchive& operator=(const CommandSetFilterEnabledArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFilterEnabledArchive& default_instance();

  void Swap(CommandSetFilterEnabledArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFilterEnabledArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFilterEnabledArchive& from);
  void MergeFrom(const CommandSetFilterEnabledArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required uint32 filter_index = 2;
  inline bool has_filter_index() const;
  inline void clear_filter_index();
  static const int kFilterIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 filter_index() const;
  inline void set_filter_index(::google::protobuf::uint32 value);

  // required bool enabled = 4;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFilterEnabledArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_filter_index();
  inline void clear_has_filter_index();
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::google::protobuf::uint32 filter_index_;
  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFilterEnabledArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFilterRuleEnabledArchive : public ::google::protobuf::Message {
 public:
  CommandSetFilterRuleEnabledArchive();
  virtual ~CommandSetFilterRuleEnabledArchive();

  CommandSetFilterRuleEnabledArchive(const CommandSetFilterRuleEnabledArchive& from);

  inline CommandSetFilterRuleEnabledArchive& operator=(const CommandSetFilterRuleEnabledArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFilterRuleEnabledArchive& default_instance();

  void Swap(CommandSetFilterRuleEnabledArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFilterRuleEnabledArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFilterRuleEnabledArchive& from);
  void MergeFrom(const CommandSetFilterRuleEnabledArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required uint32 filter_index = 2;
  inline bool has_filter_index() const;
  inline void clear_filter_index();
  static const int kFilterIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 filter_index() const;
  inline void set_filter_index(::google::protobuf::uint32 value);

  // required uint32 rule_index = 3;
  inline bool has_rule_index() const;
  inline void clear_rule_index();
  static const int kRuleIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 rule_index() const;
  inline void set_rule_index(::google::protobuf::uint32 value);

  // required bool enabled = 4;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 4;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFilterRuleEnabledArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_filter_index();
  inline void clear_has_filter_index();
  inline void set_has_rule_index();
  inline void clear_has_rule_index();
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::google::protobuf::uint32 filter_index_;
  ::google::protobuf::uint32 rule_index_;
  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFilterRuleEnabledArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetFilterSetTypeArchive : public ::google::protobuf::Message {
 public:
  CommandSetFilterSetTypeArchive();
  virtual ~CommandSetFilterSetTypeArchive();

  CommandSetFilterSetTypeArchive(const CommandSetFilterSetTypeArchive& from);

  inline CommandSetFilterSetTypeArchive& operator=(const CommandSetFilterSetTypeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetFilterSetTypeArchive& default_instance();

  void Swap(CommandSetFilterSetTypeArchive* other);

  // implements Message ----------------------------------------------

  CommandSetFilterSetTypeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetFilterSetTypeArchive& from);
  void MergeFrom(const CommandSetFilterSetTypeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.FilterSetArchive.FilterSetType old_filter_set_type = 2;
  inline bool has_old_filter_set_type() const;
  inline void clear_old_filter_set_type();
  static const int kOldFilterSetTypeFieldNumber = 2;
  inline ::TST::FilterSetArchive_FilterSetType old_filter_set_type() const;
  inline void set_old_filter_set_type(::TST::FilterSetArchive_FilterSetType value);

  // required .TST.FilterSetArchive.FilterSetType new_filter_set_type = 3;
  inline bool has_new_filter_set_type() const;
  inline void clear_new_filter_set_type();
  static const int kNewFilterSetTypeFieldNumber = 3;
  inline ::TST::FilterSetArchive_FilterSetType new_filter_set_type() const;
  inline void set_new_filter_set_type(::TST::FilterSetArchive_FilterSetType value);

  // @@protoc_insertion_point(class_scope:TST.CommandSetFilterSetTypeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_filter_set_type();
  inline void clear_has_old_filter_set_type();
  inline void set_has_new_filter_set_type();
  inline void clear_has_new_filter_set_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  int old_filter_set_type_;
  int new_filter_set_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetFilterSetTypeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetStyleNetworkArchive : public ::google::protobuf::Message {
 public:
  CommandSetStyleNetworkArchive();
  virtual ~CommandSetStyleNetworkArchive();

  CommandSetStyleNetworkArchive(const CommandSetStyleNetworkArchive& from);

  inline CommandSetStyleNetworkArchive& operator=(const CommandSetStyleNetworkArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetStyleNetworkArchive& default_instance();

  void Swap(CommandSetStyleNetworkArchive* other);

  // implements Message ----------------------------------------------

  CommandSetStyleNetworkArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetStyleNetworkArchive& from);
  void MergeFrom(const CommandSetStyleNetworkArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.TableStyleNetworkArchive old_style_network = 2;
  inline bool has_old_style_network() const;
  inline void clear_old_style_network();
  static const int kOldStyleNetworkFieldNumber = 2;
  inline const ::TST::TableStyleNetworkArchive& old_style_network() const;
  inline ::TST::TableStyleNetworkArchive* mutable_old_style_network();
  inline ::TST::TableStyleNetworkArchive* release_old_style_network();
  inline void set_allocated_old_style_network(::TST::TableStyleNetworkArchive* old_style_network);

  // required .TST.TableStyleNetworkArchive new_style_network = 3;
  inline bool has_new_style_network() const;
  inline void clear_new_style_network();
  static const int kNewStyleNetworkFieldNumber = 3;
  inline const ::TST::TableStyleNetworkArchive& new_style_network() const;
  inline ::TST::TableStyleNetworkArchive* mutable_new_style_network();
  inline ::TST::TableStyleNetworkArchive* release_new_style_network();
  inline void set_allocated_new_style_network(::TST::TableStyleNetworkArchive* new_style_network);

  // @@protoc_insertion_point(class_scope:TST.CommandSetStyleNetworkArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_style_network();
  inline void clear_has_old_style_network();
  inline void set_has_new_style_network();
  inline void clear_has_new_style_network();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::TableStyleNetworkArchive* old_style_network_;
  ::TST::TableStyleNetworkArchive* new_style_network_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetStyleNetworkArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandMutateCellsArchive : public ::google::protobuf::Message {
 public:
  CommandMutateCellsArchive();
  virtual ~CommandMutateCellsArchive();

  CommandMutateCellsArchive(const CommandMutateCellsArchive& from);

  inline CommandMutateCellsArchive& operator=(const CommandMutateCellsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMutateCellsArchive& default_instance();

  void Swap(CommandMutateCellsArchive* other);

  // implements Message ----------------------------------------------

  CommandMutateCellsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMutateCellsArchive& from);
  void MergeFrom(const CommandMutateCellsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellMapArchive undo_cell_map = 2;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 2;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // required .TST.CellMapArchive redo_cell_map = 3;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // optional .TST.SelectionArchive selection = 4;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 4;
  inline const ::TST::SelectionArchive& selection() const;
  inline ::TST::SelectionArchive* mutable_selection();
  inline ::TST::SelectionArchive* release_selection();
  inline void set_allocated_selection(::TST::SelectionArchive* selection);

  // @@protoc_insertion_point(class_scope:TST.CommandMutateCellsArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_selection();
  inline void clear_has_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TST::SelectionArchive* selection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandMutateCellsArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDisableFilterRulesForColumnArchive : public ::google::protobuf::Message {
 public:
  CommandDisableFilterRulesForColumnArchive();
  virtual ~CommandDisableFilterRulesForColumnArchive();

  CommandDisableFilterRulesForColumnArchive(const CommandDisableFilterRulesForColumnArchive& from);

  inline CommandDisableFilterRulesForColumnArchive& operator=(const CommandDisableFilterRulesForColumnArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDisableFilterRulesForColumnArchive& default_instance();

  void Swap(CommandDisableFilterRulesForColumnArchive* other);

  // implements Message ----------------------------------------------

  CommandDisableFilterRulesForColumnArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDisableFilterRulesForColumnArchive& from);
  void MergeFrom(const CommandDisableFilterRulesForColumnArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required uint32 column_index = 2;
  inline bool has_column_index() const;
  inline void clear_column_index();
  static const int kColumnIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 column_index() const;
  inline void set_column_index(::google::protobuf::uint32 value);

  // repeated uint32 rule_indices = 3;
  inline int rule_indices_size() const;
  inline void clear_rule_indices();
  static const int kRuleIndicesFieldNumber = 3;
  inline ::google::protobuf::uint32 rule_indices(int index) const;
  inline void set_rule_indices(int index, ::google::protobuf::uint32 value);
  inline void add_rule_indices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rule_indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rule_indices();

  // @@protoc_insertion_point(class_scope:TST.CommandDisableFilterRulesForColumnArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_column_index();
  inline void clear_has_column_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rule_indices_;
  ::google::protobuf::uint32 column_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDisableFilterRulesForColumnArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetTextStyleArchive : public ::google::protobuf::Message {
 public:
  CommandSetTextStyleArchive();
  virtual ~CommandSetTextStyleArchive();

  CommandSetTextStyleArchive(const CommandSetTextStyleArchive& from);

  inline CommandSetTextStyleArchive& operator=(const CommandSetTextStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetTextStyleArchive& default_instance();

  void Swap(CommandSetTextStyleArchive* other);

  // implements Message ----------------------------------------------

  CommandSetTextStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetTextStyleArchive& from);
  void MergeFrom(const CommandSetTextStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TST.CellRegion region = 2;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline const ::TST::CellRegion& region() const;
  inline ::TST::CellRegion* mutable_region();
  inline ::TST::CellRegion* release_region();
  inline void set_allocated_region(::TST::CellRegion* region);

  // optional .TST.CellMapArchive undo_cell_map = 3;
  inline bool has_undo_cell_map() const;
  inline void clear_undo_cell_map();
  static const int kUndoCellMapFieldNumber = 3;
  inline const ::TST::CellMapArchive& undo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_undo_cell_map();
  inline ::TST::CellMapArchive* release_undo_cell_map();
  inline void set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map);

  // optional .TST.CellMapArchive redo_cell_map = 4;
  inline bool has_redo_cell_map() const;
  inline void clear_redo_cell_map();
  static const int kRedoCellMapFieldNumber = 4;
  inline const ::TST::CellMapArchive& redo_cell_map() const;
  inline ::TST::CellMapArchive* mutable_redo_cell_map();
  inline ::TST::CellMapArchive* release_redo_cell_map();
  inline void set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map);

  // optional .TSP.Reference subcommands = 5;
  inline bool has_subcommands() const;
  inline void clear_subcommands();
  static const int kSubcommandsFieldNumber = 5;
  inline const ::TSP::Reference& subcommands() const;
  inline ::TSP::Reference* mutable_subcommands();
  inline ::TSP::Reference* release_subcommands();
  inline void set_allocated_subcommands(::TSP::Reference* subcommands);

  // @@protoc_insertion_point(class_scope:TST.CommandSetTextStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_undo_cell_map();
  inline void clear_has_undo_cell_map();
  inline void set_has_redo_cell_map();
  inline void clear_has_redo_cell_map();
  inline void set_has_subcommands();
  inline void clear_has_subcommands();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::CellRegion* region_;
  ::TST::CellMapArchive* undo_cell_map_;
  ::TST::CellMapArchive* redo_cell_map_;
  ::TSP::Reference* subcommands_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetTextStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandNotifyForTransformingArchive : public ::google::protobuf::Message {
 public:
  CommandNotifyForTransformingArchive();
  virtual ~CommandNotifyForTransformingArchive();

  CommandNotifyForTransformingArchive(const CommandNotifyForTransformingArchive& from);

  inline CommandNotifyForTransformingArchive& operator=(const CommandNotifyForTransformingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandNotifyForTransformingArchive& default_instance();

  void Swap(CommandNotifyForTransformingArchive* other);

  // implements Message ----------------------------------------------

  CommandNotifyForTransformingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandNotifyForTransformingArchive& from);
  void MergeFrom(const CommandNotifyForTransformingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TST.CommandNotifyForTransformingArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandNotifyForTransformingArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetStorageLanguageArchive : public ::google::protobuf::Message {
 public:
  CommandSetStorageLanguageArchive();
  virtual ~CommandSetStorageLanguageArchive();

  CommandSetStorageLanguageArchive(const CommandSetStorageLanguageArchive& from);

  inline CommandSetStorageLanguageArchive& operator=(const CommandSetStorageLanguageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetStorageLanguageArchive& default_instance();

  void Swap(CommandSetStorageLanguageArchive* other);

  // implements Message ----------------------------------------------

  CommandSetStorageLanguageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetStorageLanguageArchive& from);
  void MergeFrom(const CommandSetStorageLanguageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // required string language = 3;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 3;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // required uint32 range_location = 4;
  inline bool has_range_location() const;
  inline void clear_range_location();
  static const int kRangeLocationFieldNumber = 4;
  inline ::google::protobuf::uint32 range_location() const;
  inline void set_range_location(::google::protobuf::uint32 value);

  // required uint32 range_length = 5;
  inline bool has_range_length() const;
  inline void clear_range_length();
  static const int kRangeLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 range_length() const;
  inline void set_range_length(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TST.CommandSetStorageLanguageArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_range_location();
  inline void clear_has_range_location();
  inline void set_has_range_length();
  inline void clear_has_range_length();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::std::string* language_;
  ::google::protobuf::uint32 range_location_;
  ::google::protobuf::uint32 range_length_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetStorageLanguageArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetSortOrderArchive : public ::google::protobuf::Message {
 public:
  CommandSetSortOrderArchive();
  virtual ~CommandSetSortOrderArchive();

  CommandSetSortOrderArchive(const CommandSetSortOrderArchive& from);

  inline CommandSetSortOrderArchive& operator=(const CommandSetSortOrderArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetSortOrderArchive& default_instance();

  void Swap(CommandSetSortOrderArchive* other);

  // implements Message ----------------------------------------------

  CommandSetSortOrderArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetSortOrderArchive& from);
  void MergeFrom(const CommandSetSortOrderArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TST.TableSortOrderArchive old_sort_order = 2;
  inline bool has_old_sort_order() const;
  inline void clear_old_sort_order();
  static const int kOldSortOrderFieldNumber = 2;
  inline const ::TST::TableSortOrderArchive& old_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_old_sort_order();
  inline ::TST::TableSortOrderArchive* release_old_sort_order();
  inline void set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order);

  // optional .TST.TableSortOrderArchive new_sort_order = 3;
  inline bool has_new_sort_order() const;
  inline void clear_new_sort_order();
  static const int kNewSortOrderFieldNumber = 3;
  inline const ::TST::TableSortOrderArchive& new_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_new_sort_order();
  inline ::TST::TableSortOrderArchive* release_new_sort_order();
  inline void set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order);

  // @@protoc_insertion_point(class_scope:TST.CommandSetSortOrderArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_sort_order();
  inline void clear_has_old_sort_order();
  inline void set_has_new_sort_order();
  inline void clear_has_new_sort_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::TableSortOrderArchive* old_sort_order_;
  ::TST::TableSortOrderArchive* new_sort_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetSortOrderArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteSortOrderForTectonicShiftArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteSortOrderForTectonicShiftArchive();
  virtual ~CommandRewriteSortOrderForTectonicShiftArchive();

  CommandRewriteSortOrderForTectonicShiftArchive(const CommandRewriteSortOrderForTectonicShiftArchive& from);

  inline CommandRewriteSortOrderForTectonicShiftArchive& operator=(const CommandRewriteSortOrderForTectonicShiftArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteSortOrderForTectonicShiftArchive& default_instance();

  void Swap(CommandRewriteSortOrderForTectonicShiftArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteSortOrderForTectonicShiftArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteSortOrderForTectonicShiftArchive& from);
  void MergeFrom(const CommandRewriteSortOrderForTectonicShiftArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSCE.TectonicShiftArchive tectonic_shift = 2;
  inline bool has_tectonic_shift() const;
  inline void clear_tectonic_shift();
  static const int kTectonicShiftFieldNumber = 2;
  inline const ::TSCE::TectonicShiftArchive& tectonic_shift() const;
  inline ::TSCE::TectonicShiftArchive* mutable_tectonic_shift();
  inline ::TSCE::TectonicShiftArchive* release_tectonic_shift();
  inline void set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift);

  // optional .TST.TableSortOrderArchive old_sort_order = 3;
  inline bool has_old_sort_order() const;
  inline void clear_old_sort_order();
  static const int kOldSortOrderFieldNumber = 3;
  inline const ::TST::TableSortOrderArchive& old_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_old_sort_order();
  inline ::TST::TableSortOrderArchive* release_old_sort_order();
  inline void set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order);

  // optional .TST.TableSortOrderArchive new_sort_order = 4;
  inline bool has_new_sort_order() const;
  inline void clear_new_sort_order();
  static const int kNewSortOrderFieldNumber = 4;
  inline const ::TST::TableSortOrderArchive& new_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_new_sort_order();
  inline ::TST::TableSortOrderArchive* release_new_sort_order();
  inline void set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteSortOrderForTectonicShiftArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_tectonic_shift();
  inline void clear_has_tectonic_shift();
  inline void set_has_old_sort_order();
  inline void clear_has_old_sort_order();
  inline void set_has_new_sort_order();
  inline void clear_has_new_sort_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSCE::TectonicShiftArchive* tectonic_shift_;
  ::TST::TableSortOrderArchive* old_sort_order_;
  ::TST::TableSortOrderArchive* new_sort_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteSortOrderForTectonicShiftArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteSortOrderForSortArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteSortOrderForSortArchive();
  virtual ~CommandRewriteSortOrderForSortArchive();

  CommandRewriteSortOrderForSortArchive(const CommandRewriteSortOrderForSortArchive& from);

  inline CommandRewriteSortOrderForSortArchive& operator=(const CommandRewriteSortOrderForSortArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteSortOrderForSortArchive& default_instance();

  void Swap(CommandRewriteSortOrderForSortArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteSortOrderForSortArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteSortOrderForSortArchive& from);
  void MergeFrom(const CommandRewriteSortOrderForSortArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // required .TSK.ShuffleMappingArchive sort_mapping = 2;
  inline bool has_sort_mapping() const;
  inline void clear_sort_mapping();
  static const int kSortMappingFieldNumber = 2;
  inline const ::TSK::ShuffleMappingArchive& sort_mapping() const;
  inline ::TSK::ShuffleMappingArchive* mutable_sort_mapping();
  inline ::TSK::ShuffleMappingArchive* release_sort_mapping();
  inline void set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping);

  // optional .TST.TableSortOrderArchive old_sort_order = 3;
  inline bool has_old_sort_order() const;
  inline void clear_old_sort_order();
  static const int kOldSortOrderFieldNumber = 3;
  inline const ::TST::TableSortOrderArchive& old_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_old_sort_order();
  inline ::TST::TableSortOrderArchive* release_old_sort_order();
  inline void set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order);

  // optional .TST.TableSortOrderArchive new_sort_order = 4;
  inline bool has_new_sort_order() const;
  inline void clear_new_sort_order();
  static const int kNewSortOrderFieldNumber = 4;
  inline const ::TST::TableSortOrderArchive& new_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_new_sort_order();
  inline ::TST::TableSortOrderArchive* release_new_sort_order();
  inline void set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteSortOrderForSortArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sort_mapping();
  inline void clear_has_sort_mapping();
  inline void set_has_old_sort_order();
  inline void clear_has_old_sort_order();
  inline void set_has_new_sort_order();
  inline void clear_has_new_sort_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TSK::ShuffleMappingArchive* sort_mapping_;
  ::TST::TableSortOrderArchive* old_sort_order_;
  ::TST::TableSortOrderArchive* new_sort_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteSortOrderForSortArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandRewriteSortOrderForTableResizeArchive : public ::google::protobuf::Message {
 public:
  CommandRewriteSortOrderForTableResizeArchive();
  virtual ~CommandRewriteSortOrderForTableResizeArchive();

  CommandRewriteSortOrderForTableResizeArchive(const CommandRewriteSortOrderForTableResizeArchive& from);

  inline CommandRewriteSortOrderForTableResizeArchive& operator=(const CommandRewriteSortOrderForTableResizeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRewriteSortOrderForTableResizeArchive& default_instance();

  void Swap(CommandRewriteSortOrderForTableResizeArchive* other);

  // implements Message ----------------------------------------------

  CommandRewriteSortOrderForTableResizeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRewriteSortOrderForTableResizeArchive& from);
  void MergeFrom(const CommandRewriteSortOrderForTableResizeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TST.TableCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TST::TableCommandArchive& super() const;
  inline ::TST::TableCommandArchive* mutable_super();
  inline ::TST::TableCommandArchive* release_super();
  inline void set_allocated_super(::TST::TableCommandArchive* super);

  // optional .TST.TableSortOrderArchive old_sort_order = 2;
  inline bool has_old_sort_order() const;
  inline void clear_old_sort_order();
  static const int kOldSortOrderFieldNumber = 2;
  inline const ::TST::TableSortOrderArchive& old_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_old_sort_order();
  inline ::TST::TableSortOrderArchive* release_old_sort_order();
  inline void set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order);

  // optional .TST.TableSortOrderArchive new_sort_order = 3;
  inline bool has_new_sort_order() const;
  inline void clear_new_sort_order();
  static const int kNewSortOrderFieldNumber = 3;
  inline const ::TST::TableSortOrderArchive& new_sort_order() const;
  inline ::TST::TableSortOrderArchive* mutable_new_sort_order();
  inline ::TST::TableSortOrderArchive* release_new_sort_order();
  inline void set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order);

  // @@protoc_insertion_point(class_scope:TST.CommandRewriteSortOrderForTableResizeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_sort_order();
  inline void clear_has_old_sort_order();
  inline void set_has_new_sort_order();
  inline void clear_has_new_sort_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TST::TableCommandArchive* super_;
  ::TST::TableSortOrderArchive* old_sort_order_;
  ::TST::TableSortOrderArchive* new_sort_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSTCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSTCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSTCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandRewriteSortOrderForTableResizeArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// TableCommandArchive

// required .TSP.Reference tableInfo = 1;
inline bool TableCommandArchive::has_tableinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableCommandArchive::set_has_tableinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableCommandArchive::clear_has_tableinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableCommandArchive::clear_tableinfo() {
  if (tableinfo_ != NULL) tableinfo_->::TSP::Reference::Clear();
  clear_has_tableinfo();
}
inline const ::TSP::Reference& TableCommandArchive::tableinfo() const {
  return tableinfo_ != NULL ? *tableinfo_ : *default_instance_->tableinfo_;
}
inline ::TSP::Reference* TableCommandArchive::mutable_tableinfo() {
  set_has_tableinfo();
  if (tableinfo_ == NULL) tableinfo_ = new ::TSP::Reference;
  return tableinfo_;
}
inline ::TSP::Reference* TableCommandArchive::release_tableinfo() {
  clear_has_tableinfo();
  ::TSP::Reference* temp = tableinfo_;
  tableinfo_ = NULL;
  return temp;
}
inline void TableCommandArchive::set_allocated_tableinfo(::TSP::Reference* tableinfo) {
  delete tableinfo_;
  tableinfo_ = tableinfo;
  if (tableinfo) {
    set_has_tableinfo();
  } else {
    clear_has_tableinfo();
  }
}

// optional string commandname = 2;
inline bool TableCommandArchive::has_commandname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableCommandArchive::set_has_commandname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableCommandArchive::clear_has_commandname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableCommandArchive::clear_commandname() {
  if (commandname_ != &::google::protobuf::internal::kEmptyString) {
    commandname_->clear();
  }
  clear_has_commandname();
}
inline const ::std::string& TableCommandArchive::commandname() const {
  return *commandname_;
}
inline void TableCommandArchive::set_commandname(const ::std::string& value) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(value);
}
inline void TableCommandArchive::set_commandname(const char* value) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(value);
}
inline void TableCommandArchive::set_commandname(const char* value, size_t size) {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  commandname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TableCommandArchive::mutable_commandname() {
  set_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    commandname_ = new ::std::string;
  }
  return commandname_;
}
inline ::std::string* TableCommandArchive::release_commandname() {
  clear_has_commandname();
  if (commandname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commandname_;
    commandname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TableCommandArchive::set_allocated_commandname(::std::string* commandname) {
  if (commandname_ != &::google::protobuf::internal::kEmptyString) {
    delete commandname_;
  }
  if (commandname) {
    set_has_commandname();
    commandname_ = commandname;
  } else {
    clear_has_commandname();
    commandname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSK.CommandArchive super = 3;
inline bool TableCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& TableCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* TableCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* TableCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TableCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 editing_mode_at_start = 4;
inline bool TableCommandArchive::has_editing_mode_at_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableCommandArchive::set_has_editing_mode_at_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableCommandArchive::clear_has_editing_mode_at_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableCommandArchive::clear_editing_mode_at_start() {
  editing_mode_at_start_ = 0u;
  clear_has_editing_mode_at_start();
}
inline ::google::protobuf::uint32 TableCommandArchive::editing_mode_at_start() const {
  return editing_mode_at_start_;
}
inline void TableCommandArchive::set_editing_mode_at_start(::google::protobuf::uint32 value) {
  set_has_editing_mode_at_start();
  editing_mode_at_start_ = value;
}

// -------------------------------------------------------------------

// CommandApplyCellDiffArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandApplyCellDiffArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyCellDiffArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyCellDiffArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyCellDiffArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandApplyCellDiffArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandApplyCellDiffArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandApplyCellDiffArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyCellDiffArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellRegion cell_region = 2;
inline bool CommandApplyCellDiffArchive::has_cell_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyCellDiffArchive::set_has_cell_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyCellDiffArchive::clear_has_cell_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyCellDiffArchive::clear_cell_region() {
  if (cell_region_ != NULL) cell_region_->::TST::CellRegion::Clear();
  clear_has_cell_region();
}
inline const ::TST::CellRegion& CommandApplyCellDiffArchive::cell_region() const {
  return cell_region_ != NULL ? *cell_region_ : *default_instance_->cell_region_;
}
inline ::TST::CellRegion* CommandApplyCellDiffArchive::mutable_cell_region() {
  set_has_cell_region();
  if (cell_region_ == NULL) cell_region_ = new ::TST::CellRegion;
  return cell_region_;
}
inline ::TST::CellRegion* CommandApplyCellDiffArchive::release_cell_region() {
  clear_has_cell_region();
  ::TST::CellRegion* temp = cell_region_;
  cell_region_ = NULL;
  return temp;
}
inline void CommandApplyCellDiffArchive::set_allocated_cell_region(::TST::CellRegion* cell_region) {
  delete cell_region_;
  cell_region_ = cell_region;
  if (cell_region) {
    set_has_cell_region();
  } else {
    clear_has_cell_region();
  }
}

// required .TSP.Reference cell_diff = 3;
inline bool CommandApplyCellDiffArchive::has_cell_diff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyCellDiffArchive::set_has_cell_diff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyCellDiffArchive::clear_has_cell_diff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyCellDiffArchive::clear_cell_diff() {
  if (cell_diff_ != NULL) cell_diff_->::TSP::Reference::Clear();
  clear_has_cell_diff();
}
inline const ::TSP::Reference& CommandApplyCellDiffArchive::cell_diff() const {
  return cell_diff_ != NULL ? *cell_diff_ : *default_instance_->cell_diff_;
}
inline ::TSP::Reference* CommandApplyCellDiffArchive::mutable_cell_diff() {
  set_has_cell_diff();
  if (cell_diff_ == NULL) cell_diff_ = new ::TSP::Reference;
  return cell_diff_;
}
inline ::TSP::Reference* CommandApplyCellDiffArchive::release_cell_diff() {
  clear_has_cell_diff();
  ::TSP::Reference* temp = cell_diff_;
  cell_diff_ = NULL;
  return temp;
}
inline void CommandApplyCellDiffArchive::set_allocated_cell_diff(::TSP::Reference* cell_diff) {
  delete cell_diff_;
  cell_diff_ = cell_diff;
  if (cell_diff) {
    set_has_cell_diff();
  } else {
    clear_has_cell_diff();
  }
}

// required .TSP.Reference inverse_cell_diff_map = 4;
inline bool CommandApplyCellDiffArchive::has_inverse_cell_diff_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandApplyCellDiffArchive::set_has_inverse_cell_diff_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandApplyCellDiffArchive::clear_has_inverse_cell_diff_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandApplyCellDiffArchive::clear_inverse_cell_diff_map() {
  if (inverse_cell_diff_map_ != NULL) inverse_cell_diff_map_->::TSP::Reference::Clear();
  clear_has_inverse_cell_diff_map();
}
inline const ::TSP::Reference& CommandApplyCellDiffArchive::inverse_cell_diff_map() const {
  return inverse_cell_diff_map_ != NULL ? *inverse_cell_diff_map_ : *default_instance_->inverse_cell_diff_map_;
}
inline ::TSP::Reference* CommandApplyCellDiffArchive::mutable_inverse_cell_diff_map() {
  set_has_inverse_cell_diff_map();
  if (inverse_cell_diff_map_ == NULL) inverse_cell_diff_map_ = new ::TSP::Reference;
  return inverse_cell_diff_map_;
}
inline ::TSP::Reference* CommandApplyCellDiffArchive::release_inverse_cell_diff_map() {
  clear_has_inverse_cell_diff_map();
  ::TSP::Reference* temp = inverse_cell_diff_map_;
  inverse_cell_diff_map_ = NULL;
  return temp;
}
inline void CommandApplyCellDiffArchive::set_allocated_inverse_cell_diff_map(::TSP::Reference* inverse_cell_diff_map) {
  delete inverse_cell_diff_map_;
  inverse_cell_diff_map_ = inverse_cell_diff_map;
  if (inverse_cell_diff_map) {
    set_has_inverse_cell_diff_map();
  } else {
    clear_has_inverse_cell_diff_map();
  }
}

// -------------------------------------------------------------------

// CommandChangeFreezeHeaderStateArchive

// required .TST.CommandDirectionArchive direction = 1;
inline bool CommandChangeFreezeHeaderStateArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandChangeFreezeHeaderStateArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandChangeFreezeHeaderStateArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandChangeFreezeHeaderStateArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandChangeFreezeHeaderStateArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandChangeFreezeHeaderStateArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required bool new_freeze_state = 2;
inline bool CommandChangeFreezeHeaderStateArchive::has_new_freeze_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandChangeFreezeHeaderStateArchive::set_has_new_freeze_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandChangeFreezeHeaderStateArchive::clear_has_new_freeze_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandChangeFreezeHeaderStateArchive::clear_new_freeze_state() {
  new_freeze_state_ = false;
  clear_has_new_freeze_state();
}
inline bool CommandChangeFreezeHeaderStateArchive::new_freeze_state() const {
  return new_freeze_state_;
}
inline void CommandChangeFreezeHeaderStateArchive::set_new_freeze_state(bool value) {
  set_has_new_freeze_state();
  new_freeze_state_ = value;
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandChangeFreezeHeaderStateArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandChangeFreezeHeaderStateArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandChangeFreezeHeaderStateArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandChangeFreezeHeaderStateArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandChangeFreezeHeaderStateArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandChangeFreezeHeaderStateArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandChangeFreezeHeaderStateArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandChangeFreezeHeaderStateArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandDeleteCellsArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandDeleteCellsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDeleteCellsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDeleteCellsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDeleteCellsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandDeleteCellsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandDeleteCellsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandDeleteCellsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandDeleteCellsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandDeleteCellsArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDeleteCellsArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDeleteCellsArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDeleteCellsArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandDeleteCellsArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellsArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellsArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandDeleteCellsArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandDeleteCellsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandDeleteCellsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandDeleteCellsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandDeleteCellsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandDeleteCellsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandDeleteCellsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandDeleteCellsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDeleteCellsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellMapArchive redo_map = 4;
inline bool CommandDeleteCellsArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandDeleteCellsArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandDeleteCellsArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandDeleteCellsArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandDeleteCellsArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellsArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellsArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandDeleteCellsArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required bool invalidate_comments = 5;
inline bool CommandDeleteCellsArchive::has_invalidate_comments() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandDeleteCellsArchive::set_has_invalidate_comments() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandDeleteCellsArchive::clear_has_invalidate_comments() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandDeleteCellsArchive::clear_invalidate_comments() {
  invalidate_comments_ = false;
  clear_has_invalidate_comments();
}
inline bool CommandDeleteCellsArchive::invalidate_comments() const {
  return invalidate_comments_;
}
inline void CommandDeleteCellsArchive::set_invalidate_comments(bool value) {
  set_has_invalidate_comments();
  invalidate_comments_ = value;
}

// -------------------------------------------------------------------

// CommandDeleteCellContentsArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandDeleteCellContentsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDeleteCellContentsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDeleteCellContentsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDeleteCellContentsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandDeleteCellContentsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandDeleteCellContentsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandDeleteCellContentsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandDeleteCellContentsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandDeleteCellContentsArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDeleteCellContentsArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDeleteCellContentsArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDeleteCellContentsArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandDeleteCellContentsArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellContentsArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellContentsArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandDeleteCellContentsArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandDeleteCellContentsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandDeleteCellContentsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandDeleteCellContentsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandDeleteCellContentsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandDeleteCellContentsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandDeleteCellContentsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandDeleteCellContentsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDeleteCellContentsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellMapArchive redo_map = 4;
inline bool CommandDeleteCellContentsArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandDeleteCellContentsArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandDeleteCellContentsArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandDeleteCellContentsArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandDeleteCellContentsArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellContentsArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandDeleteCellContentsArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandDeleteCellContentsArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required bool invalidate_comments = 5;
inline bool CommandDeleteCellContentsArchive::has_invalidate_comments() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandDeleteCellContentsArchive::set_has_invalidate_comments() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandDeleteCellContentsArchive::clear_has_invalidate_comments() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandDeleteCellContentsArchive::clear_invalidate_comments() {
  invalidate_comments_ = false;
  clear_has_invalidate_comments();
}
inline bool CommandDeleteCellContentsArchive::invalidate_comments() const {
  return invalidate_comments_;
}
inline void CommandDeleteCellContentsArchive::set_invalidate_comments(bool value) {
  set_has_invalidate_comments();
  invalidate_comments_ = value;
}

// -------------------------------------------------------------------

// CommandSetMultipleCellsArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandSetMultipleCellsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleCellsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleCellsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleCellsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetMultipleCellsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetMultipleCellsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetMultipleCellsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandSetMultipleCellsArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetMultipleCellsArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetMultipleCellsArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetMultipleCellsArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandSetMultipleCellsArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandSetMultipleCellsArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetMultipleCellsArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetMultipleCellsArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetMultipleCellsArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandSetMultipleCellsArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// optional .TST.Cell source_cell = 4;
inline bool CommandSetMultipleCellsArchive::has_source_cell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetMultipleCellsArchive::set_has_source_cell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetMultipleCellsArchive::clear_has_source_cell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetMultipleCellsArchive::clear_source_cell() {
  if (source_cell_ != NULL) source_cell_->::TST::Cell::Clear();
  clear_has_source_cell();
}
inline const ::TST::Cell& CommandSetMultipleCellsArchive::source_cell() const {
  return source_cell_ != NULL ? *source_cell_ : *default_instance_->source_cell_;
}
inline ::TST::Cell* CommandSetMultipleCellsArchive::mutable_source_cell() {
  set_has_source_cell();
  if (source_cell_ == NULL) source_cell_ = new ::TST::Cell;
  return source_cell_;
}
inline ::TST::Cell* CommandSetMultipleCellsArchive::release_source_cell() {
  clear_has_source_cell();
  ::TST::Cell* temp = source_cell_;
  source_cell_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsArchive::set_allocated_source_cell(::TST::Cell* source_cell) {
  delete source_cell_;
  source_cell_ = source_cell;
  if (source_cell) {
    set_has_source_cell();
  } else {
    clear_has_source_cell();
  }
}

// optional bool only_if_format_differs = 6;
inline bool CommandSetMultipleCellsArchive::has_only_if_format_differs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetMultipleCellsArchive::set_has_only_if_format_differs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetMultipleCellsArchive::clear_has_only_if_format_differs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetMultipleCellsArchive::clear_only_if_format_differs() {
  only_if_format_differs_ = false;
  clear_has_only_if_format_differs();
}
inline bool CommandSetMultipleCellsArchive::only_if_format_differs() const {
  return only_if_format_differs_;
}
inline void CommandSetMultipleCellsArchive::set_only_if_format_differs(bool value) {
  set_has_only_if_format_differs();
  only_if_format_differs_ = value;
}

// required .TST.TableCommandArchive super = 7;
inline bool CommandSetMultipleCellsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSetMultipleCellsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSetMultipleCellsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSetMultipleCellsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetMultipleCellsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetMultipleCellsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetMultipleCellsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetMultipleCellsCustomArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandSetMultipleCellsCustomArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleCellsCustomArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetMultipleCellsCustomArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetMultipleCellsCustomArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetMultipleCellsCustomArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsCustomArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandSetMultipleCellsCustomArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetMultipleCellsCustomArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandSetMultipleCellsCustomArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsCustomArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsCustomArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsCustomArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandSetMultipleCellsCustomArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetMultipleCellsCustomArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandSetMultipleCellsCustomArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsCustomArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsCustomArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsCustomArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required .TSK.FormatStructArchive cell_format = 4;
inline bool CommandSetMultipleCellsCustomArchive::has_cell_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetMultipleCellsCustomArchive::set_has_cell_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_has_cell_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_cell_format() {
  if (cell_format_ != NULL) cell_format_->::TSK::FormatStructArchive::Clear();
  clear_has_cell_format();
}
inline const ::TSK::FormatStructArchive& CommandSetMultipleCellsCustomArchive::cell_format() const {
  return cell_format_ != NULL ? *cell_format_ : *default_instance_->cell_format_;
}
inline ::TSK::FormatStructArchive* CommandSetMultipleCellsCustomArchive::mutable_cell_format() {
  set_has_cell_format();
  if (cell_format_ == NULL) cell_format_ = new ::TSK::FormatStructArchive;
  return cell_format_;
}
inline ::TSK::FormatStructArchive* CommandSetMultipleCellsCustomArchive::release_cell_format() {
  clear_has_cell_format();
  ::TSK::FormatStructArchive* temp = cell_format_;
  cell_format_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsCustomArchive::set_allocated_cell_format(::TSK::FormatStructArchive* cell_format) {
  delete cell_format_;
  cell_format_ = cell_format;
  if (cell_format) {
    set_has_cell_format();
  } else {
    clear_has_cell_format();
  }
}

// required .TST.TableCommandArchive super = 7;
inline bool CommandSetMultipleCellsCustomArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetMultipleCellsCustomArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetMultipleCellsCustomArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetMultipleCellsCustomArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetMultipleCellsCustomArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetMultipleCellsCustomArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsCustomArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetMultipleCellsMultipleChoiceListArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandSetMultipleCellsMultipleChoiceListArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetMultipleCellsMultipleChoiceListArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetMultipleCellsMultipleChoiceListArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetMultipleCellsMultipleChoiceListArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandSetMultipleCellsMultipleChoiceListArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandSetMultipleCellsMultipleChoiceListArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsMultipleChoiceListArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsMultipleChoiceListArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandSetMultipleCellsMultipleChoiceListArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandSetMultipleCellsMultipleChoiceListArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsMultipleChoiceListArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandSetMultipleCellsMultipleChoiceListArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required .TST.TableCommandArchive super = 5;
inline bool CommandSetMultipleCellsMultipleChoiceListArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetMultipleCellsMultipleChoiceListArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetMultipleCellsMultipleChoiceListArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetMultipleCellsMultipleChoiceListArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleCellsMultipleChoiceListArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandCoerceMultipleCellsArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandCoerceMultipleCellsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandCoerceMultipleCellsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandCoerceMultipleCellsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandCoerceMultipleCellsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandCoerceMultipleCellsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandCoerceMultipleCellsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandCoerceMultipleCellsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandCoerceMultipleCellsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandCoerceMultipleCellsArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandCoerceMultipleCellsArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandCoerceMultipleCellsArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandCoerceMultipleCellsArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandCoerceMultipleCellsArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandCoerceMultipleCellsArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandCoerceMultipleCellsArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandCoerceMultipleCellsArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandCoerceMultipleCellsArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandCoerceMultipleCellsArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandCoerceMultipleCellsArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandCoerceMultipleCellsArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandCoerceMultipleCellsArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandCoerceMultipleCellsArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandCoerceMultipleCellsArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandCoerceMultipleCellsArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required int32 desired_format = 4;
inline bool CommandCoerceMultipleCellsArchive::has_desired_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandCoerceMultipleCellsArchive::set_has_desired_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandCoerceMultipleCellsArchive::clear_has_desired_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandCoerceMultipleCellsArchive::clear_desired_format() {
  desired_format_ = 0;
  clear_has_desired_format();
}
inline ::google::protobuf::int32 CommandCoerceMultipleCellsArchive::desired_format() const {
  return desired_format_;
}
inline void CommandCoerceMultipleCellsArchive::set_desired_format(::google::protobuf::int32 value) {
  set_has_desired_format();
  desired_format_ = value;
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandCoerceMultipleCellsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandCoerceMultipleCellsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandCoerceMultipleCellsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandCoerceMultipleCellsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandCoerceMultipleCellsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandCoerceMultipleCellsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandCoerceMultipleCellsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandCoerceMultipleCellsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetControlCellsDisplayNumberFormatArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandSetControlCellsDisplayNumberFormatArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetControlCellsDisplayNumberFormatArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetControlCellsDisplayNumberFormatArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetControlCellsDisplayNumberFormatArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandSetControlCellsDisplayNumberFormatArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandSetControlCellsDisplayNumberFormatArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandSetControlCellsDisplayNumberFormatArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandSetControlCellsDisplayNumberFormatArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandSetControlCellsDisplayNumberFormatArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandSetControlCellsDisplayNumberFormatArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandSetControlCellsDisplayNumberFormatArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandSetControlCellsDisplayNumberFormatArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandSetControlCellsDisplayNumberFormatArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetControlCellsDisplayNumberFormatArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetControlCellsDisplayNumberFormatArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetControlCellsDisplayNumberFormatArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetControlCellsDisplayNumberFormatArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetAutomaticFormatArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandSetAutomaticFormatArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetAutomaticFormatArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetAutomaticFormatArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetAutomaticFormatArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetAutomaticFormatArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetAutomaticFormatArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetAutomaticFormatArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetAutomaticFormatArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandSetAutomaticFormatArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetAutomaticFormatArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetAutomaticFormatArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetAutomaticFormatArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandSetAutomaticFormatArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticFormatArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticFormatArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandSetAutomaticFormatArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandSetAutomaticFormatArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetAutomaticFormatArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetAutomaticFormatArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetAutomaticFormatArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandSetAutomaticFormatArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticFormatArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticFormatArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandSetAutomaticFormatArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandSetAutomaticFormatArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetAutomaticFormatArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetAutomaticFormatArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetAutomaticFormatArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetAutomaticFormatArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetAutomaticFormatArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetAutomaticFormatArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetAutomaticFormatArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetAutomaticDurationUnitsArchive

// required .TST.SelectionArchive selection = 1;
inline bool CommandSetAutomaticDurationUnitsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetAutomaticDurationUnitsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetAutomaticDurationUnitsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetAutomaticDurationUnitsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_map = 2;
inline bool CommandSetAutomaticDurationUnitsArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandSetAutomaticDurationUnitsArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticDurationUnitsArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticDurationUnitsArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 3;
inline bool CommandSetAutomaticDurationUnitsArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandSetAutomaticDurationUnitsArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticDurationUnitsArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandSetAutomaticDurationUnitsArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// optional bool automatic_units = 4;
inline bool CommandSetAutomaticDurationUnitsArchive::has_automatic_units() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_has_automatic_units() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_has_automatic_units() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_automatic_units() {
  automatic_units_ = false;
  clear_has_automatic_units();
}
inline bool CommandSetAutomaticDurationUnitsArchive::automatic_units() const {
  return automatic_units_;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_automatic_units(bool value) {
  set_has_automatic_units();
  automatic_units_ = value;
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandSetAutomaticDurationUnitsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetAutomaticDurationUnitsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetAutomaticDurationUnitsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetAutomaticDurationUnitsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetAutomaticDurationUnitsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetAutomaticDurationUnitsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandReplaceCustomFormatArchive

// required .TST.CellMapArchive undo_map = 1;
inline bool CommandReplaceCustomFormatArchive::has_undo_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReplaceCustomFormatArchive::set_has_undo_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReplaceCustomFormatArchive::clear_has_undo_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReplaceCustomFormatArchive::clear_undo_map() {
  if (undo_map_ != NULL) undo_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_map();
}
inline const ::TST::CellMapArchive& CommandReplaceCustomFormatArchive::undo_map() const {
  return undo_map_ != NULL ? *undo_map_ : *default_instance_->undo_map_;
}
inline ::TST::CellMapArchive* CommandReplaceCustomFormatArchive::mutable_undo_map() {
  set_has_undo_map();
  if (undo_map_ == NULL) undo_map_ = new ::TST::CellMapArchive;
  return undo_map_;
}
inline ::TST::CellMapArchive* CommandReplaceCustomFormatArchive::release_undo_map() {
  clear_has_undo_map();
  ::TST::CellMapArchive* temp = undo_map_;
  undo_map_ = NULL;
  return temp;
}
inline void CommandReplaceCustomFormatArchive::set_allocated_undo_map(::TST::CellMapArchive* undo_map) {
  delete undo_map_;
  undo_map_ = undo_map;
  if (undo_map) {
    set_has_undo_map();
  } else {
    clear_has_undo_map();
  }
}

// required .TST.CellMapArchive redo_map = 2;
inline bool CommandReplaceCustomFormatArchive::has_redo_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandReplaceCustomFormatArchive::set_has_redo_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandReplaceCustomFormatArchive::clear_has_redo_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandReplaceCustomFormatArchive::clear_redo_map() {
  if (redo_map_ != NULL) redo_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_map();
}
inline const ::TST::CellMapArchive& CommandReplaceCustomFormatArchive::redo_map() const {
  return redo_map_ != NULL ? *redo_map_ : *default_instance_->redo_map_;
}
inline ::TST::CellMapArchive* CommandReplaceCustomFormatArchive::mutable_redo_map() {
  set_has_redo_map();
  if (redo_map_ == NULL) redo_map_ = new ::TST::CellMapArchive;
  return redo_map_;
}
inline ::TST::CellMapArchive* CommandReplaceCustomFormatArchive::release_redo_map() {
  clear_has_redo_map();
  ::TST::CellMapArchive* temp = redo_map_;
  redo_map_ = NULL;
  return temp;
}
inline void CommandReplaceCustomFormatArchive::set_allocated_redo_map(::TST::CellMapArchive* redo_map) {
  delete redo_map_;
  redo_map_ = redo_map;
  if (redo_map) {
    set_has_redo_map();
  } else {
    clear_has_redo_map();
  }
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandReplaceCustomFormatArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandReplaceCustomFormatArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandReplaceCustomFormatArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandReplaceCustomFormatArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandReplaceCustomFormatArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandReplaceCustomFormatArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandReplaceCustomFormatArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandReplaceCustomFormatArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandInsertColumnsOrRowsArchive_StyleIndexPair

// required .TSP.Reference style = 1;
inline bool CommandInsertColumnsOrRowsArchive_StyleIndexPair::has_style() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::set_has_style() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::clear_has_style() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& CommandInsertColumnsOrRowsArchive_StyleIndexPair::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* CommandInsertColumnsOrRowsArchive_StyleIndexPair::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* CommandInsertColumnsOrRowsArchive_StyleIndexPair::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// required uint32 index = 2;
inline bool CommandInsertColumnsOrRowsArchive_StyleIndexPair::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive_StyleIndexPair::index() const {
  return index_;
}
inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// CommandInsertColumnsOrRowsArchive

// required .TST.CommandDirectionArchive direction = 1;
inline bool CommandInsertColumnsOrRowsArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandInsertColumnsOrRowsArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandInsertColumnsOrRowsArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required uint32 index = 2;
inline bool CommandInsertColumnsOrRowsArchive::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive::index() const {
  return index_;
}
inline void CommandInsertColumnsOrRowsArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 count = 3;
inline bool CommandInsertColumnsOrRowsArchive::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive::count() const {
  return count_;
}
inline void CommandInsertColumnsOrRowsArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required float size = 4;
inline bool CommandInsertColumnsOrRowsArchive::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float CommandInsertColumnsOrRowsArchive::size() const {
  return size_;
}
inline void CommandInsertColumnsOrRowsArchive::set_size(float value) {
  set_has_size();
  size_ = value;
}

// required bool before = 5;
inline bool CommandInsertColumnsOrRowsArchive::has_before() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_before() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_before() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_before() {
  before_ = false;
  clear_has_before();
}
inline bool CommandInsertColumnsOrRowsArchive::before() const {
  return before_;
}
inline void CommandInsertColumnsOrRowsArchive::set_before(bool value) {
  set_has_before();
  before_ = value;
}

// required uint32 header_count = 11;
inline bool CommandInsertColumnsOrRowsArchive::has_header_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_header_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_header_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_header_count() {
  header_count_ = 0u;
  clear_has_header_count();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive::header_count() const {
  return header_count_;
}
inline void CommandInsertColumnsOrRowsArchive::set_header_count(::google::protobuf::uint32 value) {
  set_has_header_count();
  header_count_ = value;
}

// required uint32 headers_added = 12;
inline bool CommandInsertColumnsOrRowsArchive::has_headers_added() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_headers_added() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_headers_added() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_headers_added() {
  headers_added_ = 0u;
  clear_has_headers_added();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive::headers_added() const {
  return headers_added_;
}
inline void CommandInsertColumnsOrRowsArchive::set_headers_added(::google::protobuf::uint32 value) {
  set_has_headers_added();
  headers_added_ = value;
}

// required uint32 footer_count = 13;
inline bool CommandInsertColumnsOrRowsArchive::has_footer_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_footer_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_footer_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_footer_count() {
  footer_count_ = 0u;
  clear_has_footer_count();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive::footer_count() const {
  return footer_count_;
}
inline void CommandInsertColumnsOrRowsArchive::set_footer_count(::google::protobuf::uint32 value) {
  set_has_footer_count();
  footer_count_ = value;
}

// required uint32 footers_added = 14;
inline bool CommandInsertColumnsOrRowsArchive::has_footers_added() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_footers_added() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_footers_added() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_footers_added() {
  footers_added_ = 0u;
  clear_has_footers_added();
}
inline ::google::protobuf::uint32 CommandInsertColumnsOrRowsArchive::footers_added() const {
  return footers_added_;
}
inline void CommandInsertColumnsOrRowsArchive::set_footers_added(::google::protobuf::uint32 value) {
  set_has_footers_added();
  footers_added_ = value;
}

// optional .TSP.Reference row_column_style = 8;
inline bool CommandInsertColumnsOrRowsArchive::has_row_column_style() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_row_column_style() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_row_column_style() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_row_column_style() {
  if (row_column_style_ != NULL) row_column_style_->::TSP::Reference::Clear();
  clear_has_row_column_style();
}
inline const ::TSP::Reference& CommandInsertColumnsOrRowsArchive::row_column_style() const {
  return row_column_style_ != NULL ? *row_column_style_ : *default_instance_->row_column_style_;
}
inline ::TSP::Reference* CommandInsertColumnsOrRowsArchive::mutable_row_column_style() {
  set_has_row_column_style();
  if (row_column_style_ == NULL) row_column_style_ = new ::TSP::Reference;
  return row_column_style_;
}
inline ::TSP::Reference* CommandInsertColumnsOrRowsArchive::release_row_column_style() {
  clear_has_row_column_style();
  ::TSP::Reference* temp = row_column_style_;
  row_column_style_ = NULL;
  return temp;
}
inline void CommandInsertColumnsOrRowsArchive::set_allocated_row_column_style(::TSP::Reference* row_column_style) {
  delete row_column_style_;
  row_column_style_ = row_column_style;
  if (row_column_style) {
    set_has_row_column_style();
  } else {
    clear_has_row_column_style();
  }
}

// optional .TST.CellMapArchive cell_style_redo = 9;
inline bool CommandInsertColumnsOrRowsArchive::has_cell_style_redo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_cell_style_redo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_cell_style_redo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_cell_style_redo() {
  if (cell_style_redo_ != NULL) cell_style_redo_->::TST::CellMapArchive::Clear();
  clear_has_cell_style_redo();
}
inline const ::TST::CellMapArchive& CommandInsertColumnsOrRowsArchive::cell_style_redo() const {
  return cell_style_redo_ != NULL ? *cell_style_redo_ : *default_instance_->cell_style_redo_;
}
inline ::TST::CellMapArchive* CommandInsertColumnsOrRowsArchive::mutable_cell_style_redo() {
  set_has_cell_style_redo();
  if (cell_style_redo_ == NULL) cell_style_redo_ = new ::TST::CellMapArchive;
  return cell_style_redo_;
}
inline ::TST::CellMapArchive* CommandInsertColumnsOrRowsArchive::release_cell_style_redo() {
  clear_has_cell_style_redo();
  ::TST::CellMapArchive* temp = cell_style_redo_;
  cell_style_redo_ = NULL;
  return temp;
}
inline void CommandInsertColumnsOrRowsArchive::set_allocated_cell_style_redo(::TST::CellMapArchive* cell_style_redo) {
  delete cell_style_redo_;
  cell_style_redo_ = cell_style_redo;
  if (cell_style_redo) {
    set_has_cell_style_redo();
  } else {
    clear_has_cell_style_redo();
  }
}

// required .TST.TableCommandArchive super = 10;
inline bool CommandInsertColumnsOrRowsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandInsertColumnsOrRowsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandInsertColumnsOrRowsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandInsertColumnsOrRowsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandInsertColumnsOrRowsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference formula_rewrite_command = 15;
inline bool CommandInsertColumnsOrRowsArchive::has_formula_rewrite_command() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_formula_rewrite_command() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_formula_rewrite_command() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_formula_rewrite_command() {
  if (formula_rewrite_command_ != NULL) formula_rewrite_command_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command();
}
inline const ::TSP::Reference& CommandInsertColumnsOrRowsArchive::formula_rewrite_command() const {
  return formula_rewrite_command_ != NULL ? *formula_rewrite_command_ : *default_instance_->formula_rewrite_command_;
}
inline ::TSP::Reference* CommandInsertColumnsOrRowsArchive::mutable_formula_rewrite_command() {
  set_has_formula_rewrite_command();
  if (formula_rewrite_command_ == NULL) formula_rewrite_command_ = new ::TSP::Reference;
  return formula_rewrite_command_;
}
inline ::TSP::Reference* CommandInsertColumnsOrRowsArchive::release_formula_rewrite_command() {
  clear_has_formula_rewrite_command();
  ::TSP::Reference* temp = formula_rewrite_command_;
  formula_rewrite_command_ = NULL;
  return temp;
}
inline void CommandInsertColumnsOrRowsArchive::set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command) {
  delete formula_rewrite_command_;
  formula_rewrite_command_ = formula_rewrite_command;
  if (formula_rewrite_command) {
    set_has_formula_rewrite_command();
  } else {
    clear_has_formula_rewrite_command();
  }
}

// required float width_factor = 16;
inline bool CommandInsertColumnsOrRowsArchive::has_width_factor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_width_factor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_width_factor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_width_factor() {
  width_factor_ = 0;
  clear_has_width_factor();
}
inline float CommandInsertColumnsOrRowsArchive::width_factor() const {
  return width_factor_;
}
inline void CommandInsertColumnsOrRowsArchive::set_width_factor(float value) {
  set_has_width_factor();
  width_factor_ = value;
}

// required float height_factor = 17;
inline bool CommandInsertColumnsOrRowsArchive::has_height_factor() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_height_factor() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_height_factor() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_height_factor() {
  height_factor_ = 0;
  clear_has_height_factor();
}
inline float CommandInsertColumnsOrRowsArchive::height_factor() const {
  return height_factor_;
}
inline void CommandInsertColumnsOrRowsArchive::set_height_factor(float value) {
  set_has_height_factor();
  height_factor_ = value;
}

// optional bool allow_horizontal_autosize = 18;
inline bool CommandInsertColumnsOrRowsArchive::has_allow_horizontal_autosize() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_allow_horizontal_autosize() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_allow_horizontal_autosize() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_allow_horizontal_autosize() {
  allow_horizontal_autosize_ = false;
  clear_has_allow_horizontal_autosize();
}
inline bool CommandInsertColumnsOrRowsArchive::allow_horizontal_autosize() const {
  return allow_horizontal_autosize_;
}
inline void CommandInsertColumnsOrRowsArchive::set_allow_horizontal_autosize(bool value) {
  set_has_allow_horizontal_autosize();
  allow_horizontal_autosize_ = value;
}

// optional bool inherit_styles = 19;
inline bool CommandInsertColumnsOrRowsArchive::has_inherit_styles() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_inherit_styles() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_inherit_styles() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_inherit_styles() {
  inherit_styles_ = false;
  clear_has_inherit_styles();
}
inline bool CommandInsertColumnsOrRowsArchive::inherit_styles() const {
  return inherit_styles_;
}
inline void CommandInsertColumnsOrRowsArchive::set_inherit_styles(bool value) {
  set_has_inherit_styles();
  inherit_styles_ = value;
}

// optional bool inherit_formats = 20;
inline bool CommandInsertColumnsOrRowsArchive::has_inherit_formats() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_inherit_formats() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_inherit_formats() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_inherit_formats() {
  inherit_formats_ = false;
  clear_has_inherit_formats();
}
inline bool CommandInsertColumnsOrRowsArchive::inherit_formats() const {
  return inherit_formats_;
}
inline void CommandInsertColumnsOrRowsArchive::set_inherit_formats(bool value) {
  set_has_inherit_formats();
  inherit_formats_ = value;
}

// optional bool inherit_formulas = 24;
inline bool CommandInsertColumnsOrRowsArchive::has_inherit_formulas() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CommandInsertColumnsOrRowsArchive::set_has_inherit_formulas() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_has_inherit_formulas() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CommandInsertColumnsOrRowsArchive::clear_inherit_formulas() {
  inherit_formulas_ = false;
  clear_has_inherit_formulas();
}
inline bool CommandInsertColumnsOrRowsArchive::inherit_formulas() const {
  return inherit_formulas_;
}
inline void CommandInsertColumnsOrRowsArchive::set_inherit_formulas(bool value) {
  set_has_inherit_formulas();
  inherit_formulas_ = value;
}

// repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair cell_style_index_pairs = 21;
inline int CommandInsertColumnsOrRowsArchive::cell_style_index_pairs_size() const {
  return cell_style_index_pairs_.size();
}
inline void CommandInsertColumnsOrRowsArchive::clear_cell_style_index_pairs() {
  cell_style_index_pairs_.Clear();
}
inline const ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair& CommandInsertColumnsOrRowsArchive::cell_style_index_pairs(int index) const {
  return cell_style_index_pairs_.Get(index);
}
inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* CommandInsertColumnsOrRowsArchive::mutable_cell_style_index_pairs(int index) {
  return cell_style_index_pairs_.Mutable(index);
}
inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* CommandInsertColumnsOrRowsArchive::add_cell_style_index_pairs() {
  return cell_style_index_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >&
CommandInsertColumnsOrRowsArchive::cell_style_index_pairs() const {
  return cell_style_index_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >*
CommandInsertColumnsOrRowsArchive::mutable_cell_style_index_pairs() {
  return &cell_style_index_pairs_;
}

// repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair text_style_index_pairs = 22;
inline int CommandInsertColumnsOrRowsArchive::text_style_index_pairs_size() const {
  return text_style_index_pairs_.size();
}
inline void CommandInsertColumnsOrRowsArchive::clear_text_style_index_pairs() {
  text_style_index_pairs_.Clear();
}
inline const ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair& CommandInsertColumnsOrRowsArchive::text_style_index_pairs(int index) const {
  return text_style_index_pairs_.Get(index);
}
inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* CommandInsertColumnsOrRowsArchive::mutable_text_style_index_pairs(int index) {
  return text_style_index_pairs_.Mutable(index);
}
inline ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair* CommandInsertColumnsOrRowsArchive::add_text_style_index_pairs() {
  return text_style_index_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >&
CommandInsertColumnsOrRowsArchive::text_style_index_pairs() const {
  return text_style_index_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >*
CommandInsertColumnsOrRowsArchive::mutable_text_style_index_pairs() {
  return &text_style_index_pairs_;
}

// repeated double sizes = 23;
inline int CommandInsertColumnsOrRowsArchive::sizes_size() const {
  return sizes_.size();
}
inline void CommandInsertColumnsOrRowsArchive::clear_sizes() {
  sizes_.Clear();
}
inline double CommandInsertColumnsOrRowsArchive::sizes(int index) const {
  return sizes_.Get(index);
}
inline void CommandInsertColumnsOrRowsArchive::set_sizes(int index, double value) {
  sizes_.Set(index, value);
}
inline void CommandInsertColumnsOrRowsArchive::add_sizes(double value) {
  sizes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CommandInsertColumnsOrRowsArchive::sizes() const {
  return sizes_;
}
inline ::google::protobuf::RepeatedField< double >*
CommandInsertColumnsOrRowsArchive::mutable_sizes() {
  return &sizes_;
}

// -------------------------------------------------------------------

// CommandPasteArchive

// required .TST.SelectionArchive user_selection = 1;
inline bool CommandPasteArchive::has_user_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPasteArchive::set_has_user_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPasteArchive::clear_has_user_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPasteArchive::clear_user_selection() {
  if (user_selection_ != NULL) user_selection_->::TST::SelectionArchive::Clear();
  clear_has_user_selection();
}
inline const ::TST::SelectionArchive& CommandPasteArchive::user_selection() const {
  return user_selection_ != NULL ? *user_selection_ : *default_instance_->user_selection_;
}
inline ::TST::SelectionArchive* CommandPasteArchive::mutable_user_selection() {
  set_has_user_selection();
  if (user_selection_ == NULL) user_selection_ = new ::TST::SelectionArchive;
  return user_selection_;
}
inline ::TST::SelectionArchive* CommandPasteArchive::release_user_selection() {
  clear_has_user_selection();
  ::TST::SelectionArchive* temp = user_selection_;
  user_selection_ = NULL;
  return temp;
}
inline void CommandPasteArchive::set_allocated_user_selection(::TST::SelectionArchive* user_selection) {
  delete user_selection_;
  user_selection_ = user_selection;
  if (user_selection) {
    set_has_user_selection();
  } else {
    clear_has_user_selection();
  }
}

// required .TST.SelectionArchive final_selection = 2;
inline bool CommandPasteArchive::has_final_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPasteArchive::set_has_final_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPasteArchive::clear_has_final_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPasteArchive::clear_final_selection() {
  if (final_selection_ != NULL) final_selection_->::TST::SelectionArchive::Clear();
  clear_has_final_selection();
}
inline const ::TST::SelectionArchive& CommandPasteArchive::final_selection() const {
  return final_selection_ != NULL ? *final_selection_ : *default_instance_->final_selection_;
}
inline ::TST::SelectionArchive* CommandPasteArchive::mutable_final_selection() {
  set_has_final_selection();
  if (final_selection_ == NULL) final_selection_ = new ::TST::SelectionArchive;
  return final_selection_;
}
inline ::TST::SelectionArchive* CommandPasteArchive::release_final_selection() {
  clear_has_final_selection();
  ::TST::SelectionArchive* temp = final_selection_;
  final_selection_ = NULL;
  return temp;
}
inline void CommandPasteArchive::set_allocated_final_selection(::TST::SelectionArchive* final_selection) {
  delete final_selection_;
  final_selection_ = final_selection;
  if (final_selection) {
    set_has_final_selection();
  } else {
    clear_has_final_selection();
  }
}

// required .TST.TiledCellMapArchive undo_cell_map = 3;
inline bool CommandPasteArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPasteArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPasteArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPasteArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::TiledCellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::TiledCellMapArchive& CommandPasteArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::TiledCellMapArchive* CommandPasteArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::TiledCellMapArchive;
  return undo_cell_map_;
}
inline ::TST::TiledCellMapArchive* CommandPasteArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::TiledCellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandPasteArchive::set_allocated_undo_cell_map(::TST::TiledCellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.TiledCellMapArchive redo_cell_map = 4;
inline bool CommandPasteArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPasteArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPasteArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPasteArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::TiledCellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::TiledCellMapArchive& CommandPasteArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::TiledCellMapArchive* CommandPasteArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::TiledCellMapArchive;
  return redo_cell_map_;
}
inline ::TST::TiledCellMapArchive* CommandPasteArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::TiledCellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandPasteArchive::set_allocated_redo_cell_map(::TST::TiledCellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional .TSP.Reference command_undo = 6;
inline bool CommandPasteArchive::has_command_undo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPasteArchive::set_has_command_undo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPasteArchive::clear_has_command_undo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPasteArchive::clear_command_undo() {
  if (command_undo_ != NULL) command_undo_->::TSP::Reference::Clear();
  clear_has_command_undo();
}
inline const ::TSP::Reference& CommandPasteArchive::command_undo() const {
  return command_undo_ != NULL ? *command_undo_ : *default_instance_->command_undo_;
}
inline ::TSP::Reference* CommandPasteArchive::mutable_command_undo() {
  set_has_command_undo();
  if (command_undo_ == NULL) command_undo_ = new ::TSP::Reference;
  return command_undo_;
}
inline ::TSP::Reference* CommandPasteArchive::release_command_undo() {
  clear_has_command_undo();
  ::TSP::Reference* temp = command_undo_;
  command_undo_ = NULL;
  return temp;
}
inline void CommandPasteArchive::set_allocated_command_undo(::TSP::Reference* command_undo) {
  delete command_undo_;
  command_undo_ = command_undo;
  if (command_undo) {
    set_has_command_undo();
  } else {
    clear_has_command_undo();
  }
}

// required bool invalidate_comments = 7;
inline bool CommandPasteArchive::has_invalidate_comments() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandPasteArchive::set_has_invalidate_comments() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandPasteArchive::clear_has_invalidate_comments() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandPasteArchive::clear_invalidate_comments() {
  invalidate_comments_ = false;
  clear_has_invalidate_comments();
}
inline bool CommandPasteArchive::invalidate_comments() const {
  return invalidate_comments_;
}
inline void CommandPasteArchive::set_invalidate_comments(bool value) {
  set_has_invalidate_comments();
  invalidate_comments_ = value;
}

// required .TST.TableCommandArchive super = 11;
inline bool CommandPasteArchive::has_super() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandPasteArchive::set_has_super() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandPasteArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandPasteArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandPasteArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandPasteArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandPasteArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandPasteArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference formula_rewrite_commands = 15;
inline int CommandPasteArchive::formula_rewrite_commands_size() const {
  return formula_rewrite_commands_.size();
}
inline void CommandPasteArchive::clear_formula_rewrite_commands() {
  formula_rewrite_commands_.Clear();
}
inline const ::TSP::Reference& CommandPasteArchive::formula_rewrite_commands(int index) const {
  return formula_rewrite_commands_.Get(index);
}
inline ::TSP::Reference* CommandPasteArchive::mutable_formula_rewrite_commands(int index) {
  return formula_rewrite_commands_.Mutable(index);
}
inline ::TSP::Reference* CommandPasteArchive::add_formula_rewrite_commands() {
  return formula_rewrite_commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandPasteArchive::formula_rewrite_commands() const {
  return formula_rewrite_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandPasteArchive::mutable_formula_rewrite_commands() {
  return &formula_rewrite_commands_;
}

// -------------------------------------------------------------------

// CommandRemoveColumnsOrRowsArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRemoveColumnsOrRowsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRemoveColumnsOrRowsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRemoveColumnsOrRowsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRemoveColumnsOrRowsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CommandDirectionArchive direction = 2;
inline bool CommandRemoveColumnsOrRowsArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandRemoveColumnsOrRowsArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandRemoveColumnsOrRowsArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required .TSP.IndexSet indices_to_remove = 3;
inline bool CommandRemoveColumnsOrRowsArchive::has_indices_to_remove() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_indices_to_remove() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_indices_to_remove() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_indices_to_remove() {
  if (indices_to_remove_ != NULL) indices_to_remove_->::TSP::IndexSet::Clear();
  clear_has_indices_to_remove();
}
inline const ::TSP::IndexSet& CommandRemoveColumnsOrRowsArchive::indices_to_remove() const {
  return indices_to_remove_ != NULL ? *indices_to_remove_ : *default_instance_->indices_to_remove_;
}
inline ::TSP::IndexSet* CommandRemoveColumnsOrRowsArchive::mutable_indices_to_remove() {
  set_has_indices_to_remove();
  if (indices_to_remove_ == NULL) indices_to_remove_ = new ::TSP::IndexSet;
  return indices_to_remove_;
}
inline ::TSP::IndexSet* CommandRemoveColumnsOrRowsArchive::release_indices_to_remove() {
  clear_has_indices_to_remove();
  ::TSP::IndexSet* temp = indices_to_remove_;
  indices_to_remove_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_indices_to_remove(::TSP::IndexSet* indices_to_remove) {
  delete indices_to_remove_;
  indices_to_remove_ = indices_to_remove;
  if (indices_to_remove) {
    set_has_indices_to_remove();
  } else {
    clear_has_indices_to_remove();
  }
}

// optional .TST.CellMapArchive cellMap = 4;
inline bool CommandRemoveColumnsOrRowsArchive::has_cellmap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_cellmap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_cellmap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_cellmap() {
  if (cellmap_ != NULL) cellmap_->::TST::CellMapArchive::Clear();
  clear_has_cellmap();
}
inline const ::TST::CellMapArchive& CommandRemoveColumnsOrRowsArchive::cellmap() const {
  return cellmap_ != NULL ? *cellmap_ : *default_instance_->cellmap_;
}
inline ::TST::CellMapArchive* CommandRemoveColumnsOrRowsArchive::mutable_cellmap() {
  set_has_cellmap();
  if (cellmap_ == NULL) cellmap_ = new ::TST::CellMapArchive;
  return cellmap_;
}
inline ::TST::CellMapArchive* CommandRemoveColumnsOrRowsArchive::release_cellmap() {
  clear_has_cellmap();
  ::TST::CellMapArchive* temp = cellmap_;
  cellmap_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_cellmap(::TST::CellMapArchive* cellmap) {
  delete cellmap_;
  cellmap_ = cellmap;
  if (cellmap) {
    set_has_cellmap();
  } else {
    clear_has_cellmap();
  }
}

// required .TSD.GeometryArchive oldgeom = 5;
inline bool CommandRemoveColumnsOrRowsArchive::has_oldgeom() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_oldgeom() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_oldgeom() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_oldgeom() {
  if (oldgeom_ != NULL) oldgeom_->::TSD::GeometryArchive::Clear();
  clear_has_oldgeom();
}
inline const ::TSD::GeometryArchive& CommandRemoveColumnsOrRowsArchive::oldgeom() const {
  return oldgeom_ != NULL ? *oldgeom_ : *default_instance_->oldgeom_;
}
inline ::TSD::GeometryArchive* CommandRemoveColumnsOrRowsArchive::mutable_oldgeom() {
  set_has_oldgeom();
  if (oldgeom_ == NULL) oldgeom_ = new ::TSD::GeometryArchive;
  return oldgeom_;
}
inline ::TSD::GeometryArchive* CommandRemoveColumnsOrRowsArchive::release_oldgeom() {
  clear_has_oldgeom();
  ::TSD::GeometryArchive* temp = oldgeom_;
  oldgeom_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_oldgeom(::TSD::GeometryArchive* oldgeom) {
  delete oldgeom_;
  oldgeom_ = oldgeom;
  if (oldgeom) {
    set_has_oldgeom();
  } else {
    clear_has_oldgeom();
  }
}

// required .TSD.GeometryArchive newgeom = 6;
inline bool CommandRemoveColumnsOrRowsArchive::has_newgeom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_newgeom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_newgeom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_newgeom() {
  if (newgeom_ != NULL) newgeom_->::TSD::GeometryArchive::Clear();
  clear_has_newgeom();
}
inline const ::TSD::GeometryArchive& CommandRemoveColumnsOrRowsArchive::newgeom() const {
  return newgeom_ != NULL ? *newgeom_ : *default_instance_->newgeom_;
}
inline ::TSD::GeometryArchive* CommandRemoveColumnsOrRowsArchive::mutable_newgeom() {
  set_has_newgeom();
  if (newgeom_ == NULL) newgeom_ = new ::TSD::GeometryArchive;
  return newgeom_;
}
inline ::TSD::GeometryArchive* CommandRemoveColumnsOrRowsArchive::release_newgeom() {
  clear_has_newgeom();
  ::TSD::GeometryArchive* temp = newgeom_;
  newgeom_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_newgeom(::TSD::GeometryArchive* newgeom) {
  delete newgeom_;
  newgeom_ = newgeom;
  if (newgeom) {
    set_has_newgeom();
  } else {
    clear_has_newgeom();
  }
}

// repeated float subsizes = 7;
inline int CommandRemoveColumnsOrRowsArchive::subsizes_size() const {
  return subsizes_.size();
}
inline void CommandRemoveColumnsOrRowsArchive::clear_subsizes() {
  subsizes_.Clear();
}
inline float CommandRemoveColumnsOrRowsArchive::subsizes(int index) const {
  return subsizes_.Get(index);
}
inline void CommandRemoveColumnsOrRowsArchive::set_subsizes(int index, float value) {
  subsizes_.Set(index, value);
}
inline void CommandRemoveColumnsOrRowsArchive::add_subsizes(float value) {
  subsizes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
CommandRemoveColumnsOrRowsArchive::subsizes() const {
  return subsizes_;
}
inline ::google::protobuf::RepeatedField< float >*
CommandRemoveColumnsOrRowsArchive::mutable_subsizes() {
  return &subsizes_;
}

// optional .TSP.Reference formula_rewrite_command = 8;
inline bool CommandRemoveColumnsOrRowsArchive::has_formula_rewrite_command() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_formula_rewrite_command() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_formula_rewrite_command() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_formula_rewrite_command() {
  if (formula_rewrite_command_ != NULL) formula_rewrite_command_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command();
}
inline const ::TSP::Reference& CommandRemoveColumnsOrRowsArchive::formula_rewrite_command() const {
  return formula_rewrite_command_ != NULL ? *formula_rewrite_command_ : *default_instance_->formula_rewrite_command_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::mutable_formula_rewrite_command() {
  set_has_formula_rewrite_command();
  if (formula_rewrite_command_ == NULL) formula_rewrite_command_ = new ::TSP::Reference;
  return formula_rewrite_command_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::release_formula_rewrite_command() {
  clear_has_formula_rewrite_command();
  ::TSP::Reference* temp = formula_rewrite_command_;
  formula_rewrite_command_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command) {
  delete formula_rewrite_command_;
  formula_rewrite_command_ = formula_rewrite_command;
  if (formula_rewrite_command) {
    set_has_formula_rewrite_command();
  } else {
    clear_has_formula_rewrite_command();
  }
}

// required float width_factor = 9;
inline bool CommandRemoveColumnsOrRowsArchive::has_width_factor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_width_factor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_width_factor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_width_factor() {
  width_factor_ = 0;
  clear_has_width_factor();
}
inline float CommandRemoveColumnsOrRowsArchive::width_factor() const {
  return width_factor_;
}
inline void CommandRemoveColumnsOrRowsArchive::set_width_factor(float value) {
  set_has_width_factor();
  width_factor_ = value;
}

// required float height_factor = 10;
inline bool CommandRemoveColumnsOrRowsArchive::has_height_factor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_height_factor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_height_factor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_height_factor() {
  height_factor_ = 0;
  clear_has_height_factor();
}
inline float CommandRemoveColumnsOrRowsArchive::height_factor() const {
  return height_factor_;
}
inline void CommandRemoveColumnsOrRowsArchive::set_height_factor(float value) {
  set_has_height_factor();
  height_factor_ = value;
}

// optional bool allow_horizontal_autosize = 11;
inline bool CommandRemoveColumnsOrRowsArchive::has_allow_horizontal_autosize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_allow_horizontal_autosize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_allow_horizontal_autosize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_allow_horizontal_autosize() {
  allow_horizontal_autosize_ = false;
  clear_has_allow_horizontal_autosize();
}
inline bool CommandRemoveColumnsOrRowsArchive::allow_horizontal_autosize() const {
  return allow_horizontal_autosize_;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allow_horizontal_autosize(bool value) {
  set_has_allow_horizontal_autosize();
  allow_horizontal_autosize_ = value;
}

// optional .TSP.Reference undo_merge_map = 12;
inline bool CommandRemoveColumnsOrRowsArchive::has_undo_merge_map() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_undo_merge_map() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_undo_merge_map() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_undo_merge_map() {
  if (undo_merge_map_ != NULL) undo_merge_map_->::TSP::Reference::Clear();
  clear_has_undo_merge_map();
}
inline const ::TSP::Reference& CommandRemoveColumnsOrRowsArchive::undo_merge_map() const {
  return undo_merge_map_ != NULL ? *undo_merge_map_ : *default_instance_->undo_merge_map_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::mutable_undo_merge_map() {
  set_has_undo_merge_map();
  if (undo_merge_map_ == NULL) undo_merge_map_ = new ::TSP::Reference;
  return undo_merge_map_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::release_undo_merge_map() {
  clear_has_undo_merge_map();
  ::TSP::Reference* temp = undo_merge_map_;
  undo_merge_map_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_undo_merge_map(::TSP::Reference* undo_merge_map) {
  delete undo_merge_map_;
  undo_merge_map_ = undo_merge_map;
  if (undo_merge_map) {
    set_has_undo_merge_map();
  } else {
    clear_has_undo_merge_map();
  }
}

// optional .TSP.Reference redo_merge_map = 13;
inline bool CommandRemoveColumnsOrRowsArchive::has_redo_merge_map() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_redo_merge_map() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_redo_merge_map() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_redo_merge_map() {
  if (redo_merge_map_ != NULL) redo_merge_map_->::TSP::Reference::Clear();
  clear_has_redo_merge_map();
}
inline const ::TSP::Reference& CommandRemoveColumnsOrRowsArchive::redo_merge_map() const {
  return redo_merge_map_ != NULL ? *redo_merge_map_ : *default_instance_->redo_merge_map_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::mutable_redo_merge_map() {
  set_has_redo_merge_map();
  if (redo_merge_map_ == NULL) redo_merge_map_ = new ::TSP::Reference;
  return redo_merge_map_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::release_redo_merge_map() {
  clear_has_redo_merge_map();
  ::TSP::Reference* temp = redo_merge_map_;
  redo_merge_map_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_redo_merge_map(::TSP::Reference* redo_merge_map) {
  delete redo_merge_map_;
  redo_merge_map_ = redo_merge_map;
  if (redo_merge_map) {
    set_has_redo_merge_map();
  } else {
    clear_has_redo_merge_map();
  }
}

// repeated uint32 hiding_actions = 14;
inline int CommandRemoveColumnsOrRowsArchive::hiding_actions_size() const {
  return hiding_actions_.size();
}
inline void CommandRemoveColumnsOrRowsArchive::clear_hiding_actions() {
  hiding_actions_.Clear();
}
inline ::google::protobuf::uint32 CommandRemoveColumnsOrRowsArchive::hiding_actions(int index) const {
  return hiding_actions_.Get(index);
}
inline void CommandRemoveColumnsOrRowsArchive::set_hiding_actions(int index, ::google::protobuf::uint32 value) {
  hiding_actions_.Set(index, value);
}
inline void CommandRemoveColumnsOrRowsArchive::add_hiding_actions(::google::protobuf::uint32 value) {
  hiding_actions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandRemoveColumnsOrRowsArchive::hiding_actions() const {
  return hiding_actions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandRemoveColumnsOrRowsArchive::mutable_hiding_actions() {
  return &hiding_actions_;
}

// optional .TSP.Reference orig_filter_set = 15;
inline bool CommandRemoveColumnsOrRowsArchive::has_orig_filter_set() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommandRemoveColumnsOrRowsArchive::set_has_orig_filter_set() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_has_orig_filter_set() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommandRemoveColumnsOrRowsArchive::clear_orig_filter_set() {
  if (orig_filter_set_ != NULL) orig_filter_set_->::TSP::Reference::Clear();
  clear_has_orig_filter_set();
}
inline const ::TSP::Reference& CommandRemoveColumnsOrRowsArchive::orig_filter_set() const {
  return orig_filter_set_ != NULL ? *orig_filter_set_ : *default_instance_->orig_filter_set_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::mutable_orig_filter_set() {
  set_has_orig_filter_set();
  if (orig_filter_set_ == NULL) orig_filter_set_ = new ::TSP::Reference;
  return orig_filter_set_;
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::release_orig_filter_set() {
  clear_has_orig_filter_set();
  ::TSP::Reference* temp = orig_filter_set_;
  orig_filter_set_ = NULL;
  return temp;
}
inline void CommandRemoveColumnsOrRowsArchive::set_allocated_orig_filter_set(::TSP::Reference* orig_filter_set) {
  delete orig_filter_set_;
  orig_filter_set_ = orig_filter_set;
  if (orig_filter_set) {
    set_has_orig_filter_set();
  } else {
    clear_has_orig_filter_set();
  }
}

// repeated .TSP.Reference undo_command_collector = 16;
inline int CommandRemoveColumnsOrRowsArchive::undo_command_collector_size() const {
  return undo_command_collector_.size();
}
inline void CommandRemoveColumnsOrRowsArchive::clear_undo_command_collector() {
  undo_command_collector_.Clear();
}
inline const ::TSP::Reference& CommandRemoveColumnsOrRowsArchive::undo_command_collector(int index) const {
  return undo_command_collector_.Get(index);
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::mutable_undo_command_collector(int index) {
  return undo_command_collector_.Mutable(index);
}
inline ::TSP::Reference* CommandRemoveColumnsOrRowsArchive::add_undo_command_collector() {
  return undo_command_collector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandRemoveColumnsOrRowsArchive::undo_command_collector() const {
  return undo_command_collector_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandRemoveColumnsOrRowsArchive::mutable_undo_command_collector() {
  return &undo_command_collector_;
}

// -------------------------------------------------------------------

// CommandResizeColumnOrRowArchive

// required .TST.CommandDirectionArchive direction = 1;
inline bool CommandResizeColumnOrRowArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandResizeColumnOrRowArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandResizeColumnOrRowArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandResizeColumnOrRowArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required uint32 index = 2;
inline bool CommandResizeColumnOrRowArchive::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandResizeColumnOrRowArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandResizeColumnOrRowArchive::index() const {
  return index_;
}
inline void CommandResizeColumnOrRowArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 count = 3;
inline bool CommandResizeColumnOrRowArchive::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandResizeColumnOrRowArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CommandResizeColumnOrRowArchive::count() const {
  return count_;
}
inline void CommandResizeColumnOrRowArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required float newsize = 4;
inline bool CommandResizeColumnOrRowArchive::has_newsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_newsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_newsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandResizeColumnOrRowArchive::clear_newsize() {
  newsize_ = 0;
  clear_has_newsize();
}
inline float CommandResizeColumnOrRowArchive::newsize() const {
  return newsize_;
}
inline void CommandResizeColumnOrRowArchive::set_newsize(float value) {
  set_has_newsize();
  newsize_ = value;
}

// optional .TSD.GeometryArchive oldgeom = 5;
inline bool CommandResizeColumnOrRowArchive::has_oldgeom() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_oldgeom() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_oldgeom() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandResizeColumnOrRowArchive::clear_oldgeom() {
  if (oldgeom_ != NULL) oldgeom_->::TSD::GeometryArchive::Clear();
  clear_has_oldgeom();
}
inline const ::TSD::GeometryArchive& CommandResizeColumnOrRowArchive::oldgeom() const {
  return oldgeom_ != NULL ? *oldgeom_ : *default_instance_->oldgeom_;
}
inline ::TSD::GeometryArchive* CommandResizeColumnOrRowArchive::mutable_oldgeom() {
  set_has_oldgeom();
  if (oldgeom_ == NULL) oldgeom_ = new ::TSD::GeometryArchive;
  return oldgeom_;
}
inline ::TSD::GeometryArchive* CommandResizeColumnOrRowArchive::release_oldgeom() {
  clear_has_oldgeom();
  ::TSD::GeometryArchive* temp = oldgeom_;
  oldgeom_ = NULL;
  return temp;
}
inline void CommandResizeColumnOrRowArchive::set_allocated_oldgeom(::TSD::GeometryArchive* oldgeom) {
  delete oldgeom_;
  oldgeom_ = oldgeom;
  if (oldgeom) {
    set_has_oldgeom();
  } else {
    clear_has_oldgeom();
  }
}

// optional .TSD.GeometryArchive newgeom = 6;
inline bool CommandResizeColumnOrRowArchive::has_newgeom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_newgeom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_newgeom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandResizeColumnOrRowArchive::clear_newgeom() {
  if (newgeom_ != NULL) newgeom_->::TSD::GeometryArchive::Clear();
  clear_has_newgeom();
}
inline const ::TSD::GeometryArchive& CommandResizeColumnOrRowArchive::newgeom() const {
  return newgeom_ != NULL ? *newgeom_ : *default_instance_->newgeom_;
}
inline ::TSD::GeometryArchive* CommandResizeColumnOrRowArchive::mutable_newgeom() {
  set_has_newgeom();
  if (newgeom_ == NULL) newgeom_ = new ::TSD::GeometryArchive;
  return newgeom_;
}
inline ::TSD::GeometryArchive* CommandResizeColumnOrRowArchive::release_newgeom() {
  clear_has_newgeom();
  ::TSD::GeometryArchive* temp = newgeom_;
  newgeom_ = NULL;
  return temp;
}
inline void CommandResizeColumnOrRowArchive::set_allocated_newgeom(::TSD::GeometryArchive* newgeom) {
  delete newgeom_;
  newgeom_ = newgeom;
  if (newgeom) {
    set_has_newgeom();
  } else {
    clear_has_newgeom();
  }
}

// repeated float subsizes = 7;
inline int CommandResizeColumnOrRowArchive::subsizes_size() const {
  return subsizes_.size();
}
inline void CommandResizeColumnOrRowArchive::clear_subsizes() {
  subsizes_.Clear();
}
inline float CommandResizeColumnOrRowArchive::subsizes(int index) const {
  return subsizes_.Get(index);
}
inline void CommandResizeColumnOrRowArchive::set_subsizes(int index, float value) {
  subsizes_.Set(index, value);
}
inline void CommandResizeColumnOrRowArchive::add_subsizes(float value) {
  subsizes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
CommandResizeColumnOrRowArchive::subsizes() const {
  return subsizes_;
}
inline ::google::protobuf::RepeatedField< float >*
CommandResizeColumnOrRowArchive::mutable_subsizes() {
  return &subsizes_;
}

// optional float old_default = 8;
inline bool CommandResizeColumnOrRowArchive::has_old_default() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_old_default() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_old_default() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandResizeColumnOrRowArchive::clear_old_default() {
  old_default_ = 0;
  clear_has_old_default();
}
inline float CommandResizeColumnOrRowArchive::old_default() const {
  return old_default_;
}
inline void CommandResizeColumnOrRowArchive::set_old_default(float value) {
  set_has_old_default();
  old_default_ = value;
}

// optional bool uniformsizes = 9;
inline bool CommandResizeColumnOrRowArchive::has_uniformsizes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_uniformsizes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_uniformsizes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandResizeColumnOrRowArchive::clear_uniformsizes() {
  uniformsizes_ = false;
  clear_has_uniformsizes();
}
inline bool CommandResizeColumnOrRowArchive::uniformsizes() const {
  return uniformsizes_;
}
inline void CommandResizeColumnOrRowArchive::set_uniformsizes(bool value) {
  set_has_uniformsizes();
  uniformsizes_ = value;
}

// optional uint32 resizemode = 10;
inline bool CommandResizeColumnOrRowArchive::has_resizemode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_resizemode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_resizemode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommandResizeColumnOrRowArchive::clear_resizemode() {
  resizemode_ = 0u;
  clear_has_resizemode();
}
inline ::google::protobuf::uint32 CommandResizeColumnOrRowArchive::resizemode() const {
  return resizemode_;
}
inline void CommandResizeColumnOrRowArchive::set_resizemode(::google::protobuf::uint32 value) {
  set_has_resizemode();
  resizemode_ = value;
}

// required .TST.TableCommandArchive super = 11;
inline bool CommandResizeColumnOrRowArchive::has_super() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommandResizeColumnOrRowArchive::set_has_super() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommandResizeColumnOrRowArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommandResizeColumnOrRowArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandResizeColumnOrRowArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandResizeColumnOrRowArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandResizeColumnOrRowArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandResizeColumnOrRowArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetCellArchive

// required .TST.CellID cellID = 1;
inline bool CommandSetCellArchive::has_cellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetCellArchive::set_has_cellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetCellArchive::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetCellArchive::clear_cellid() {
  if (cellid_ != NULL) cellid_->::TST::CellID::Clear();
  clear_has_cellid();
}
inline const ::TST::CellID& CommandSetCellArchive::cellid() const {
  return cellid_ != NULL ? *cellid_ : *default_instance_->cellid_;
}
inline ::TST::CellID* CommandSetCellArchive::mutable_cellid() {
  set_has_cellid();
  if (cellid_ == NULL) cellid_ = new ::TST::CellID;
  return cellid_;
}
inline ::TST::CellID* CommandSetCellArchive::release_cellid() {
  clear_has_cellid();
  ::TST::CellID* temp = cellid_;
  cellid_ = NULL;
  return temp;
}
inline void CommandSetCellArchive::set_allocated_cellid(::TST::CellID* cellid) {
  delete cellid_;
  cellid_ = cellid;
  if (cellid) {
    set_has_cellid();
  } else {
    clear_has_cellid();
  }
}

// optional .TST.Cell newcell = 2;
inline bool CommandSetCellArchive::has_newcell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetCellArchive::set_has_newcell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetCellArchive::clear_has_newcell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetCellArchive::clear_newcell() {
  if (newcell_ != NULL) newcell_->::TST::Cell::Clear();
  clear_has_newcell();
}
inline const ::TST::Cell& CommandSetCellArchive::newcell() const {
  return newcell_ != NULL ? *newcell_ : *default_instance_->newcell_;
}
inline ::TST::Cell* CommandSetCellArchive::mutable_newcell() {
  set_has_newcell();
  if (newcell_ == NULL) newcell_ = new ::TST::Cell;
  return newcell_;
}
inline ::TST::Cell* CommandSetCellArchive::release_newcell() {
  clear_has_newcell();
  ::TST::Cell* temp = newcell_;
  newcell_ = NULL;
  return temp;
}
inline void CommandSetCellArchive::set_allocated_newcell(::TST::Cell* newcell) {
  delete newcell_;
  newcell_ = newcell;
  if (newcell) {
    set_has_newcell();
  } else {
    clear_has_newcell();
  }
}

// optional .TST.Cell oldcell = 3;
inline bool CommandSetCellArchive::has_oldcell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetCellArchive::set_has_oldcell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetCellArchive::clear_has_oldcell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetCellArchive::clear_oldcell() {
  if (oldcell_ != NULL) oldcell_->::TST::Cell::Clear();
  clear_has_oldcell();
}
inline const ::TST::Cell& CommandSetCellArchive::oldcell() const {
  return oldcell_ != NULL ? *oldcell_ : *default_instance_->oldcell_;
}
inline ::TST::Cell* CommandSetCellArchive::mutable_oldcell() {
  set_has_oldcell();
  if (oldcell_ == NULL) oldcell_ = new ::TST::Cell;
  return oldcell_;
}
inline ::TST::Cell* CommandSetCellArchive::release_oldcell() {
  clear_has_oldcell();
  ::TST::Cell* temp = oldcell_;
  oldcell_ = NULL;
  return temp;
}
inline void CommandSetCellArchive::set_allocated_oldcell(::TST::Cell* oldcell) {
  delete oldcell_;
  oldcell_ = oldcell;
  if (oldcell) {
    set_has_oldcell();
  } else {
    clear_has_oldcell();
  }
}

// required .TST.TableCommandArchive super = 5;
inline bool CommandSetCellArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetCellArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetCellArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetCellArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetCellArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetCellArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetCellArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetCellArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool post_undo_redo_selection = 6;
inline bool CommandSetCellArchive::has_post_undo_redo_selection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetCellArchive::set_has_post_undo_redo_selection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetCellArchive::clear_has_post_undo_redo_selection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetCellArchive::clear_post_undo_redo_selection() {
  post_undo_redo_selection_ = false;
  clear_has_post_undo_redo_selection();
}
inline bool CommandSetCellArchive::post_undo_redo_selection() const {
  return post_undo_redo_selection_;
}
inline void CommandSetCellArchive::set_post_undo_redo_selection(bool value) {
  set_has_post_undo_redo_selection();
  post_undo_redo_selection_ = value;
}

// -------------------------------------------------------------------

// CommandTextPreflightInsertCellArchive

// required .TST.CellID editing_cellID = 1;
inline bool CommandTextPreflightInsertCellArchive::has_editing_cellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_editing_cellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_editing_cellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandTextPreflightInsertCellArchive::clear_editing_cellid() {
  if (editing_cellid_ != NULL) editing_cellid_->::TST::CellID::Clear();
  clear_has_editing_cellid();
}
inline const ::TST::CellID& CommandTextPreflightInsertCellArchive::editing_cellid() const {
  return editing_cellid_ != NULL ? *editing_cellid_ : *default_instance_->editing_cellid_;
}
inline ::TST::CellID* CommandTextPreflightInsertCellArchive::mutable_editing_cellid() {
  set_has_editing_cellid();
  if (editing_cellid_ == NULL) editing_cellid_ = new ::TST::CellID;
  return editing_cellid_;
}
inline ::TST::CellID* CommandTextPreflightInsertCellArchive::release_editing_cellid() {
  clear_has_editing_cellid();
  ::TST::CellID* temp = editing_cellid_;
  editing_cellid_ = NULL;
  return temp;
}
inline void CommandTextPreflightInsertCellArchive::set_allocated_editing_cellid(::TST::CellID* editing_cellid) {
  delete editing_cellid_;
  editing_cellid_ = editing_cellid;
  if (editing_cellid) {
    set_has_editing_cellid();
  } else {
    clear_has_editing_cellid();
  }
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandTextPreflightInsertCellArchive::has_super() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_super() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandTextPreflightInsertCellArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandTextPreflightInsertCellArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandTextPreflightInsertCellArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandTextPreflightInsertCellArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandTextPreflightInsertCellArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference coalesced_textcommand = 6;
inline bool CommandTextPreflightInsertCellArchive::has_coalesced_textcommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_coalesced_textcommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_coalesced_textcommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandTextPreflightInsertCellArchive::clear_coalesced_textcommand() {
  if (coalesced_textcommand_ != NULL) coalesced_textcommand_->::TSP::Reference::Clear();
  clear_has_coalesced_textcommand();
}
inline const ::TSP::Reference& CommandTextPreflightInsertCellArchive::coalesced_textcommand() const {
  return coalesced_textcommand_ != NULL ? *coalesced_textcommand_ : *default_instance_->coalesced_textcommand_;
}
inline ::TSP::Reference* CommandTextPreflightInsertCellArchive::mutable_coalesced_textcommand() {
  set_has_coalesced_textcommand();
  if (coalesced_textcommand_ == NULL) coalesced_textcommand_ = new ::TSP::Reference;
  return coalesced_textcommand_;
}
inline ::TSP::Reference* CommandTextPreflightInsertCellArchive::release_coalesced_textcommand() {
  clear_has_coalesced_textcommand();
  ::TSP::Reference* temp = coalesced_textcommand_;
  coalesced_textcommand_ = NULL;
  return temp;
}
inline void CommandTextPreflightInsertCellArchive::set_allocated_coalesced_textcommand(::TSP::Reference* coalesced_textcommand) {
  delete coalesced_textcommand_;
  coalesced_textcommand_ = coalesced_textcommand;
  if (coalesced_textcommand) {
    set_has_coalesced_textcommand();
  } else {
    clear_has_coalesced_textcommand();
  }
}

// optional .TSP.Reference postflightcommand = 8;
inline bool CommandTextPreflightInsertCellArchive::has_postflightcommand() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_postflightcommand() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_postflightcommand() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandTextPreflightInsertCellArchive::clear_postflightcommand() {
  if (postflightcommand_ != NULL) postflightcommand_->::TSP::Reference::Clear();
  clear_has_postflightcommand();
}
inline const ::TSP::Reference& CommandTextPreflightInsertCellArchive::postflightcommand() const {
  return postflightcommand_ != NULL ? *postflightcommand_ : *default_instance_->postflightcommand_;
}
inline ::TSP::Reference* CommandTextPreflightInsertCellArchive::mutable_postflightcommand() {
  set_has_postflightcommand();
  if (postflightcommand_ == NULL) postflightcommand_ = new ::TSP::Reference;
  return postflightcommand_;
}
inline ::TSP::Reference* CommandTextPreflightInsertCellArchive::release_postflightcommand() {
  clear_has_postflightcommand();
  ::TSP::Reference* temp = postflightcommand_;
  postflightcommand_ = NULL;
  return temp;
}
inline void CommandTextPreflightInsertCellArchive::set_allocated_postflightcommand(::TSP::Reference* postflightcommand) {
  delete postflightcommand_;
  postflightcommand_ = postflightcommand;
  if (postflightcommand) {
    set_has_postflightcommand();
  } else {
    clear_has_postflightcommand();
  }
}

// optional bool grouped_with_postflight = 9;
inline bool CommandTextPreflightInsertCellArchive::has_grouped_with_postflight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_grouped_with_postflight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_grouped_with_postflight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandTextPreflightInsertCellArchive::clear_grouped_with_postflight() {
  grouped_with_postflight_ = false;
  clear_has_grouped_with_postflight();
}
inline bool CommandTextPreflightInsertCellArchive::grouped_with_postflight() const {
  return grouped_with_postflight_;
}
inline void CommandTextPreflightInsertCellArchive::set_grouped_with_postflight(bool value) {
  set_has_grouped_with_postflight();
  grouped_with_postflight_ = value;
}

// required .TST.Cell editing_cell = 10;
inline bool CommandTextPreflightInsertCellArchive::has_editing_cell() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_editing_cell() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_editing_cell() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandTextPreflightInsertCellArchive::clear_editing_cell() {
  if (editing_cell_ != NULL) editing_cell_->::TST::Cell::Clear();
  clear_has_editing_cell();
}
inline const ::TST::Cell& CommandTextPreflightInsertCellArchive::editing_cell() const {
  return editing_cell_ != NULL ? *editing_cell_ : *default_instance_->editing_cell_;
}
inline ::TST::Cell* CommandTextPreflightInsertCellArchive::mutable_editing_cell() {
  set_has_editing_cell();
  if (editing_cell_ == NULL) editing_cell_ = new ::TST::Cell;
  return editing_cell_;
}
inline ::TST::Cell* CommandTextPreflightInsertCellArchive::release_editing_cell() {
  clear_has_editing_cell();
  ::TST::Cell* temp = editing_cell_;
  editing_cell_ = NULL;
  return temp;
}
inline void CommandTextPreflightInsertCellArchive::set_allocated_editing_cell(::TST::Cell* editing_cell) {
  delete editing_cell_;
  editing_cell_ = editing_cell;
  if (editing_cell) {
    set_has_editing_cell();
  } else {
    clear_has_editing_cell();
  }
}

// required .TSP.Reference editing_storage = 11;
inline bool CommandTextPreflightInsertCellArchive::has_editing_storage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_editing_storage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_editing_storage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandTextPreflightInsertCellArchive::clear_editing_storage() {
  if (editing_storage_ != NULL) editing_storage_->::TSP::Reference::Clear();
  clear_has_editing_storage();
}
inline const ::TSP::Reference& CommandTextPreflightInsertCellArchive::editing_storage() const {
  return editing_storage_ != NULL ? *editing_storage_ : *default_instance_->editing_storage_;
}
inline ::TSP::Reference* CommandTextPreflightInsertCellArchive::mutable_editing_storage() {
  set_has_editing_storage();
  if (editing_storage_ == NULL) editing_storage_ = new ::TSP::Reference;
  return editing_storage_;
}
inline ::TSP::Reference* CommandTextPreflightInsertCellArchive::release_editing_storage() {
  clear_has_editing_storage();
  ::TSP::Reference* temp = editing_storage_;
  editing_storage_ = NULL;
  return temp;
}
inline void CommandTextPreflightInsertCellArchive::set_allocated_editing_storage(::TSP::Reference* editing_storage) {
  delete editing_storage_;
  editing_storage_ = editing_storage;
  if (editing_storage) {
    set_has_editing_storage();
  } else {
    clear_has_editing_storage();
  }
}

// optional uint32 last_column_hit_by_tap = 12;
inline bool CommandTextPreflightInsertCellArchive::has_last_column_hit_by_tap() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandTextPreflightInsertCellArchive::set_has_last_column_hit_by_tap() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandTextPreflightInsertCellArchive::clear_has_last_column_hit_by_tap() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandTextPreflightInsertCellArchive::clear_last_column_hit_by_tap() {
  last_column_hit_by_tap_ = 0u;
  clear_has_last_column_hit_by_tap();
}
inline ::google::protobuf::uint32 CommandTextPreflightInsertCellArchive::last_column_hit_by_tap() const {
  return last_column_hit_by_tap_;
}
inline void CommandTextPreflightInsertCellArchive::set_last_column_hit_by_tap(::google::protobuf::uint32 value) {
  set_has_last_column_hit_by_tap();
  last_column_hit_by_tap_ = value;
}

// -------------------------------------------------------------------

// CommandPostflightSetCellArchive

// required .TST.CellID cellID = 1;
inline bool CommandPostflightSetCellArchive::has_cellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_cellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPostflightSetCellArchive::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPostflightSetCellArchive::clear_cellid() {
  if (cellid_ != NULL) cellid_->::TST::CellID::Clear();
  clear_has_cellid();
}
inline const ::TST::CellID& CommandPostflightSetCellArchive::cellid() const {
  return cellid_ != NULL ? *cellid_ : *default_instance_->cellid_;
}
inline ::TST::CellID* CommandPostflightSetCellArchive::mutable_cellid() {
  set_has_cellid();
  if (cellid_ == NULL) cellid_ = new ::TST::CellID;
  return cellid_;
}
inline ::TST::CellID* CommandPostflightSetCellArchive::release_cellid() {
  clear_has_cellid();
  ::TST::CellID* temp = cellid_;
  cellid_ = NULL;
  return temp;
}
inline void CommandPostflightSetCellArchive::set_allocated_cellid(::TST::CellID* cellid) {
  delete cellid_;
  cellid_ = cellid;
  if (cellid) {
    set_has_cellid();
  } else {
    clear_has_cellid();
  }
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandPostflightSetCellArchive::has_super() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_super() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPostflightSetCellArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPostflightSetCellArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandPostflightSetCellArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandPostflightSetCellArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandPostflightSetCellArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandPostflightSetCellArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference childcommandundo = 4;
inline bool CommandPostflightSetCellArchive::has_childcommandundo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_childcommandundo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPostflightSetCellArchive::clear_has_childcommandundo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPostflightSetCellArchive::clear_childcommandundo() {
  if (childcommandundo_ != NULL) childcommandundo_->::TSP::Reference::Clear();
  clear_has_childcommandundo();
}
inline const ::TSP::Reference& CommandPostflightSetCellArchive::childcommandundo() const {
  return childcommandundo_ != NULL ? *childcommandundo_ : *default_instance_->childcommandundo_;
}
inline ::TSP::Reference* CommandPostflightSetCellArchive::mutable_childcommandundo() {
  set_has_childcommandundo();
  if (childcommandundo_ == NULL) childcommandundo_ = new ::TSP::Reference;
  return childcommandundo_;
}
inline ::TSP::Reference* CommandPostflightSetCellArchive::release_childcommandundo() {
  clear_has_childcommandundo();
  ::TSP::Reference* temp = childcommandundo_;
  childcommandundo_ = NULL;
  return temp;
}
inline void CommandPostflightSetCellArchive::set_allocated_childcommandundo(::TSP::Reference* childcommandundo) {
  delete childcommandundo_;
  childcommandundo_ = childcommandundo;
  if (childcommandundo) {
    set_has_childcommandundo();
  } else {
    clear_has_childcommandundo();
  }
}

// required .TST.Cell editing_cell = 6;
inline bool CommandPostflightSetCellArchive::has_editing_cell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_editing_cell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPostflightSetCellArchive::clear_has_editing_cell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPostflightSetCellArchive::clear_editing_cell() {
  if (editing_cell_ != NULL) editing_cell_->::TST::Cell::Clear();
  clear_has_editing_cell();
}
inline const ::TST::Cell& CommandPostflightSetCellArchive::editing_cell() const {
  return editing_cell_ != NULL ? *editing_cell_ : *default_instance_->editing_cell_;
}
inline ::TST::Cell* CommandPostflightSetCellArchive::mutable_editing_cell() {
  set_has_editing_cell();
  if (editing_cell_ == NULL) editing_cell_ = new ::TST::Cell;
  return editing_cell_;
}
inline ::TST::Cell* CommandPostflightSetCellArchive::release_editing_cell() {
  clear_has_editing_cell();
  ::TST::Cell* temp = editing_cell_;
  editing_cell_ = NULL;
  return temp;
}
inline void CommandPostflightSetCellArchive::set_allocated_editing_cell(::TST::Cell* editing_cell) {
  delete editing_cell_;
  editing_cell_ = editing_cell;
  if (editing_cell) {
    set_has_editing_cell();
  } else {
    clear_has_editing_cell();
  }
}

// required .TST.Cell new_cell = 7;
inline bool CommandPostflightSetCellArchive::has_new_cell() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_new_cell() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPostflightSetCellArchive::clear_has_new_cell() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPostflightSetCellArchive::clear_new_cell() {
  if (new_cell_ != NULL) new_cell_->::TST::Cell::Clear();
  clear_has_new_cell();
}
inline const ::TST::Cell& CommandPostflightSetCellArchive::new_cell() const {
  return new_cell_ != NULL ? *new_cell_ : *default_instance_->new_cell_;
}
inline ::TST::Cell* CommandPostflightSetCellArchive::mutable_new_cell() {
  set_has_new_cell();
  if (new_cell_ == NULL) new_cell_ = new ::TST::Cell;
  return new_cell_;
}
inline ::TST::Cell* CommandPostflightSetCellArchive::release_new_cell() {
  clear_has_new_cell();
  ::TST::Cell* temp = new_cell_;
  new_cell_ = NULL;
  return temp;
}
inline void CommandPostflightSetCellArchive::set_allocated_new_cell(::TST::Cell* new_cell) {
  delete new_cell_;
  new_cell_ = new_cell;
  if (new_cell) {
    set_has_new_cell();
  } else {
    clear_has_new_cell();
  }
}

// required .TSP.Reference editing_storage = 8;
inline bool CommandPostflightSetCellArchive::has_editing_storage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_editing_storage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandPostflightSetCellArchive::clear_has_editing_storage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandPostflightSetCellArchive::clear_editing_storage() {
  if (editing_storage_ != NULL) editing_storage_->::TSP::Reference::Clear();
  clear_has_editing_storage();
}
inline const ::TSP::Reference& CommandPostflightSetCellArchive::editing_storage() const {
  return editing_storage_ != NULL ? *editing_storage_ : *default_instance_->editing_storage_;
}
inline ::TSP::Reference* CommandPostflightSetCellArchive::mutable_editing_storage() {
  set_has_editing_storage();
  if (editing_storage_ == NULL) editing_storage_ = new ::TSP::Reference;
  return editing_storage_;
}
inline ::TSP::Reference* CommandPostflightSetCellArchive::release_editing_storage() {
  clear_has_editing_storage();
  ::TSP::Reference* temp = editing_storage_;
  editing_storage_ = NULL;
  return temp;
}
inline void CommandPostflightSetCellArchive::set_allocated_editing_storage(::TSP::Reference* editing_storage) {
  delete editing_storage_;
  editing_storage_ = editing_storage;
  if (editing_storage) {
    set_has_editing_storage();
  } else {
    clear_has_editing_storage();
  }
}

// optional uint32 last_column_hit_by_tap = 9;
inline bool CommandPostflightSetCellArchive::has_last_column_hit_by_tap() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandPostflightSetCellArchive::set_has_last_column_hit_by_tap() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandPostflightSetCellArchive::clear_has_last_column_hit_by_tap() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandPostflightSetCellArchive::clear_last_column_hit_by_tap() {
  last_column_hit_by_tap_ = 0u;
  clear_has_last_column_hit_by_tap();
}
inline ::google::protobuf::uint32 CommandPostflightSetCellArchive::last_column_hit_by_tap() const {
  return last_column_hit_by_tap_;
}
inline void CommandPostflightSetCellArchive::set_last_column_hit_by_tap(::google::protobuf::uint32 value) {
  set_has_last_column_hit_by_tap();
  last_column_hit_by_tap_ = value;
}

// -------------------------------------------------------------------

// CommandSetNumberOfHeadersOrFootersArchive

// required .TST.CommandRegionArchive region = 1;
inline bool CommandSetNumberOfHeadersOrFootersArchive::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_region() {
  region_ = 0;
  clear_has_region();
}
inline ::TST::CommandRegionArchive CommandSetNumberOfHeadersOrFootersArchive::region() const {
  return static_cast< ::TST::CommandRegionArchive >(region_);
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_region(::TST::CommandRegionArchive value) {
  assert(::TST::CommandRegionArchive_IsValid(value));
  set_has_region();
  region_ = value;
}

// required uint32 count = 2;
inline bool CommandSetNumberOfHeadersOrFootersArchive::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CommandSetNumberOfHeadersOrFootersArchive::count() const {
  return count_;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 oldcount = 3;
inline bool CommandSetNumberOfHeadersOrFootersArchive::has_oldcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_has_oldcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_has_oldcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_oldcount() {
  oldcount_ = 0u;
  clear_has_oldcount();
}
inline ::google::protobuf::uint32 CommandSetNumberOfHeadersOrFootersArchive::oldcount() const {
  return oldcount_;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_oldcount(::google::protobuf::uint32 value) {
  set_has_oldcount();
  oldcount_ = value;
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandSetNumberOfHeadersOrFootersArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetNumberOfHeadersOrFootersArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetNumberOfHeadersOrFootersArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetNumberOfHeadersOrFootersArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetNumberOfHeadersOrFootersArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandFixWPStylesInRowsOrColumnsArchive

// required .TST.CommandDirectionArchive direction = 1;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandFixWPStylesInRowsOrColumnsArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required uint32 index = 2;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandFixWPStylesInRowsOrColumnsArchive::index() const {
  return index_;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required .TST.CellMapArchive undo_cell_map = 3;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandFixWPStylesInRowsOrColumnsArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixWPStylesInRowsOrColumnsArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixWPStylesInRowsOrColumnsArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandFixWPStylesInRowsOrColumnsArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixWPStylesInRowsOrColumnsArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixWPStylesInRowsOrColumnsArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandFixWPStylesInRowsOrColumnsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandFixWPStylesInRowsOrColumnsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandFixWPStylesInRowsOrColumnsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 reference_index = 7;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_reference_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_reference_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_reference_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_reference_index() {
  reference_index_ = 0u;
  clear_has_reference_index();
}
inline ::google::protobuf::uint32 CommandFixWPStylesInRowsOrColumnsArchive::reference_index() const {
  return reference_index_;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_reference_index(::google::protobuf::uint32 value) {
  set_has_reference_index();
  reference_index_ = value;
}

// required bool inherit_styles = 8;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_inherit_styles() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_inherit_styles() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_inherit_styles() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_inherit_styles() {
  inherit_styles_ = false;
  clear_has_inherit_styles();
}
inline bool CommandFixWPStylesInRowsOrColumnsArchive::inherit_styles() const {
  return inherit_styles_;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_inherit_styles(bool value) {
  set_has_inherit_styles();
  inherit_styles_ = value;
}

// optional uint32 count = 9;
inline bool CommandFixWPStylesInRowsOrColumnsArchive::has_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_has_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CommandFixWPStylesInRowsOrColumnsArchive::count() const {
  return count_;
}
inline void CommandFixWPStylesInRowsOrColumnsArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// CommandFixStylesInHeadersOrFootersArchive

// required .TST.CommandRegionArchive region = 1;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_region() {
  region_ = 0;
  clear_has_region();
}
inline ::TST::CommandRegionArchive CommandFixStylesInHeadersOrFootersArchive::region() const {
  return static_cast< ::TST::CommandRegionArchive >(region_);
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_region(::TST::CommandRegionArchive value) {
  assert(::TST::CommandRegionArchive_IsValid(value));
  set_has_region();
  region_ = value;
}

// required uint32 old_number = 2;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_old_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_old_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_old_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_old_number() {
  old_number_ = 0u;
  clear_has_old_number();
}
inline ::google::protobuf::uint32 CommandFixStylesInHeadersOrFootersArchive::old_number() const {
  return old_number_;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_old_number(::google::protobuf::uint32 value) {
  set_has_old_number();
  old_number_ = value;
}

// required uint32 new_number = 3;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_new_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_new_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_new_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_new_number() {
  new_number_ = 0u;
  clear_has_new_number();
}
inline ::google::protobuf::uint32 CommandFixStylesInHeadersOrFootersArchive::new_number() const {
  return new_number_;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_new_number(::google::protobuf::uint32 value) {
  set_has_new_number();
  new_number_ = value;
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandFixStylesInHeadersOrFootersArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixStylesInHeadersOrFootersArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixStylesInHeadersOrFootersArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// required .TST.CellMapArchive undo_cell_map = 5;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandFixStylesInHeadersOrFootersArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixStylesInHeadersOrFootersArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFixStylesInHeadersOrFootersArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.TableCommandArchive super = 6;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_super() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_super() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandFixStylesInHeadersOrFootersArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandFixStylesInHeadersOrFootersArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandFixStylesInHeadersOrFootersArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference textundo = 7;
inline bool CommandFixStylesInHeadersOrFootersArchive::has_textundo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_has_textundo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_has_textundo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandFixStylesInHeadersOrFootersArchive::clear_textundo() {
  if (textundo_ != NULL) textundo_->::TSP::Reference::Clear();
  clear_has_textundo();
}
inline const ::TSP::Reference& CommandFixStylesInHeadersOrFootersArchive::textundo() const {
  return textundo_ != NULL ? *textundo_ : *default_instance_->textundo_;
}
inline ::TSP::Reference* CommandFixStylesInHeadersOrFootersArchive::mutable_textundo() {
  set_has_textundo();
  if (textundo_ == NULL) textundo_ = new ::TSP::Reference;
  return textundo_;
}
inline ::TSP::Reference* CommandFixStylesInHeadersOrFootersArchive::release_textundo() {
  clear_has_textundo();
  ::TSP::Reference* temp = textundo_;
  textundo_ = NULL;
  return temp;
}
inline void CommandFixStylesInHeadersOrFootersArchive::set_allocated_textundo(::TSP::Reference* textundo) {
  delete textundo_;
  textundo_ = textundo;
  if (textundo) {
    set_has_textundo();
  } else {
    clear_has_textundo();
  }
}

// -------------------------------------------------------------------

// CommandSetTableNameArchive

// required string newtablename = 1;
inline bool CommandSetTableNameArchive::has_newtablename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetTableNameArchive::set_has_newtablename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetTableNameArchive::clear_has_newtablename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetTableNameArchive::clear_newtablename() {
  if (newtablename_ != &::google::protobuf::internal::kEmptyString) {
    newtablename_->clear();
  }
  clear_has_newtablename();
}
inline const ::std::string& CommandSetTableNameArchive::newtablename() const {
  return *newtablename_;
}
inline void CommandSetTableNameArchive::set_newtablename(const ::std::string& value) {
  set_has_newtablename();
  if (newtablename_ == &::google::protobuf::internal::kEmptyString) {
    newtablename_ = new ::std::string;
  }
  newtablename_->assign(value);
}
inline void CommandSetTableNameArchive::set_newtablename(const char* value) {
  set_has_newtablename();
  if (newtablename_ == &::google::protobuf::internal::kEmptyString) {
    newtablename_ = new ::std::string;
  }
  newtablename_->assign(value);
}
inline void CommandSetTableNameArchive::set_newtablename(const char* value, size_t size) {
  set_has_newtablename();
  if (newtablename_ == &::google::protobuf::internal::kEmptyString) {
    newtablename_ = new ::std::string;
  }
  newtablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetTableNameArchive::mutable_newtablename() {
  set_has_newtablename();
  if (newtablename_ == &::google::protobuf::internal::kEmptyString) {
    newtablename_ = new ::std::string;
  }
  return newtablename_;
}
inline ::std::string* CommandSetTableNameArchive::release_newtablename() {
  clear_has_newtablename();
  if (newtablename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newtablename_;
    newtablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetTableNameArchive::set_allocated_newtablename(::std::string* newtablename) {
  if (newtablename_ != &::google::protobuf::internal::kEmptyString) {
    delete newtablename_;
  }
  if (newtablename) {
    set_has_newtablename();
    newtablename_ = newtablename;
  } else {
    clear_has_newtablename();
    newtablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string oldtablename = 2;
inline bool CommandSetTableNameArchive::has_oldtablename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetTableNameArchive::set_has_oldtablename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetTableNameArchive::clear_has_oldtablename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetTableNameArchive::clear_oldtablename() {
  if (oldtablename_ != &::google::protobuf::internal::kEmptyString) {
    oldtablename_->clear();
  }
  clear_has_oldtablename();
}
inline const ::std::string& CommandSetTableNameArchive::oldtablename() const {
  return *oldtablename_;
}
inline void CommandSetTableNameArchive::set_oldtablename(const ::std::string& value) {
  set_has_oldtablename();
  if (oldtablename_ == &::google::protobuf::internal::kEmptyString) {
    oldtablename_ = new ::std::string;
  }
  oldtablename_->assign(value);
}
inline void CommandSetTableNameArchive::set_oldtablename(const char* value) {
  set_has_oldtablename();
  if (oldtablename_ == &::google::protobuf::internal::kEmptyString) {
    oldtablename_ = new ::std::string;
  }
  oldtablename_->assign(value);
}
inline void CommandSetTableNameArchive::set_oldtablename(const char* value, size_t size) {
  set_has_oldtablename();
  if (oldtablename_ == &::google::protobuf::internal::kEmptyString) {
    oldtablename_ = new ::std::string;
  }
  oldtablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetTableNameArchive::mutable_oldtablename() {
  set_has_oldtablename();
  if (oldtablename_ == &::google::protobuf::internal::kEmptyString) {
    oldtablename_ = new ::std::string;
  }
  return oldtablename_;
}
inline ::std::string* CommandSetTableNameArchive::release_oldtablename() {
  clear_has_oldtablename();
  if (oldtablename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldtablename_;
    oldtablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetTableNameArchive::set_allocated_oldtablename(::std::string* oldtablename) {
  if (oldtablename_ != &::google::protobuf::internal::kEmptyString) {
    delete oldtablename_;
  }
  if (oldtablename) {
    set_has_oldtablename();
    oldtablename_ = oldtablename;
  } else {
    clear_has_oldtablename();
    oldtablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference newstyle = 3;
inline bool CommandSetTableNameArchive::has_newstyle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetTableNameArchive::set_has_newstyle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetTableNameArchive::clear_has_newstyle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetTableNameArchive::clear_newstyle() {
  if (newstyle_ != NULL) newstyle_->::TSP::Reference::Clear();
  clear_has_newstyle();
}
inline const ::TSP::Reference& CommandSetTableNameArchive::newstyle() const {
  return newstyle_ != NULL ? *newstyle_ : *default_instance_->newstyle_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::mutable_newstyle() {
  set_has_newstyle();
  if (newstyle_ == NULL) newstyle_ = new ::TSP::Reference;
  return newstyle_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::release_newstyle() {
  clear_has_newstyle();
  ::TSP::Reference* temp = newstyle_;
  newstyle_ = NULL;
  return temp;
}
inline void CommandSetTableNameArchive::set_allocated_newstyle(::TSP::Reference* newstyle) {
  delete newstyle_;
  newstyle_ = newstyle;
  if (newstyle) {
    set_has_newstyle();
  } else {
    clear_has_newstyle();
  }
}

// optional .TSP.Reference oldstyle = 4;
inline bool CommandSetTableNameArchive::has_oldstyle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetTableNameArchive::set_has_oldstyle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetTableNameArchive::clear_has_oldstyle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetTableNameArchive::clear_oldstyle() {
  if (oldstyle_ != NULL) oldstyle_->::TSP::Reference::Clear();
  clear_has_oldstyle();
}
inline const ::TSP::Reference& CommandSetTableNameArchive::oldstyle() const {
  return oldstyle_ != NULL ? *oldstyle_ : *default_instance_->oldstyle_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::mutable_oldstyle() {
  set_has_oldstyle();
  if (oldstyle_ == NULL) oldstyle_ = new ::TSP::Reference;
  return oldstyle_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::release_oldstyle() {
  clear_has_oldstyle();
  ::TSP::Reference* temp = oldstyle_;
  oldstyle_ = NULL;
  return temp;
}
inline void CommandSetTableNameArchive::set_allocated_oldstyle(::TSP::Reference* oldstyle) {
  delete oldstyle_;
  oldstyle_ = oldstyle;
  if (oldstyle) {
    set_has_oldstyle();
  } else {
    clear_has_oldstyle();
  }
}

// required .TST.TableCommandArchive super = 5;
inline bool CommandSetTableNameArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetTableNameArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetTableNameArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetTableNameArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetTableNameArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetTableNameArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetTableNameArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetTableNameArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference old_shape_style = 6;
inline bool CommandSetTableNameArchive::has_old_shape_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSetTableNameArchive::set_has_old_shape_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSetTableNameArchive::clear_has_old_shape_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSetTableNameArchive::clear_old_shape_style() {
  if (old_shape_style_ != NULL) old_shape_style_->::TSP::Reference::Clear();
  clear_has_old_shape_style();
}
inline const ::TSP::Reference& CommandSetTableNameArchive::old_shape_style() const {
  return old_shape_style_ != NULL ? *old_shape_style_ : *default_instance_->old_shape_style_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::mutable_old_shape_style() {
  set_has_old_shape_style();
  if (old_shape_style_ == NULL) old_shape_style_ = new ::TSP::Reference;
  return old_shape_style_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::release_old_shape_style() {
  clear_has_old_shape_style();
  ::TSP::Reference* temp = old_shape_style_;
  old_shape_style_ = NULL;
  return temp;
}
inline void CommandSetTableNameArchive::set_allocated_old_shape_style(::TSP::Reference* old_shape_style) {
  delete old_shape_style_;
  old_shape_style_ = old_shape_style;
  if (old_shape_style) {
    set_has_old_shape_style();
  } else {
    clear_has_old_shape_style();
  }
}

// optional .TSP.Reference new_shape_style = 7;
inline bool CommandSetTableNameArchive::has_new_shape_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandSetTableNameArchive::set_has_new_shape_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandSetTableNameArchive::clear_has_new_shape_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandSetTableNameArchive::clear_new_shape_style() {
  if (new_shape_style_ != NULL) new_shape_style_->::TSP::Reference::Clear();
  clear_has_new_shape_style();
}
inline const ::TSP::Reference& CommandSetTableNameArchive::new_shape_style() const {
  return new_shape_style_ != NULL ? *new_shape_style_ : *default_instance_->new_shape_style_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::mutable_new_shape_style() {
  set_has_new_shape_style();
  if (new_shape_style_ == NULL) new_shape_style_ = new ::TSP::Reference;
  return new_shape_style_;
}
inline ::TSP::Reference* CommandSetTableNameArchive::release_new_shape_style() {
  clear_has_new_shape_style();
  ::TSP::Reference* temp = new_shape_style_;
  new_shape_style_ = NULL;
  return temp;
}
inline void CommandSetTableNameArchive::set_allocated_new_shape_style(::TSP::Reference* new_shape_style) {
  delete new_shape_style_;
  new_shape_style_ = new_shape_style;
  if (new_shape_style) {
    set_has_new_shape_style();
  } else {
    clear_has_new_shape_style();
  }
}

// optional bool old_table_name_border_enabled = 8;
inline bool CommandSetTableNameArchive::has_old_table_name_border_enabled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandSetTableNameArchive::set_has_old_table_name_border_enabled() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandSetTableNameArchive::clear_has_old_table_name_border_enabled() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandSetTableNameArchive::clear_old_table_name_border_enabled() {
  old_table_name_border_enabled_ = false;
  clear_has_old_table_name_border_enabled();
}
inline bool CommandSetTableNameArchive::old_table_name_border_enabled() const {
  return old_table_name_border_enabled_;
}
inline void CommandSetTableNameArchive::set_old_table_name_border_enabled(bool value) {
  set_has_old_table_name_border_enabled();
  old_table_name_border_enabled_ = value;
}

// optional bool new_table_name_border_enabled = 9;
inline bool CommandSetTableNameArchive::has_new_table_name_border_enabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandSetTableNameArchive::set_has_new_table_name_border_enabled() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandSetTableNameArchive::clear_has_new_table_name_border_enabled() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandSetTableNameArchive::clear_new_table_name_border_enabled() {
  new_table_name_border_enabled_ = false;
  clear_has_new_table_name_border_enabled();
}
inline bool CommandSetTableNameArchive::new_table_name_border_enabled() const {
  return new_table_name_border_enabled_;
}
inline void CommandSetTableNameArchive::set_new_table_name_border_enabled(bool value) {
  set_has_new_table_name_border_enabled();
  new_table_name_border_enabled_ = value;
}

// -------------------------------------------------------------------

// CommandSetTableNameEnabledArchive

// required bool table_name_enabled = 1;
inline bool CommandSetTableNameEnabledArchive::has_table_name_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetTableNameEnabledArchive::set_has_table_name_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetTableNameEnabledArchive::clear_has_table_name_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetTableNameEnabledArchive::clear_table_name_enabled() {
  table_name_enabled_ = false;
  clear_has_table_name_enabled();
}
inline bool CommandSetTableNameEnabledArchive::table_name_enabled() const {
  return table_name_enabled_;
}
inline void CommandSetTableNameEnabledArchive::set_table_name_enabled(bool value) {
  set_has_table_name_enabled();
  table_name_enabled_ = value;
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandSetTableNameEnabledArchive::has_super() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetTableNameEnabledArchive::set_has_super() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetTableNameEnabledArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetTableNameEnabledArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetTableNameEnabledArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetTableNameEnabledArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetTableNameEnabledArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetTableNameEnabledArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetTableFontSizeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetTableFontSizeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetTableFontSizeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetTableFontSizeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetTableFontSizeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetTableFontSizeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetTableFontSizeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetTableFontSizeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetTableFontSizeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required float scale_factor = 9;
inline bool CommandSetTableFontSizeArchive::has_scale_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetTableFontSizeArchive::set_has_scale_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetTableFontSizeArchive::clear_has_scale_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetTableFontSizeArchive::clear_scale_factor() {
  scale_factor_ = 0;
  clear_has_scale_factor();
}
inline float CommandSetTableFontSizeArchive::scale_factor() const {
  return scale_factor_;
}
inline void CommandSetTableFontSizeArchive::set_scale_factor(float value) {
  set_has_scale_factor();
  scale_factor_ = value;
}

// optional .TST.CellMapArchive undo_cell_map = 5;
inline bool CommandSetTableFontSizeArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetTableFontSizeArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetTableFontSizeArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetTableFontSizeArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetTableFontSizeArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontSizeArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontSizeArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetTableFontSizeArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// optional .TST.CellMapArchive redo_cell_map = 6;
inline bool CommandSetTableFontSizeArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetTableFontSizeArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetTableFontSizeArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetTableFontSizeArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetTableFontSizeArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontSizeArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontSizeArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetTableFontSizeArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional bool resize_default_cells = 7;
inline bool CommandSetTableFontSizeArchive::has_resize_default_cells() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetTableFontSizeArchive::set_has_resize_default_cells() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetTableFontSizeArchive::clear_has_resize_default_cells() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetTableFontSizeArchive::clear_resize_default_cells() {
  resize_default_cells_ = false;
  clear_has_resize_default_cells();
}
inline bool CommandSetTableFontSizeArchive::resize_default_cells() const {
  return resize_default_cells_;
}
inline void CommandSetTableFontSizeArchive::set_resize_default_cells(bool value) {
  set_has_resize_default_cells();
  resize_default_cells_ = value;
}

// optional .TSP.Reference text_undo = 8;
inline bool CommandSetTableFontSizeArchive::has_text_undo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSetTableFontSizeArchive::set_has_text_undo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSetTableFontSizeArchive::clear_has_text_undo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSetTableFontSizeArchive::clear_text_undo() {
  if (text_undo_ != NULL) text_undo_->::TSP::Reference::Clear();
  clear_has_text_undo();
}
inline const ::TSP::Reference& CommandSetTableFontSizeArchive::text_undo() const {
  return text_undo_ != NULL ? *text_undo_ : *default_instance_->text_undo_;
}
inline ::TSP::Reference* CommandSetTableFontSizeArchive::mutable_text_undo() {
  set_has_text_undo();
  if (text_undo_ == NULL) text_undo_ = new ::TSP::Reference;
  return text_undo_;
}
inline ::TSP::Reference* CommandSetTableFontSizeArchive::release_text_undo() {
  clear_has_text_undo();
  ::TSP::Reference* temp = text_undo_;
  text_undo_ = NULL;
  return temp;
}
inline void CommandSetTableFontSizeArchive::set_allocated_text_undo(::TSP::Reference* text_undo) {
  delete text_undo_;
  text_undo_ = text_undo;
  if (text_undo) {
    set_has_text_undo();
  } else {
    clear_has_text_undo();
  }
}

// -------------------------------------------------------------------

// CommandSetTableFontNameArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetTableFontNameArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetTableFontNameArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetTableFontNameArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetTableFontNameArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetTableFontNameArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetTableFontNameArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetTableFontNameArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required string font_name = 2;
inline bool CommandSetTableFontNameArchive::has_font_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_font_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetTableFontNameArchive::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetTableFontNameArchive::clear_font_name() {
  if (font_name_ != &::google::protobuf::internal::kEmptyString) {
    font_name_->clear();
  }
  clear_has_font_name();
}
inline const ::std::string& CommandSetTableFontNameArchive::font_name() const {
  return *font_name_;
}
inline void CommandSetTableFontNameArchive::set_font_name(const ::std::string& value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void CommandSetTableFontNameArchive::set_font_name(const char* value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void CommandSetTableFontNameArchive::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetTableFontNameArchive::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    font_name_ = new ::std::string;
  }
  return font_name_;
}
inline ::std::string* CommandSetTableFontNameArchive::release_font_name() {
  clear_has_font_name();
  if (font_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = font_name_;
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetTableFontNameArchive::set_allocated_font_name(::std::string* font_name) {
  if (font_name_ != &::google::protobuf::internal::kEmptyString) {
    delete font_name_;
  }
  if (font_name) {
    set_has_font_name();
    font_name_ = font_name;
  } else {
    clear_has_font_name();
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string old_font_name = 3;
inline bool CommandSetTableFontNameArchive::has_old_font_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_old_font_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetTableFontNameArchive::clear_has_old_font_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetTableFontNameArchive::clear_old_font_name() {
  if (old_font_name_ != &::google::protobuf::internal::kEmptyString) {
    old_font_name_->clear();
  }
  clear_has_old_font_name();
}
inline const ::std::string& CommandSetTableFontNameArchive::old_font_name() const {
  return *old_font_name_;
}
inline void CommandSetTableFontNameArchive::set_old_font_name(const ::std::string& value) {
  set_has_old_font_name();
  if (old_font_name_ == &::google::protobuf::internal::kEmptyString) {
    old_font_name_ = new ::std::string;
  }
  old_font_name_->assign(value);
}
inline void CommandSetTableFontNameArchive::set_old_font_name(const char* value) {
  set_has_old_font_name();
  if (old_font_name_ == &::google::protobuf::internal::kEmptyString) {
    old_font_name_ = new ::std::string;
  }
  old_font_name_->assign(value);
}
inline void CommandSetTableFontNameArchive::set_old_font_name(const char* value, size_t size) {
  set_has_old_font_name();
  if (old_font_name_ == &::google::protobuf::internal::kEmptyString) {
    old_font_name_ = new ::std::string;
  }
  old_font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetTableFontNameArchive::mutable_old_font_name() {
  set_has_old_font_name();
  if (old_font_name_ == &::google::protobuf::internal::kEmptyString) {
    old_font_name_ = new ::std::string;
  }
  return old_font_name_;
}
inline ::std::string* CommandSetTableFontNameArchive::release_old_font_name() {
  clear_has_old_font_name();
  if (old_font_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_font_name_;
    old_font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetTableFontNameArchive::set_allocated_old_font_name(::std::string* old_font_name) {
  if (old_font_name_ != &::google::protobuf::internal::kEmptyString) {
    delete old_font_name_;
  }
  if (old_font_name) {
    set_has_old_font_name();
    old_font_name_ = old_font_name;
  } else {
    clear_has_old_font_name();
    old_font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_face = 5;
inline bool CommandSetTableFontNameArchive::has_preserve_face() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_preserve_face() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetTableFontNameArchive::clear_has_preserve_face() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetTableFontNameArchive::clear_preserve_face() {
  preserve_face_ = false;
  clear_has_preserve_face();
}
inline bool CommandSetTableFontNameArchive::preserve_face() const {
  return preserve_face_;
}
inline void CommandSetTableFontNameArchive::set_preserve_face(bool value) {
  set_has_preserve_face();
  preserve_face_ = value;
}

// optional .TST.CellMapArchive undo_cell_map = 6;
inline bool CommandSetTableFontNameArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetTableFontNameArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetTableFontNameArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetTableFontNameArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontNameArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontNameArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetTableFontNameArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// optional .TST.CellMapArchive redo_cell_map = 7;
inline bool CommandSetTableFontNameArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSetTableFontNameArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSetTableFontNameArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetTableFontNameArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontNameArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTableFontNameArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetTableFontNameArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional .TSP.Reference text_undo = 8;
inline bool CommandSetTableFontNameArchive::has_text_undo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandSetTableFontNameArchive::set_has_text_undo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandSetTableFontNameArchive::clear_has_text_undo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandSetTableFontNameArchive::clear_text_undo() {
  if (text_undo_ != NULL) text_undo_->::TSP::Reference::Clear();
  clear_has_text_undo();
}
inline const ::TSP::Reference& CommandSetTableFontNameArchive::text_undo() const {
  return text_undo_ != NULL ? *text_undo_ : *default_instance_->text_undo_;
}
inline ::TSP::Reference* CommandSetTableFontNameArchive::mutable_text_undo() {
  set_has_text_undo();
  if (text_undo_ == NULL) text_undo_ = new ::TSP::Reference;
  return text_undo_;
}
inline ::TSP::Reference* CommandSetTableFontNameArchive::release_text_undo() {
  clear_has_text_undo();
  ::TSP::Reference* temp = text_undo_;
  text_undo_ = NULL;
  return temp;
}
inline void CommandSetTableFontNameArchive::set_allocated_text_undo(::TSP::Reference* text_undo) {
  delete text_undo_;
  text_undo_ = text_undo;
  if (text_undo) {
    set_has_text_undo();
  } else {
    clear_has_text_undo();
  }
}

// -------------------------------------------------------------------

// CommandSetTableNameHeightArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetTableNameHeightArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetTableNameHeightArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetTableNameHeightArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetTableNameHeightArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetTableNameHeightArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetTableNameHeightArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetTableNameHeightArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetTableNameHeightArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required double old_table_name_height = 2;
inline bool CommandSetTableNameHeightArchive::has_old_table_name_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetTableNameHeightArchive::set_has_old_table_name_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetTableNameHeightArchive::clear_has_old_table_name_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetTableNameHeightArchive::clear_old_table_name_height() {
  old_table_name_height_ = 0;
  clear_has_old_table_name_height();
}
inline double CommandSetTableNameHeightArchive::old_table_name_height() const {
  return old_table_name_height_;
}
inline void CommandSetTableNameHeightArchive::set_old_table_name_height(double value) {
  set_has_old_table_name_height();
  old_table_name_height_ = value;
}

// required double new_table_name_height = 3;
inline bool CommandSetTableNameHeightArchive::has_new_table_name_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetTableNameHeightArchive::set_has_new_table_name_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetTableNameHeightArchive::clear_has_new_table_name_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetTableNameHeightArchive::clear_new_table_name_height() {
  new_table_name_height_ = 0;
  clear_has_new_table_name_height();
}
inline double CommandSetTableNameHeightArchive::new_table_name_height() const {
  return new_table_name_height_;
}
inline void CommandSetTableNameHeightArchive::set_new_table_name_height(double value) {
  set_has_new_table_name_height();
  new_table_name_height_ = value;
}

// -------------------------------------------------------------------

// CommandStyleCellsArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandStyleCellsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandStyleCellsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandStyleCellsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandStyleCellsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandStyleCellsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandStyleCellsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandStyleCellsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandStyleCellsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.ReferenceDictionary format_properties = 2;
inline bool CommandStyleCellsArchive::has_format_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandStyleCellsArchive::set_has_format_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandStyleCellsArchive::clear_has_format_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandStyleCellsArchive::clear_format_properties() {
  if (format_properties_ != NULL) format_properties_->::TSP::ReferenceDictionary::Clear();
  clear_has_format_properties();
}
inline const ::TSP::ReferenceDictionary& CommandStyleCellsArchive::format_properties() const {
  return format_properties_ != NULL ? *format_properties_ : *default_instance_->format_properties_;
}
inline ::TSP::ReferenceDictionary* CommandStyleCellsArchive::mutable_format_properties() {
  set_has_format_properties();
  if (format_properties_ == NULL) format_properties_ = new ::TSP::ReferenceDictionary;
  return format_properties_;
}
inline ::TSP::ReferenceDictionary* CommandStyleCellsArchive::release_format_properties() {
  clear_has_format_properties();
  ::TSP::ReferenceDictionary* temp = format_properties_;
  format_properties_ = NULL;
  return temp;
}
inline void CommandStyleCellsArchive::set_allocated_format_properties(::TSP::ReferenceDictionary* format_properties) {
  delete format_properties_;
  format_properties_ = format_properties;
  if (format_properties) {
    set_has_format_properties();
  } else {
    clear_has_format_properties();
  }
}

// required .TST.SelectionArchive selection = 3;
inline bool CommandStyleCellsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandStyleCellsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandStyleCellsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandStyleCellsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandStyleCellsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandStyleCellsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandStyleCellsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandStyleCellsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_cell_map = 4;
inline bool CommandStyleCellsArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandStyleCellsArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandStyleCellsArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandStyleCellsArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandStyleCellsArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandStyleCellsArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandStyleCellsArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandStyleCellsArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 5;
inline bool CommandStyleCellsArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandStyleCellsArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandStyleCellsArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandStyleCellsArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandStyleCellsArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandStyleCellsArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandStyleCellsArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandStyleCellsArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional .TSP.Reference text_undo = 6;
inline bool CommandStyleCellsArchive::has_text_undo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandStyleCellsArchive::set_has_text_undo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandStyleCellsArchive::clear_has_text_undo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandStyleCellsArchive::clear_text_undo() {
  if (text_undo_ != NULL) text_undo_->::TSP::Reference::Clear();
  clear_has_text_undo();
}
inline const ::TSP::Reference& CommandStyleCellsArchive::text_undo() const {
  return text_undo_ != NULL ? *text_undo_ : *default_instance_->text_undo_;
}
inline ::TSP::Reference* CommandStyleCellsArchive::mutable_text_undo() {
  set_has_text_undo();
  if (text_undo_ == NULL) text_undo_ = new ::TSP::Reference;
  return text_undo_;
}
inline ::TSP::Reference* CommandStyleCellsArchive::release_text_undo() {
  clear_has_text_undo();
  ::TSP::Reference* temp = text_undo_;
  text_undo_ = NULL;
  return temp;
}
inline void CommandStyleCellsArchive::set_allocated_text_undo(::TSP::Reference* text_undo) {
  delete text_undo_;
  text_undo_ = text_undo;
  if (text_undo) {
    set_has_text_undo();
  } else {
    clear_has_text_undo();
  }
}

// -------------------------------------------------------------------

// CommandSetFillPropertyArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetFillPropertyArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFillPropertyArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFillPropertyArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFillPropertyArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetFillPropertyArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetFillPropertyArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetFillPropertyArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFillPropertyArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.FillArchive fill = 2;
inline bool CommandSetFillPropertyArchive::has_fill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFillPropertyArchive::set_has_fill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFillPropertyArchive::clear_has_fill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFillPropertyArchive::clear_fill() {
  if (fill_ != NULL) fill_->::TSD::FillArchive::Clear();
  clear_has_fill();
}
inline const ::TSD::FillArchive& CommandSetFillPropertyArchive::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSD::FillArchive* CommandSetFillPropertyArchive::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSD::FillArchive;
  return fill_;
}
inline ::TSD::FillArchive* CommandSetFillPropertyArchive::release_fill() {
  clear_has_fill();
  ::TSD::FillArchive* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void CommandSetFillPropertyArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// optional .TST.CellFillStandIn cell_fill_stand_in = 3;
inline bool CommandSetFillPropertyArchive::has_cell_fill_stand_in() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetFillPropertyArchive::set_has_cell_fill_stand_in() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetFillPropertyArchive::clear_has_cell_fill_stand_in() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetFillPropertyArchive::clear_cell_fill_stand_in() {
  if (cell_fill_stand_in_ != NULL) cell_fill_stand_in_->::TST::CellFillStandIn::Clear();
  clear_has_cell_fill_stand_in();
}
inline const ::TST::CellFillStandIn& CommandSetFillPropertyArchive::cell_fill_stand_in() const {
  return cell_fill_stand_in_ != NULL ? *cell_fill_stand_in_ : *default_instance_->cell_fill_stand_in_;
}
inline ::TST::CellFillStandIn* CommandSetFillPropertyArchive::mutable_cell_fill_stand_in() {
  set_has_cell_fill_stand_in();
  if (cell_fill_stand_in_ == NULL) cell_fill_stand_in_ = new ::TST::CellFillStandIn;
  return cell_fill_stand_in_;
}
inline ::TST::CellFillStandIn* CommandSetFillPropertyArchive::release_cell_fill_stand_in() {
  clear_has_cell_fill_stand_in();
  ::TST::CellFillStandIn* temp = cell_fill_stand_in_;
  cell_fill_stand_in_ = NULL;
  return temp;
}
inline void CommandSetFillPropertyArchive::set_allocated_cell_fill_stand_in(::TST::CellFillStandIn* cell_fill_stand_in) {
  delete cell_fill_stand_in_;
  cell_fill_stand_in_ = cell_fill_stand_in;
  if (cell_fill_stand_in) {
    set_has_cell_fill_stand_in();
  } else {
    clear_has_cell_fill_stand_in();
  }
}

// required .TST.SelectionArchive selection = 4;
inline bool CommandSetFillPropertyArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetFillPropertyArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetFillPropertyArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetFillPropertyArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetFillPropertyArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetFillPropertyArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetFillPropertyArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetFillPropertyArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_cell_map = 5;
inline bool CommandSetFillPropertyArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetFillPropertyArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetFillPropertyArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetFillPropertyArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetFillPropertyArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetFillPropertyArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetFillPropertyArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetFillPropertyArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 6;
inline bool CommandSetFillPropertyArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSetFillPropertyArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSetFillPropertyArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSetFillPropertyArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetFillPropertyArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetFillPropertyArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetFillPropertyArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetFillPropertyArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandStyleTableArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandStyleTableArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandStyleTableArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandStyleTableArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandStyleTableArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandStyleTableArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandStyleTableArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandStyleTableArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandStyleTableArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.ReferenceDictionary format_properties = 2;
inline bool CommandStyleTableArchive::has_format_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandStyleTableArchive::set_has_format_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandStyleTableArchive::clear_has_format_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandStyleTableArchive::clear_format_properties() {
  if (format_properties_ != NULL) format_properties_->::TSP::ReferenceDictionary::Clear();
  clear_has_format_properties();
}
inline const ::TSP::ReferenceDictionary& CommandStyleTableArchive::format_properties() const {
  return format_properties_ != NULL ? *format_properties_ : *default_instance_->format_properties_;
}
inline ::TSP::ReferenceDictionary* CommandStyleTableArchive::mutable_format_properties() {
  set_has_format_properties();
  if (format_properties_ == NULL) format_properties_ = new ::TSP::ReferenceDictionary;
  return format_properties_;
}
inline ::TSP::ReferenceDictionary* CommandStyleTableArchive::release_format_properties() {
  clear_has_format_properties();
  ::TSP::ReferenceDictionary* temp = format_properties_;
  format_properties_ = NULL;
  return temp;
}
inline void CommandStyleTableArchive::set_allocated_format_properties(::TSP::ReferenceDictionary* format_properties) {
  delete format_properties_;
  format_properties_ = format_properties;
  if (format_properties) {
    set_has_format_properties();
  } else {
    clear_has_format_properties();
  }
}

// optional .TSP.Reference old_style = 3;
inline bool CommandStyleTableArchive::has_old_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandStyleTableArchive::set_has_old_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandStyleTableArchive::clear_has_old_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandStyleTableArchive::clear_old_style() {
  if (old_style_ != NULL) old_style_->::TSP::Reference::Clear();
  clear_has_old_style();
}
inline const ::TSP::Reference& CommandStyleTableArchive::old_style() const {
  return old_style_ != NULL ? *old_style_ : *default_instance_->old_style_;
}
inline ::TSP::Reference* CommandStyleTableArchive::mutable_old_style() {
  set_has_old_style();
  if (old_style_ == NULL) old_style_ = new ::TSP::Reference;
  return old_style_;
}
inline ::TSP::Reference* CommandStyleTableArchive::release_old_style() {
  clear_has_old_style();
  ::TSP::Reference* temp = old_style_;
  old_style_ = NULL;
  return temp;
}
inline void CommandStyleTableArchive::set_allocated_old_style(::TSP::Reference* old_style) {
  delete old_style_;
  old_style_ = old_style;
  if (old_style) {
    set_has_old_style();
  } else {
    clear_has_old_style();
  }
}

// optional .TSP.Reference new_style = 4;
inline bool CommandStyleTableArchive::has_new_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandStyleTableArchive::set_has_new_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandStyleTableArchive::clear_has_new_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandStyleTableArchive::clear_new_style() {
  if (new_style_ != NULL) new_style_->::TSP::Reference::Clear();
  clear_has_new_style();
}
inline const ::TSP::Reference& CommandStyleTableArchive::new_style() const {
  return new_style_ != NULL ? *new_style_ : *default_instance_->new_style_;
}
inline ::TSP::Reference* CommandStyleTableArchive::mutable_new_style() {
  set_has_new_style();
  if (new_style_ == NULL) new_style_ = new ::TSP::Reference;
  return new_style_;
}
inline ::TSP::Reference* CommandStyleTableArchive::release_new_style() {
  clear_has_new_style();
  ::TSP::Reference* temp = new_style_;
  new_style_ = NULL;
  return temp;
}
inline void CommandStyleTableArchive::set_allocated_new_style(::TSP::Reference* new_style) {
  delete new_style_;
  new_style_ = new_style;
  if (new_style) {
    set_has_new_style();
  } else {
    clear_has_new_style();
  }
}

// -------------------------------------------------------------------

// CommandFillCellsArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandFillCellsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandFillCellsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandFillCellsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandFillCellsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandFillCellsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandFillCellsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandFillCellsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.SelectionArchive sourceselection = 2;
inline bool CommandFillCellsArchive::has_sourceselection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandFillCellsArchive::set_has_sourceselection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandFillCellsArchive::clear_has_sourceselection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandFillCellsArchive::clear_sourceselection() {
  if (sourceselection_ != NULL) sourceselection_->::TST::SelectionArchive::Clear();
  clear_has_sourceselection();
}
inline const ::TST::SelectionArchive& CommandFillCellsArchive::sourceselection() const {
  return sourceselection_ != NULL ? *sourceselection_ : *default_instance_->sourceselection_;
}
inline ::TST::SelectionArchive* CommandFillCellsArchive::mutable_sourceselection() {
  set_has_sourceselection();
  if (sourceselection_ == NULL) sourceselection_ = new ::TST::SelectionArchive;
  return sourceselection_;
}
inline ::TST::SelectionArchive* CommandFillCellsArchive::release_sourceselection() {
  clear_has_sourceselection();
  ::TST::SelectionArchive* temp = sourceselection_;
  sourceselection_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_sourceselection(::TST::SelectionArchive* sourceselection) {
  delete sourceselection_;
  sourceselection_ = sourceselection;
  if (sourceselection) {
    set_has_sourceselection();
  } else {
    clear_has_sourceselection();
  }
}

// required .TST.CellRange sourcecellrange = 3;
inline bool CommandFillCellsArchive::has_sourcecellrange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandFillCellsArchive::set_has_sourcecellrange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandFillCellsArchive::clear_has_sourcecellrange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandFillCellsArchive::clear_sourcecellrange() {
  if (sourcecellrange_ != NULL) sourcecellrange_->::TST::CellRange::Clear();
  clear_has_sourcecellrange();
}
inline const ::TST::CellRange& CommandFillCellsArchive::sourcecellrange() const {
  return sourcecellrange_ != NULL ? *sourcecellrange_ : *default_instance_->sourcecellrange_;
}
inline ::TST::CellRange* CommandFillCellsArchive::mutable_sourcecellrange() {
  set_has_sourcecellrange();
  if (sourcecellrange_ == NULL) sourcecellrange_ = new ::TST::CellRange;
  return sourcecellrange_;
}
inline ::TST::CellRange* CommandFillCellsArchive::release_sourcecellrange() {
  clear_has_sourcecellrange();
  ::TST::CellRange* temp = sourcecellrange_;
  sourcecellrange_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_sourcecellrange(::TST::CellRange* sourcecellrange) {
  delete sourcecellrange_;
  sourcecellrange_ = sourcecellrange;
  if (sourcecellrange) {
    set_has_sourcecellrange();
  } else {
    clear_has_sourcecellrange();
  }
}

// required .TST.CellRange targetcellrange = 4;
inline bool CommandFillCellsArchive::has_targetcellrange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandFillCellsArchive::set_has_targetcellrange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandFillCellsArchive::clear_has_targetcellrange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandFillCellsArchive::clear_targetcellrange() {
  if (targetcellrange_ != NULL) targetcellrange_->::TST::CellRange::Clear();
  clear_has_targetcellrange();
}
inline const ::TST::CellRange& CommandFillCellsArchive::targetcellrange() const {
  return targetcellrange_ != NULL ? *targetcellrange_ : *default_instance_->targetcellrange_;
}
inline ::TST::CellRange* CommandFillCellsArchive::mutable_targetcellrange() {
  set_has_targetcellrange();
  if (targetcellrange_ == NULL) targetcellrange_ = new ::TST::CellRange;
  return targetcellrange_;
}
inline ::TST::CellRange* CommandFillCellsArchive::release_targetcellrange() {
  clear_has_targetcellrange();
  ::TST::CellRange* temp = targetcellrange_;
  targetcellrange_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_targetcellrange(::TST::CellRange* targetcellrange) {
  delete targetcellrange_;
  targetcellrange_ = targetcellrange;
  if (targetcellrange) {
    set_has_targetcellrange();
  } else {
    clear_has_targetcellrange();
  }
}

// required .TST.CellMapArchive undo_cell_map = 5;
inline bool CommandFillCellsArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandFillCellsArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandFillCellsArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandFillCellsArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandFillCellsArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFillCellsArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFillCellsArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.FillDirectionArchive fillDirection = 6;
inline bool CommandFillCellsArchive::has_filldirection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandFillCellsArchive::set_has_filldirection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandFillCellsArchive::clear_has_filldirection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandFillCellsArchive::clear_filldirection() {
  filldirection_ = 1;
  clear_has_filldirection();
}
inline ::TST::FillDirectionArchive CommandFillCellsArchive::filldirection() const {
  return static_cast< ::TST::FillDirectionArchive >(filldirection_);
}
inline void CommandFillCellsArchive::set_filldirection(::TST::FillDirectionArchive value) {
  assert(::TST::FillDirectionArchive_IsValid(value));
  set_has_filldirection();
  filldirection_ = value;
}

// required .TST.SelectionArchive targetselection = 7;
inline bool CommandFillCellsArchive::has_targetselection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandFillCellsArchive::set_has_targetselection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandFillCellsArchive::clear_has_targetselection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandFillCellsArchive::clear_targetselection() {
  if (targetselection_ != NULL) targetselection_->::TST::SelectionArchive::Clear();
  clear_has_targetselection();
}
inline const ::TST::SelectionArchive& CommandFillCellsArchive::targetselection() const {
  return targetselection_ != NULL ? *targetselection_ : *default_instance_->targetselection_;
}
inline ::TST::SelectionArchive* CommandFillCellsArchive::mutable_targetselection() {
  set_has_targetselection();
  if (targetselection_ == NULL) targetselection_ = new ::TST::SelectionArchive;
  return targetselection_;
}
inline ::TST::SelectionArchive* CommandFillCellsArchive::release_targetselection() {
  clear_has_targetselection();
  ::TST::SelectionArchive* temp = targetselection_;
  targetselection_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_targetselection(::TST::SelectionArchive* targetselection) {
  delete targetselection_;
  targetselection_ = targetselection;
  if (targetselection) {
    set_has_targetselection();
  } else {
    clear_has_targetselection();
  }
}

// required .TST.CellMapArchive redo_cell_map = 8;
inline bool CommandFillCellsArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandFillCellsArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandFillCellsArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandFillCellsArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandFillCellsArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFillCellsArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandFillCellsArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandFillCellsArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandReplaceTextArchive

// required .TST.CellID cellID = 1;
inline bool CommandReplaceTextArchive::has_cellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReplaceTextArchive::set_has_cellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReplaceTextArchive::clear_has_cellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReplaceTextArchive::clear_cellid() {
  if (cellid_ != NULL) cellid_->::TST::CellID::Clear();
  clear_has_cellid();
}
inline const ::TST::CellID& CommandReplaceTextArchive::cellid() const {
  return cellid_ != NULL ? *cellid_ : *default_instance_->cellid_;
}
inline ::TST::CellID* CommandReplaceTextArchive::mutable_cellid() {
  set_has_cellid();
  if (cellid_ == NULL) cellid_ = new ::TST::CellID;
  return cellid_;
}
inline ::TST::CellID* CommandReplaceTextArchive::release_cellid() {
  clear_has_cellid();
  ::TST::CellID* temp = cellid_;
  cellid_ = NULL;
  return temp;
}
inline void CommandReplaceTextArchive::set_allocated_cellid(::TST::CellID* cellid) {
  delete cellid_;
  cellid_ = cellid;
  if (cellid) {
    set_has_cellid();
  } else {
    clear_has_cellid();
  }
}

// required .TST.Cell newcell = 2;
inline bool CommandReplaceTextArchive::has_newcell() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandReplaceTextArchive::set_has_newcell() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandReplaceTextArchive::clear_has_newcell() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandReplaceTextArchive::clear_newcell() {
  if (newcell_ != NULL) newcell_->::TST::Cell::Clear();
  clear_has_newcell();
}
inline const ::TST::Cell& CommandReplaceTextArchive::newcell() const {
  return newcell_ != NULL ? *newcell_ : *default_instance_->newcell_;
}
inline ::TST::Cell* CommandReplaceTextArchive::mutable_newcell() {
  set_has_newcell();
  if (newcell_ == NULL) newcell_ = new ::TST::Cell;
  return newcell_;
}
inline ::TST::Cell* CommandReplaceTextArchive::release_newcell() {
  clear_has_newcell();
  ::TST::Cell* temp = newcell_;
  newcell_ = NULL;
  return temp;
}
inline void CommandReplaceTextArchive::set_allocated_newcell(::TST::Cell* newcell) {
  delete newcell_;
  newcell_ = newcell;
  if (newcell) {
    set_has_newcell();
  } else {
    clear_has_newcell();
  }
}

// required .TST.Cell oldcell = 3;
inline bool CommandReplaceTextArchive::has_oldcell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandReplaceTextArchive::set_has_oldcell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandReplaceTextArchive::clear_has_oldcell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandReplaceTextArchive::clear_oldcell() {
  if (oldcell_ != NULL) oldcell_->::TST::Cell::Clear();
  clear_has_oldcell();
}
inline const ::TST::Cell& CommandReplaceTextArchive::oldcell() const {
  return oldcell_ != NULL ? *oldcell_ : *default_instance_->oldcell_;
}
inline ::TST::Cell* CommandReplaceTextArchive::mutable_oldcell() {
  set_has_oldcell();
  if (oldcell_ == NULL) oldcell_ = new ::TST::Cell;
  return oldcell_;
}
inline ::TST::Cell* CommandReplaceTextArchive::release_oldcell() {
  clear_has_oldcell();
  ::TST::Cell* temp = oldcell_;
  oldcell_ = NULL;
  return temp;
}
inline void CommandReplaceTextArchive::set_allocated_oldcell(::TST::Cell* oldcell) {
  delete oldcell_;
  oldcell_ = oldcell;
  if (oldcell) {
    set_has_oldcell();
  } else {
    clear_has_oldcell();
  }
}

// required .TST.TableCommandArchive super = 4;
inline bool CommandReplaceTextArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandReplaceTextArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandReplaceTextArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandReplaceTextArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandReplaceTextArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandReplaceTextArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandReplaceTextArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandReplaceTextArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference child_command_undo = 5;
inline bool CommandReplaceTextArchive::has_child_command_undo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandReplaceTextArchive::set_has_child_command_undo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandReplaceTextArchive::clear_has_child_command_undo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandReplaceTextArchive::clear_child_command_undo() {
  if (child_command_undo_ != NULL) child_command_undo_->::TSP::Reference::Clear();
  clear_has_child_command_undo();
}
inline const ::TSP::Reference& CommandReplaceTextArchive::child_command_undo() const {
  return child_command_undo_ != NULL ? *child_command_undo_ : *default_instance_->child_command_undo_;
}
inline ::TSP::Reference* CommandReplaceTextArchive::mutable_child_command_undo() {
  set_has_child_command_undo();
  if (child_command_undo_ == NULL) child_command_undo_ = new ::TSP::Reference;
  return child_command_undo_;
}
inline ::TSP::Reference* CommandReplaceTextArchive::release_child_command_undo() {
  clear_has_child_command_undo();
  ::TSP::Reference* temp = child_command_undo_;
  child_command_undo_ = NULL;
  return temp;
}
inline void CommandReplaceTextArchive::set_allocated_child_command_undo(::TSP::Reference* child_command_undo) {
  delete child_command_undo_;
  child_command_undo_ = child_command_undo;
  if (child_command_undo) {
    set_has_child_command_undo();
  } else {
    clear_has_child_command_undo();
  }
}

// -------------------------------------------------------------------

// CommandReplaceAllTextArchive

// required .TSP.Reference tableInfo = 1;
inline bool CommandReplaceAllTextArchive::has_tableinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReplaceAllTextArchive::set_has_tableinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReplaceAllTextArchive::clear_has_tableinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReplaceAllTextArchive::clear_tableinfo() {
  if (tableinfo_ != NULL) tableinfo_->::TSP::Reference::Clear();
  clear_has_tableinfo();
}
inline const ::TSP::Reference& CommandReplaceAllTextArchive::tableinfo() const {
  return tableinfo_ != NULL ? *tableinfo_ : *default_instance_->tableinfo_;
}
inline ::TSP::Reference* CommandReplaceAllTextArchive::mutable_tableinfo() {
  set_has_tableinfo();
  if (tableinfo_ == NULL) tableinfo_ = new ::TSP::Reference;
  return tableinfo_;
}
inline ::TSP::Reference* CommandReplaceAllTextArchive::release_tableinfo() {
  clear_has_tableinfo();
  ::TSP::Reference* temp = tableinfo_;
  tableinfo_ = NULL;
  return temp;
}
inline void CommandReplaceAllTextArchive::set_allocated_tableinfo(::TSP::Reference* tableinfo) {
  delete tableinfo_;
  tableinfo_ = tableinfo;
  if (tableinfo) {
    set_has_tableinfo();
  } else {
    clear_has_tableinfo();
  }
}

// required .TST.CellMapArchive undo_cell_map = 2;
inline bool CommandReplaceAllTextArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandReplaceAllTextArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandReplaceAllTextArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandReplaceAllTextArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandReplaceAllTextArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandReplaceAllTextArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandReplaceAllTextArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandReplaceAllTextArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 3;
inline bool CommandReplaceAllTextArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandReplaceAllTextArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandReplaceAllTextArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandReplaceAllTextArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandReplaceAllTextArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandReplaceAllTextArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandReplaceAllTextArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandReplaceAllTextArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandSetRepeatingHeaderEnabledArchive

// required bool repeating_header_enabled = 1;
inline bool CommandSetRepeatingHeaderEnabledArchive::has_repeating_header_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetRepeatingHeaderEnabledArchive::set_has_repeating_header_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetRepeatingHeaderEnabledArchive::clear_has_repeating_header_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetRepeatingHeaderEnabledArchive::clear_repeating_header_enabled() {
  repeating_header_enabled_ = false;
  clear_has_repeating_header_enabled();
}
inline bool CommandSetRepeatingHeaderEnabledArchive::repeating_header_enabled() const {
  return repeating_header_enabled_;
}
inline void CommandSetRepeatingHeaderEnabledArchive::set_repeating_header_enabled(bool value) {
  set_has_repeating_header_enabled();
  repeating_header_enabled_ = value;
}

// required .TST.CommandDirectionArchive direction = 2;
inline bool CommandSetRepeatingHeaderEnabledArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetRepeatingHeaderEnabledArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetRepeatingHeaderEnabledArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetRepeatingHeaderEnabledArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandSetRepeatingHeaderEnabledArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandSetRepeatingHeaderEnabledArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required .TST.TableCommandArchive super = 3;
inline bool CommandSetRepeatingHeaderEnabledArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetRepeatingHeaderEnabledArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetRepeatingHeaderEnabledArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetRepeatingHeaderEnabledArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetRepeatingHeaderEnabledArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetRepeatingHeaderEnabledArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetRepeatingHeaderEnabledArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetRepeatingHeaderEnabledArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetFiltersEnabledArchive

// required bool enable_filters = 1;
inline bool CommandSetFiltersEnabledArchive::has_enable_filters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFiltersEnabledArchive::set_has_enable_filters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFiltersEnabledArchive::clear_has_enable_filters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFiltersEnabledArchive::clear_enable_filters() {
  enable_filters_ = false;
  clear_has_enable_filters();
}
inline bool CommandSetFiltersEnabledArchive::enable_filters() const {
  return enable_filters_;
}
inline void CommandSetFiltersEnabledArchive::set_enable_filters(bool value) {
  set_has_enable_filters();
  enable_filters_ = value;
}

// required .TST.TableCommandArchive super = 2;
inline bool CommandSetFiltersEnabledArchive::has_super() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFiltersEnabledArchive::set_has_super() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFiltersEnabledArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFiltersEnabledArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetFiltersEnabledArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetFiltersEnabledArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetFiltersEnabledArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFiltersEnabledArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandAddQuickFilterRulesArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandAddQuickFilterRulesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandAddQuickFilterRulesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandAddQuickFilterRulesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandAddQuickFilterRulesArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandAddQuickFilterRulesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandAddQuickFilterRulesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandAddQuickFilterRulesArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandAddQuickFilterRulesArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TST.FilterRuleArchive rules = 2;
inline int CommandAddQuickFilterRulesArchive::rules_size() const {
  return rules_.size();
}
inline void CommandAddQuickFilterRulesArchive::clear_rules() {
  rules_.Clear();
}
inline const ::TST::FilterRuleArchive& CommandAddQuickFilterRulesArchive::rules(int index) const {
  return rules_.Get(index);
}
inline ::TST::FilterRuleArchive* CommandAddQuickFilterRulesArchive::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::TST::FilterRuleArchive* CommandAddQuickFilterRulesArchive::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >&
CommandAddQuickFilterRulesArchive::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >*
CommandAddQuickFilterRulesArchive::mutable_rules() {
  return &rules_;
}

// required uint32 filter_index = 3;
inline bool CommandAddQuickFilterRulesArchive::has_filter_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandAddQuickFilterRulesArchive::set_has_filter_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandAddQuickFilterRulesArchive::clear_has_filter_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandAddQuickFilterRulesArchive::clear_filter_index() {
  filter_index_ = 0u;
  clear_has_filter_index();
}
inline ::google::protobuf::uint32 CommandAddQuickFilterRulesArchive::filter_index() const {
  return filter_index_;
}
inline void CommandAddQuickFilterRulesArchive::set_filter_index(::google::protobuf::uint32 value) {
  set_has_filter_index();
  filter_index_ = value;
}

// repeated uint32 rule_indices = 4;
inline int CommandAddQuickFilterRulesArchive::rule_indices_size() const {
  return rule_indices_.size();
}
inline void CommandAddQuickFilterRulesArchive::clear_rule_indices() {
  rule_indices_.Clear();
}
inline ::google::protobuf::uint32 CommandAddQuickFilterRulesArchive::rule_indices(int index) const {
  return rule_indices_.Get(index);
}
inline void CommandAddQuickFilterRulesArchive::set_rule_indices(int index, ::google::protobuf::uint32 value) {
  rule_indices_.Set(index, value);
}
inline void CommandAddQuickFilterRulesArchive::add_rule_indices(::google::protobuf::uint32 value) {
  rule_indices_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandAddQuickFilterRulesArchive::rule_indices() const {
  return rule_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandAddQuickFilterRulesArchive::mutable_rule_indices() {
  return &rule_indices_;
}

// required bool filter_set_enabled = 5;
inline bool CommandAddQuickFilterRulesArchive::has_filter_set_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandAddQuickFilterRulesArchive::set_has_filter_set_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandAddQuickFilterRulesArchive::clear_has_filter_set_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandAddQuickFilterRulesArchive::clear_filter_set_enabled() {
  filter_set_enabled_ = false;
  clear_has_filter_set_enabled();
}
inline bool CommandAddQuickFilterRulesArchive::filter_set_enabled() const {
  return filter_set_enabled_;
}
inline void CommandAddQuickFilterRulesArchive::set_filter_set_enabled(bool value) {
  set_has_filter_set_enabled();
  filter_set_enabled_ = value;
}

// -------------------------------------------------------------------

// CommandDeleteFilterRulesArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandDeleteFilterRulesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDeleteFilterRulesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDeleteFilterRulesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDeleteFilterRulesArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandDeleteFilterRulesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandDeleteFilterRulesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandDeleteFilterRulesArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDeleteFilterRulesArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TST.FilterRuleArchive undo_rules = 2;
inline int CommandDeleteFilterRulesArchive::undo_rules_size() const {
  return undo_rules_.size();
}
inline void CommandDeleteFilterRulesArchive::clear_undo_rules() {
  undo_rules_.Clear();
}
inline const ::TST::FilterRuleArchive& CommandDeleteFilterRulesArchive::undo_rules(int index) const {
  return undo_rules_.Get(index);
}
inline ::TST::FilterRuleArchive* CommandDeleteFilterRulesArchive::mutable_undo_rules(int index) {
  return undo_rules_.Mutable(index);
}
inline ::TST::FilterRuleArchive* CommandDeleteFilterRulesArchive::add_undo_rules() {
  return undo_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >&
CommandDeleteFilterRulesArchive::undo_rules() const {
  return undo_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::FilterRuleArchive >*
CommandDeleteFilterRulesArchive::mutable_undo_rules() {
  return &undo_rules_;
}

// repeated uint32 rule_indices = 3;
inline int CommandDeleteFilterRulesArchive::rule_indices_size() const {
  return rule_indices_.size();
}
inline void CommandDeleteFilterRulesArchive::clear_rule_indices() {
  rule_indices_.Clear();
}
inline ::google::protobuf::uint32 CommandDeleteFilterRulesArchive::rule_indices(int index) const {
  return rule_indices_.Get(index);
}
inline void CommandDeleteFilterRulesArchive::set_rule_indices(int index, ::google::protobuf::uint32 value) {
  rule_indices_.Set(index, value);
}
inline void CommandDeleteFilterRulesArchive::add_rule_indices(::google::protobuf::uint32 value) {
  rule_indices_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandDeleteFilterRulesArchive::rule_indices() const {
  return rule_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandDeleteFilterRulesArchive::mutable_rule_indices() {
  return &rule_indices_;
}

// required bool filter_removed = 4;
inline bool CommandDeleteFilterRulesArchive::has_filter_removed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandDeleteFilterRulesArchive::set_has_filter_removed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandDeleteFilterRulesArchive::clear_has_filter_removed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandDeleteFilterRulesArchive::clear_filter_removed() {
  filter_removed_ = false;
  clear_has_filter_removed();
}
inline bool CommandDeleteFilterRulesArchive::filter_removed() const {
  return filter_removed_;
}
inline void CommandDeleteFilterRulesArchive::set_filter_removed(bool value) {
  set_has_filter_removed();
  filter_removed_ = value;
}

// required uint32 filter_index = 5;
inline bool CommandDeleteFilterRulesArchive::has_filter_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandDeleteFilterRulesArchive::set_has_filter_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandDeleteFilterRulesArchive::clear_has_filter_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandDeleteFilterRulesArchive::clear_filter_index() {
  filter_index_ = 0u;
  clear_has_filter_index();
}
inline ::google::protobuf::uint32 CommandDeleteFilterRulesArchive::filter_index() const {
  return filter_index_;
}
inline void CommandDeleteFilterRulesArchive::set_filter_index(::google::protobuf::uint32 value) {
  set_has_filter_index();
  filter_index_ = value;
}

// required bool filter_set_enabled = 6;
inline bool CommandDeleteFilterRulesArchive::has_filter_set_enabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandDeleteFilterRulesArchive::set_has_filter_set_enabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandDeleteFilterRulesArchive::clear_has_filter_set_enabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandDeleteFilterRulesArchive::clear_filter_set_enabled() {
  filter_set_enabled_ = false;
  clear_has_filter_set_enabled();
}
inline bool CommandDeleteFilterRulesArchive::filter_set_enabled() const {
  return filter_set_enabled_;
}
inline void CommandDeleteFilterRulesArchive::set_filter_set_enabled(bool value) {
  set_has_filter_set_enabled();
  filter_set_enabled_ = value;
}

// -------------------------------------------------------------------

// CommandModifyFilterRuleArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandModifyFilterRuleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandModifyFilterRuleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandModifyFilterRuleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandModifyFilterRuleArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandModifyFilterRuleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandModifyFilterRuleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandModifyFilterRuleArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandModifyFilterRuleArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.FilterRuleArchive undo_rule = 2;
inline bool CommandModifyFilterRuleArchive::has_undo_rule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandModifyFilterRuleArchive::set_has_undo_rule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandModifyFilterRuleArchive::clear_has_undo_rule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandModifyFilterRuleArchive::clear_undo_rule() {
  if (undo_rule_ != NULL) undo_rule_->::TST::FilterRuleArchive::Clear();
  clear_has_undo_rule();
}
inline const ::TST::FilterRuleArchive& CommandModifyFilterRuleArchive::undo_rule() const {
  return undo_rule_ != NULL ? *undo_rule_ : *default_instance_->undo_rule_;
}
inline ::TST::FilterRuleArchive* CommandModifyFilterRuleArchive::mutable_undo_rule() {
  set_has_undo_rule();
  if (undo_rule_ == NULL) undo_rule_ = new ::TST::FilterRuleArchive;
  return undo_rule_;
}
inline ::TST::FilterRuleArchive* CommandModifyFilterRuleArchive::release_undo_rule() {
  clear_has_undo_rule();
  ::TST::FilterRuleArchive* temp = undo_rule_;
  undo_rule_ = NULL;
  return temp;
}
inline void CommandModifyFilterRuleArchive::set_allocated_undo_rule(::TST::FilterRuleArchive* undo_rule) {
  delete undo_rule_;
  undo_rule_ = undo_rule;
  if (undo_rule) {
    set_has_undo_rule();
  } else {
    clear_has_undo_rule();
  }
}

// required .TST.FilterRuleArchive redo_rule = 3;
inline bool CommandModifyFilterRuleArchive::has_redo_rule() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandModifyFilterRuleArchive::set_has_redo_rule() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandModifyFilterRuleArchive::clear_has_redo_rule() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandModifyFilterRuleArchive::clear_redo_rule() {
  if (redo_rule_ != NULL) redo_rule_->::TST::FilterRuleArchive::Clear();
  clear_has_redo_rule();
}
inline const ::TST::FilterRuleArchive& CommandModifyFilterRuleArchive::redo_rule() const {
  return redo_rule_ != NULL ? *redo_rule_ : *default_instance_->redo_rule_;
}
inline ::TST::FilterRuleArchive* CommandModifyFilterRuleArchive::mutable_redo_rule() {
  set_has_redo_rule();
  if (redo_rule_ == NULL) redo_rule_ = new ::TST::FilterRuleArchive;
  return redo_rule_;
}
inline ::TST::FilterRuleArchive* CommandModifyFilterRuleArchive::release_redo_rule() {
  clear_has_redo_rule();
  ::TST::FilterRuleArchive* temp = redo_rule_;
  redo_rule_ = NULL;
  return temp;
}
inline void CommandModifyFilterRuleArchive::set_allocated_redo_rule(::TST::FilterRuleArchive* redo_rule) {
  delete redo_rule_;
  redo_rule_ = redo_rule;
  if (redo_rule) {
    set_has_redo_rule();
  } else {
    clear_has_redo_rule();
  }
}

// required uint32 rule_index = 4;
inline bool CommandModifyFilterRuleArchive::has_rule_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandModifyFilterRuleArchive::set_has_rule_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandModifyFilterRuleArchive::clear_has_rule_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandModifyFilterRuleArchive::clear_rule_index() {
  rule_index_ = 0u;
  clear_has_rule_index();
}
inline ::google::protobuf::uint32 CommandModifyFilterRuleArchive::rule_index() const {
  return rule_index_;
}
inline void CommandModifyFilterRuleArchive::set_rule_index(::google::protobuf::uint32 value) {
  set_has_rule_index();
  rule_index_ = value;
}

// required uint32 filter_index = 5;
inline bool CommandModifyFilterRuleArchive::has_filter_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandModifyFilterRuleArchive::set_has_filter_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandModifyFilterRuleArchive::clear_has_filter_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandModifyFilterRuleArchive::clear_filter_index() {
  filter_index_ = 0u;
  clear_has_filter_index();
}
inline ::google::protobuf::uint32 CommandModifyFilterRuleArchive::filter_index() const {
  return filter_index_;
}
inline void CommandModifyFilterRuleArchive::set_filter_index(::google::protobuf::uint32 value) {
  set_has_filter_index();
  filter_index_ = value;
}

// -------------------------------------------------------------------

// CommandApplyStrokePresetArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandApplyStrokePresetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyStrokePresetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyStrokePresetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyStrokePresetArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandApplyStrokePresetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandApplyStrokePresetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandApplyStrokePresetArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyStrokePresetArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellMapArchive undo_cell_map = 2;
inline bool CommandApplyStrokePresetArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyStrokePresetArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyStrokePresetArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyStrokePresetArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyStrokePresetArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyStrokePresetArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyStrokePresetArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyStrokePresetArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandApplyStrokePresetArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyStrokePresetArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyStrokePresetArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyStrokePresetArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyStrokePresetArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyStrokePresetArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyStrokePresetArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyStrokePresetArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// required .TST.SelectionArchive selection = 3;
inline bool CommandApplyStrokePresetArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandApplyStrokePresetArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandApplyStrokePresetArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandApplyStrokePresetArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandApplyStrokePresetArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandApplyStrokePresetArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandApplyStrokePresetArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandApplyStrokePresetArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// optional .TST.SelectionArchive expanded_selection = 6;
inline bool CommandApplyStrokePresetArchive::has_expanded_selection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandApplyStrokePresetArchive::set_has_expanded_selection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandApplyStrokePresetArchive::clear_has_expanded_selection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandApplyStrokePresetArchive::clear_expanded_selection() {
  if (expanded_selection_ != NULL) expanded_selection_->::TST::SelectionArchive::Clear();
  clear_has_expanded_selection();
}
inline const ::TST::SelectionArchive& CommandApplyStrokePresetArchive::expanded_selection() const {
  return expanded_selection_ != NULL ? *expanded_selection_ : *default_instance_->expanded_selection_;
}
inline ::TST::SelectionArchive* CommandApplyStrokePresetArchive::mutable_expanded_selection() {
  set_has_expanded_selection();
  if (expanded_selection_ == NULL) expanded_selection_ = new ::TST::SelectionArchive;
  return expanded_selection_;
}
inline ::TST::SelectionArchive* CommandApplyStrokePresetArchive::release_expanded_selection() {
  clear_has_expanded_selection();
  ::TST::SelectionArchive* temp = expanded_selection_;
  expanded_selection_ = NULL;
  return temp;
}
inline void CommandApplyStrokePresetArchive::set_allocated_expanded_selection(::TST::SelectionArchive* expanded_selection) {
  delete expanded_selection_;
  expanded_selection_ = expanded_selection;
  if (expanded_selection) {
    set_has_expanded_selection();
  } else {
    clear_has_expanded_selection();
  }
}

// required int32 preset_index = 5;
inline bool CommandApplyStrokePresetArchive::has_preset_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandApplyStrokePresetArchive::set_has_preset_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandApplyStrokePresetArchive::clear_has_preset_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandApplyStrokePresetArchive::clear_preset_index() {
  preset_index_ = 0;
  clear_has_preset_index();
}
inline ::google::protobuf::int32 CommandApplyStrokePresetArchive::preset_index() const {
  return preset_index_;
}
inline void CommandApplyStrokePresetArchive::set_preset_index(::google::protobuf::int32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// -------------------------------------------------------------------

// CommandAddTableStylePresetArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandAddTableStylePresetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandAddTableStylePresetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandAddTableStylePresetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandAddTableStylePresetArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandAddTableStylePresetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandAddTableStylePresetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandAddTableStylePresetArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandAddTableStylePresetArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required int32 preset_index = 2;
inline bool CommandAddTableStylePresetArchive::has_preset_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandAddTableStylePresetArchive::set_has_preset_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandAddTableStylePresetArchive::clear_has_preset_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandAddTableStylePresetArchive::clear_preset_index() {
  preset_index_ = 0;
  clear_has_preset_index();
}
inline ::google::protobuf::int32 CommandAddTableStylePresetArchive::preset_index() const {
  return preset_index_;
}
inline void CommandAddTableStylePresetArchive::set_preset_index(::google::protobuf::int32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// required .TST.TableStyleNetworkArchive table_styles = 3;
inline bool CommandAddTableStylePresetArchive::has_table_styles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandAddTableStylePresetArchive::set_has_table_styles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandAddTableStylePresetArchive::clear_has_table_styles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandAddTableStylePresetArchive::clear_table_styles() {
  if (table_styles_ != NULL) table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandAddTableStylePresetArchive::table_styles() const {
  return table_styles_ != NULL ? *table_styles_ : *default_instance_->table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandAddTableStylePresetArchive::mutable_table_styles() {
  set_has_table_styles();
  if (table_styles_ == NULL) table_styles_ = new ::TST::TableStyleNetworkArchive;
  return table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandAddTableStylePresetArchive::release_table_styles() {
  clear_has_table_styles();
  ::TST::TableStyleNetworkArchive* temp = table_styles_;
  table_styles_ = NULL;
  return temp;
}
inline void CommandAddTableStylePresetArchive::set_allocated_table_styles(::TST::TableStyleNetworkArchive* table_styles) {
  delete table_styles_;
  table_styles_ = table_styles;
  if (table_styles) {
    set_has_table_styles();
  } else {
    clear_has_table_styles();
  }
}

// required bool send_notification = 4;
inline bool CommandAddTableStylePresetArchive::has_send_notification() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandAddTableStylePresetArchive::set_has_send_notification() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandAddTableStylePresetArchive::clear_has_send_notification() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandAddTableStylePresetArchive::clear_send_notification() {
  send_notification_ = false;
  clear_has_send_notification();
}
inline bool CommandAddTableStylePresetArchive::send_notification() const {
  return send_notification_;
}
inline void CommandAddTableStylePresetArchive::set_send_notification(bool value) {
  set_has_send_notification();
  send_notification_ = value;
}

// -------------------------------------------------------------------

// CommandRemoveTableStylePresetArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandRemoveTableStylePresetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRemoveTableStylePresetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRemoveTableStylePresetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRemoveTableStylePresetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandRemoveTableStylePresetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandRemoveTableStylePresetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandRemoveTableStylePresetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRemoveTableStylePresetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference theme = 2;
inline bool CommandRemoveTableStylePresetArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRemoveTableStylePresetArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRemoveTableStylePresetArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRemoveTableStylePresetArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& CommandRemoveTableStylePresetArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* CommandRemoveTableStylePresetArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* CommandRemoveTableStylePresetArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void CommandRemoveTableStylePresetArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .TST.TableStyleNetworkArchive removed_table_styles = 3;
inline bool CommandRemoveTableStylePresetArchive::has_removed_table_styles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRemoveTableStylePresetArchive::set_has_removed_table_styles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRemoveTableStylePresetArchive::clear_has_removed_table_styles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRemoveTableStylePresetArchive::clear_removed_table_styles() {
  if (removed_table_styles_ != NULL) removed_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_removed_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandRemoveTableStylePresetArchive::removed_table_styles() const {
  return removed_table_styles_ != NULL ? *removed_table_styles_ : *default_instance_->removed_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandRemoveTableStylePresetArchive::mutable_removed_table_styles() {
  set_has_removed_table_styles();
  if (removed_table_styles_ == NULL) removed_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return removed_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandRemoveTableStylePresetArchive::release_removed_table_styles() {
  clear_has_removed_table_styles();
  ::TST::TableStyleNetworkArchive* temp = removed_table_styles_;
  removed_table_styles_ = NULL;
  return temp;
}
inline void CommandRemoveTableStylePresetArchive::set_allocated_removed_table_styles(::TST::TableStyleNetworkArchive* removed_table_styles) {
  delete removed_table_styles_;
  removed_table_styles_ = removed_table_styles;
  if (removed_table_styles) {
    set_has_removed_table_styles();
  } else {
    clear_has_removed_table_styles();
  }
}

// required int32 preset_id = 4;
inline bool CommandRemoveTableStylePresetArchive::has_preset_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRemoveTableStylePresetArchive::set_has_preset_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRemoveTableStylePresetArchive::clear_has_preset_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRemoveTableStylePresetArchive::clear_preset_id() {
  preset_id_ = 0;
  clear_has_preset_id();
}
inline ::google::protobuf::int32 CommandRemoveTableStylePresetArchive::preset_id() const {
  return preset_id_;
}
inline void CommandRemoveTableStylePresetArchive::set_preset_id(::google::protobuf::int32 value) {
  set_has_preset_id();
  preset_id_ = value;
}

// required int32 preset_index_in_theme = 5;
inline bool CommandRemoveTableStylePresetArchive::has_preset_index_in_theme() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRemoveTableStylePresetArchive::set_has_preset_index_in_theme() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRemoveTableStylePresetArchive::clear_has_preset_index_in_theme() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRemoveTableStylePresetArchive::clear_preset_index_in_theme() {
  preset_index_in_theme_ = 0;
  clear_has_preset_index_in_theme();
}
inline ::google::protobuf::int32 CommandRemoveTableStylePresetArchive::preset_index_in_theme() const {
  return preset_index_in_theme_;
}
inline void CommandRemoveTableStylePresetArchive::set_preset_index_in_theme(::google::protobuf::int32 value) {
  set_has_preset_index_in_theme();
  preset_index_in_theme_ = value;
}

// -------------------------------------------------------------------

// CommandReplaceTableStylePresetArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandReplaceTableStylePresetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReplaceTableStylePresetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReplaceTableStylePresetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReplaceTableStylePresetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandReplaceTableStylePresetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandReplaceTableStylePresetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandReplaceTableStylePresetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandReplaceTableStylePresetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference theme = 2;
inline bool CommandReplaceTableStylePresetArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandReplaceTableStylePresetArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandReplaceTableStylePresetArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandReplaceTableStylePresetArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& CommandReplaceTableStylePresetArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* CommandReplaceTableStylePresetArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* CommandReplaceTableStylePresetArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void CommandReplaceTableStylePresetArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .TST.TableStyleNetworkArchive old_table_styles = 3;
inline bool CommandReplaceTableStylePresetArchive::has_old_table_styles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandReplaceTableStylePresetArchive::set_has_old_table_styles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandReplaceTableStylePresetArchive::clear_has_old_table_styles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandReplaceTableStylePresetArchive::clear_old_table_styles() {
  if (old_table_styles_ != NULL) old_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_old_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandReplaceTableStylePresetArchive::old_table_styles() const {
  return old_table_styles_ != NULL ? *old_table_styles_ : *default_instance_->old_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandReplaceTableStylePresetArchive::mutable_old_table_styles() {
  set_has_old_table_styles();
  if (old_table_styles_ == NULL) old_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return old_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandReplaceTableStylePresetArchive::release_old_table_styles() {
  clear_has_old_table_styles();
  ::TST::TableStyleNetworkArchive* temp = old_table_styles_;
  old_table_styles_ = NULL;
  return temp;
}
inline void CommandReplaceTableStylePresetArchive::set_allocated_old_table_styles(::TST::TableStyleNetworkArchive* old_table_styles) {
  delete old_table_styles_;
  old_table_styles_ = old_table_styles;
  if (old_table_styles) {
    set_has_old_table_styles();
  } else {
    clear_has_old_table_styles();
  }
}

// required .TST.TableStyleNetworkArchive new_table_styles = 4;
inline bool CommandReplaceTableStylePresetArchive::has_new_table_styles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandReplaceTableStylePresetArchive::set_has_new_table_styles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandReplaceTableStylePresetArchive::clear_has_new_table_styles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandReplaceTableStylePresetArchive::clear_new_table_styles() {
  if (new_table_styles_ != NULL) new_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_new_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandReplaceTableStylePresetArchive::new_table_styles() const {
  return new_table_styles_ != NULL ? *new_table_styles_ : *default_instance_->new_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandReplaceTableStylePresetArchive::mutable_new_table_styles() {
  set_has_new_table_styles();
  if (new_table_styles_ == NULL) new_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return new_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandReplaceTableStylePresetArchive::release_new_table_styles() {
  clear_has_new_table_styles();
  ::TST::TableStyleNetworkArchive* temp = new_table_styles_;
  new_table_styles_ = NULL;
  return temp;
}
inline void CommandReplaceTableStylePresetArchive::set_allocated_new_table_styles(::TST::TableStyleNetworkArchive* new_table_styles) {
  delete new_table_styles_;
  new_table_styles_ = new_table_styles;
  if (new_table_styles) {
    set_has_new_table_styles();
  } else {
    clear_has_new_table_styles();
  }
}

// -------------------------------------------------------------------

// CommandApplyTableStylePresetArchive_StyleIndexTuple

// required uint32 index = 1;
inline bool CommandApplyTableStylePresetArchive_StyleIndexTuple::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandApplyTableStylePresetArchive_StyleIndexTuple::index() const {
  return index_;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .TSP.Reference cell_style = 5;
inline bool CommandApplyTableStylePresetArchive_StyleIndexTuple::has_cell_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::set_has_cell_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_has_cell_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_cell_style() {
  if (cell_style_ != NULL) cell_style_->::TSP::Reference::Clear();
  clear_has_cell_style();
}
inline const ::TSP::Reference& CommandApplyTableStylePresetArchive_StyleIndexTuple::cell_style() const {
  return cell_style_ != NULL ? *cell_style_ : *default_instance_->cell_style_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive_StyleIndexTuple::mutable_cell_style() {
  set_has_cell_style();
  if (cell_style_ == NULL) cell_style_ = new ::TSP::Reference;
  return cell_style_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive_StyleIndexTuple::release_cell_style() {
  clear_has_cell_style();
  ::TSP::Reference* temp = cell_style_;
  cell_style_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::set_allocated_cell_style(::TSP::Reference* cell_style) {
  delete cell_style_;
  cell_style_ = cell_style;
  if (cell_style) {
    set_has_cell_style();
  } else {
    clear_has_cell_style();
  }
}

// optional .TSP.Reference text_style = 6;
inline bool CommandApplyTableStylePresetArchive_StyleIndexTuple::has_text_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::set_has_text_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_has_text_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_text_style() {
  if (text_style_ != NULL) text_style_->::TSP::Reference::Clear();
  clear_has_text_style();
}
inline const ::TSP::Reference& CommandApplyTableStylePresetArchive_StyleIndexTuple::text_style() const {
  return text_style_ != NULL ? *text_style_ : *default_instance_->text_style_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive_StyleIndexTuple::mutable_text_style() {
  set_has_text_style();
  if (text_style_ == NULL) text_style_ = new ::TSP::Reference;
  return text_style_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive_StyleIndexTuple::release_text_style() {
  clear_has_text_style();
  ::TSP::Reference* temp = text_style_;
  text_style_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::set_allocated_text_style(::TSP::Reference* text_style) {
  delete text_style_;
  text_style_ = text_style;
  if (text_style) {
    set_has_text_style();
  } else {
    clear_has_text_style();
  }
}

// -------------------------------------------------------------------

// CommandApplyTableStylePresetArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandApplyTableStylePresetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyTableStylePresetArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandApplyTableStylePresetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandApplyTableStylePresetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandApplyTableStylePresetArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellMapArchive undo_cell_map = 2;
inline bool CommandApplyTableStylePresetArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyTableStylePresetArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyTableStylePresetArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyTableStylePresetArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyTableStylePresetArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandApplyTableStylePresetArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyTableStylePresetArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyTableStylePresetArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyTableStylePresetArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyTableStylePresetArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// required int32 preset_index = 5;
inline bool CommandApplyTableStylePresetArchive::has_preset_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_preset_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_preset_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandApplyTableStylePresetArchive::clear_preset_index() {
  preset_index_ = 0;
  clear_has_preset_index();
}
inline ::google::protobuf::int32 CommandApplyTableStylePresetArchive::preset_index() const {
  return preset_index_;
}
inline void CommandApplyTableStylePresetArchive::set_preset_index(::google::protobuf::int32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// required .TST.TableStyleNetworkArchive old_table_styles = 7;
inline bool CommandApplyTableStylePresetArchive::has_old_table_styles() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_old_table_styles() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_old_table_styles() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandApplyTableStylePresetArchive::clear_old_table_styles() {
  if (old_table_styles_ != NULL) old_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_old_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandApplyTableStylePresetArchive::old_table_styles() const {
  return old_table_styles_ != NULL ? *old_table_styles_ : *default_instance_->old_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyTableStylePresetArchive::mutable_old_table_styles() {
  set_has_old_table_styles();
  if (old_table_styles_ == NULL) old_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return old_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyTableStylePresetArchive::release_old_table_styles() {
  clear_has_old_table_styles();
  ::TST::TableStyleNetworkArchive* temp = old_table_styles_;
  old_table_styles_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_old_table_styles(::TST::TableStyleNetworkArchive* old_table_styles) {
  delete old_table_styles_;
  old_table_styles_ = old_table_styles;
  if (old_table_styles) {
    set_has_old_table_styles();
  } else {
    clear_has_old_table_styles();
  }
}

// optional .TST.TableStyleNetworkArchive new_table_styles = 8 [deprecated = true];
inline bool CommandApplyTableStylePresetArchive::has_new_table_styles() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_new_table_styles() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_new_table_styles() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandApplyTableStylePresetArchive::clear_new_table_styles() {
  if (new_table_styles_ != NULL) new_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_new_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandApplyTableStylePresetArchive::new_table_styles() const {
  return new_table_styles_ != NULL ? *new_table_styles_ : *default_instance_->new_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyTableStylePresetArchive::mutable_new_table_styles() {
  set_has_new_table_styles();
  if (new_table_styles_ == NULL) new_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return new_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyTableStylePresetArchive::release_new_table_styles() {
  clear_has_new_table_styles();
  ::TST::TableStyleNetworkArchive* temp = new_table_styles_;
  new_table_styles_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_new_table_styles(::TST::TableStyleNetworkArchive* new_table_styles) {
  delete new_table_styles_;
  new_table_styles_ = new_table_styles;
  if (new_table_styles) {
    set_has_new_table_styles();
  } else {
    clear_has_new_table_styles();
  }
}

// optional bool apply_clears_all = 10;
inline bool CommandApplyTableStylePresetArchive::has_apply_clears_all() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_apply_clears_all() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_apply_clears_all() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandApplyTableStylePresetArchive::clear_apply_clears_all() {
  apply_clears_all_ = false;
  clear_has_apply_clears_all();
}
inline bool CommandApplyTableStylePresetArchive::apply_clears_all() const {
  return apply_clears_all_;
}
inline void CommandApplyTableStylePresetArchive::set_apply_clears_all(bool value) {
  set_has_apply_clears_all();
  apply_clears_all_ = value;
}

// optional .TSP.Reference font_size_command = 11;
inline bool CommandApplyTableStylePresetArchive::has_font_size_command() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_font_size_command() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_font_size_command() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandApplyTableStylePresetArchive::clear_font_size_command() {
  if (font_size_command_ != NULL) font_size_command_->::TSP::Reference::Clear();
  clear_has_font_size_command();
}
inline const ::TSP::Reference& CommandApplyTableStylePresetArchive::font_size_command() const {
  return font_size_command_ != NULL ? *font_size_command_ : *default_instance_->font_size_command_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive::mutable_font_size_command() {
  set_has_font_size_command();
  if (font_size_command_ == NULL) font_size_command_ = new ::TSP::Reference;
  return font_size_command_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive::release_font_size_command() {
  clear_has_font_size_command();
  ::TSP::Reference* temp = font_size_command_;
  font_size_command_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_font_size_command(::TSP::Reference* font_size_command) {
  delete font_size_command_;
  font_size_command_ = font_size_command;
  if (font_size_command) {
    set_has_font_size_command();
  } else {
    clear_has_font_size_command();
  }
}

// optional .TSP.Reference set_style_apply_clears_all_flag_command = 12;
inline bool CommandApplyTableStylePresetArchive::has_set_style_apply_clears_all_flag_command() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandApplyTableStylePresetArchive::set_has_set_style_apply_clears_all_flag_command() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandApplyTableStylePresetArchive::clear_has_set_style_apply_clears_all_flag_command() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandApplyTableStylePresetArchive::clear_set_style_apply_clears_all_flag_command() {
  if (set_style_apply_clears_all_flag_command_ != NULL) set_style_apply_clears_all_flag_command_->::TSP::Reference::Clear();
  clear_has_set_style_apply_clears_all_flag_command();
}
inline const ::TSP::Reference& CommandApplyTableStylePresetArchive::set_style_apply_clears_all_flag_command() const {
  return set_style_apply_clears_all_flag_command_ != NULL ? *set_style_apply_clears_all_flag_command_ : *default_instance_->set_style_apply_clears_all_flag_command_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive::mutable_set_style_apply_clears_all_flag_command() {
  set_has_set_style_apply_clears_all_flag_command();
  if (set_style_apply_clears_all_flag_command_ == NULL) set_style_apply_clears_all_flag_command_ = new ::TSP::Reference;
  return set_style_apply_clears_all_flag_command_;
}
inline ::TSP::Reference* CommandApplyTableStylePresetArchive::release_set_style_apply_clears_all_flag_command() {
  clear_has_set_style_apply_clears_all_flag_command();
  ::TSP::Reference* temp = set_style_apply_clears_all_flag_command_;
  set_style_apply_clears_all_flag_command_ = NULL;
  return temp;
}
inline void CommandApplyTableStylePresetArchive::set_allocated_set_style_apply_clears_all_flag_command(::TSP::Reference* set_style_apply_clears_all_flag_command) {
  delete set_style_apply_clears_all_flag_command_;
  set_style_apply_clears_all_flag_command_ = set_style_apply_clears_all_flag_command;
  if (set_style_apply_clears_all_flag_command) {
    set_has_set_style_apply_clears_all_flag_command();
  } else {
    clear_has_set_style_apply_clears_all_flag_command();
  }
}

// repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple row_style_index_tuples = 13;
inline int CommandApplyTableStylePresetArchive::row_style_index_tuples_size() const {
  return row_style_index_tuples_.size();
}
inline void CommandApplyTableStylePresetArchive::clear_row_style_index_tuples() {
  row_style_index_tuples_.Clear();
}
inline const ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple& CommandApplyTableStylePresetArchive::row_style_index_tuples(int index) const {
  return row_style_index_tuples_.Get(index);
}
inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* CommandApplyTableStylePresetArchive::mutable_row_style_index_tuples(int index) {
  return row_style_index_tuples_.Mutable(index);
}
inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* CommandApplyTableStylePresetArchive::add_row_style_index_tuples() {
  return row_style_index_tuples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >&
CommandApplyTableStylePresetArchive::row_style_index_tuples() const {
  return row_style_index_tuples_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >*
CommandApplyTableStylePresetArchive::mutable_row_style_index_tuples() {
  return &row_style_index_tuples_;
}

// repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple col_style_index_tuples = 14;
inline int CommandApplyTableStylePresetArchive::col_style_index_tuples_size() const {
  return col_style_index_tuples_.size();
}
inline void CommandApplyTableStylePresetArchive::clear_col_style_index_tuples() {
  col_style_index_tuples_.Clear();
}
inline const ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple& CommandApplyTableStylePresetArchive::col_style_index_tuples(int index) const {
  return col_style_index_tuples_.Get(index);
}
inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* CommandApplyTableStylePresetArchive::mutable_col_style_index_tuples(int index) {
  return col_style_index_tuples_.Mutable(index);
}
inline ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple* CommandApplyTableStylePresetArchive::add_col_style_index_tuples() {
  return col_style_index_tuples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >&
CommandApplyTableStylePresetArchive::col_style_index_tuples() const {
  return col_style_index_tuples_;
}
inline ::google::protobuf::RepeatedPtrField< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >*
CommandApplyTableStylePresetArchive::mutable_col_style_index_tuples() {
  return &col_style_index_tuples_;
}

// -------------------------------------------------------------------

// CommandSetStyleApplyClearsAllFlagArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetStyleApplyClearsAllFlagArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetStyleApplyClearsAllFlagArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetStyleApplyClearsAllFlagArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetStyleApplyClearsAllFlagArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool apply_clears_all = 2;
inline bool CommandSetStyleApplyClearsAllFlagArchive::has_apply_clears_all() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::set_has_apply_clears_all() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::clear_has_apply_clears_all() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::clear_apply_clears_all() {
  apply_clears_all_ = false;
  clear_has_apply_clears_all();
}
inline bool CommandSetStyleApplyClearsAllFlagArchive::apply_clears_all() const {
  return apply_clears_all_;
}
inline void CommandSetStyleApplyClearsAllFlagArchive::set_apply_clears_all(bool value) {
  set_has_apply_clears_all();
  apply_clears_all_ = value;
}

// -------------------------------------------------------------------

// CommandApplyThemeToTableArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandApplyThemeToTableArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyThemeToTableArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyThemeToTableArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyThemeToTableArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandApplyThemeToTableArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandApplyThemeToTableArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandApplyThemeToTableArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyThemeToTableArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellMapArchive undo_cell_map = 2;
inline bool CommandApplyThemeToTableArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyThemeToTableArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyThemeToTableArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyThemeToTableArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyThemeToTableArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyThemeToTableArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyThemeToTableArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyThemeToTableArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandApplyThemeToTableArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyThemeToTableArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyThemeToTableArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyThemeToTableArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyThemeToTableArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyThemeToTableArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyThemeToTableArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyThemeToTableArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// required .TST.TableStyleNetworkArchive old_table_styles = 7;
inline bool CommandApplyThemeToTableArchive::has_old_table_styles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandApplyThemeToTableArchive::set_has_old_table_styles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandApplyThemeToTableArchive::clear_has_old_table_styles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandApplyThemeToTableArchive::clear_old_table_styles() {
  if (old_table_styles_ != NULL) old_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_old_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandApplyThemeToTableArchive::old_table_styles() const {
  return old_table_styles_ != NULL ? *old_table_styles_ : *default_instance_->old_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyThemeToTableArchive::mutable_old_table_styles() {
  set_has_old_table_styles();
  if (old_table_styles_ == NULL) old_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return old_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyThemeToTableArchive::release_old_table_styles() {
  clear_has_old_table_styles();
  ::TST::TableStyleNetworkArchive* temp = old_table_styles_;
  old_table_styles_ = NULL;
  return temp;
}
inline void CommandApplyThemeToTableArchive::set_allocated_old_table_styles(::TST::TableStyleNetworkArchive* old_table_styles) {
  delete old_table_styles_;
  old_table_styles_ = old_table_styles;
  if (old_table_styles) {
    set_has_old_table_styles();
  } else {
    clear_has_old_table_styles();
  }
}

// required .TST.TableStyleNetworkArchive new_table_styles = 8;
inline bool CommandApplyThemeToTableArchive::has_new_table_styles() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandApplyThemeToTableArchive::set_has_new_table_styles() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandApplyThemeToTableArchive::clear_has_new_table_styles() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandApplyThemeToTableArchive::clear_new_table_styles() {
  if (new_table_styles_ != NULL) new_table_styles_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_new_table_styles();
}
inline const ::TST::TableStyleNetworkArchive& CommandApplyThemeToTableArchive::new_table_styles() const {
  return new_table_styles_ != NULL ? *new_table_styles_ : *default_instance_->new_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyThemeToTableArchive::mutable_new_table_styles() {
  set_has_new_table_styles();
  if (new_table_styles_ == NULL) new_table_styles_ = new ::TST::TableStyleNetworkArchive;
  return new_table_styles_;
}
inline ::TST::TableStyleNetworkArchive* CommandApplyThemeToTableArchive::release_new_table_styles() {
  clear_has_new_table_styles();
  ::TST::TableStyleNetworkArchive* temp = new_table_styles_;
  new_table_styles_ = NULL;
  return temp;
}
inline void CommandApplyThemeToTableArchive::set_allocated_new_table_styles(::TST::TableStyleNetworkArchive* new_table_styles) {
  delete new_table_styles_;
  new_table_styles_ = new_table_styles;
  if (new_table_styles) {
    set_has_new_table_styles();
  } else {
    clear_has_new_table_styles();
  }
}

// -------------------------------------------------------------------

// CommandApplyThemeChildForTableArchive

// required .TSS.ApplyThemeChildCommandArchive super = 1;
inline bool CommandApplyThemeChildForTableArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyThemeChildForTableArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyThemeChildForTableArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyThemeChildForTableArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::ApplyThemeChildCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSS::ApplyThemeChildCommandArchive& CommandApplyThemeChildForTableArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* CommandApplyThemeChildForTableArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::ApplyThemeChildCommandArchive;
  return super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* CommandApplyThemeChildForTableArchive::release_super() {
  clear_has_super();
  ::TSS::ApplyThemeChildCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyThemeChildForTableArchive::set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference apply_command = 2;
inline bool CommandApplyThemeChildForTableArchive::has_apply_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyThemeChildForTableArchive::set_has_apply_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyThemeChildForTableArchive::clear_has_apply_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyThemeChildForTableArchive::clear_apply_command() {
  if (apply_command_ != NULL) apply_command_->::TSP::Reference::Clear();
  clear_has_apply_command();
}
inline const ::TSP::Reference& CommandApplyThemeChildForTableArchive::apply_command() const {
  return apply_command_ != NULL ? *apply_command_ : *default_instance_->apply_command_;
}
inline ::TSP::Reference* CommandApplyThemeChildForTableArchive::mutable_apply_command() {
  set_has_apply_command();
  if (apply_command_ == NULL) apply_command_ = new ::TSP::Reference;
  return apply_command_;
}
inline ::TSP::Reference* CommandApplyThemeChildForTableArchive::release_apply_command() {
  clear_has_apply_command();
  ::TSP::Reference* temp = apply_command_;
  apply_command_ = NULL;
  return temp;
}
inline void CommandApplyThemeChildForTableArchive::set_allocated_apply_command(::TSP::Reference* apply_command) {
  delete apply_command_;
  apply_command_ = apply_command;
  if (apply_command) {
    set_has_apply_command();
  } else {
    clear_has_apply_command();
  }
}

// -------------------------------------------------------------------

// CommandToggleTextPropertyArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandToggleTextPropertyArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandToggleTextPropertyArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandToggleTextPropertyArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandToggleTextPropertyArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandToggleTextPropertyArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandToggleTextPropertyArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.SelectionArchive selection = 2;
inline bool CommandToggleTextPropertyArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandToggleTextPropertyArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandToggleTextPropertyArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandToggleTextPropertyArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandToggleTextPropertyArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandToggleTextPropertyArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required uint32 property = 3;
inline bool CommandToggleTextPropertyArchive::has_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandToggleTextPropertyArchive::clear_has_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandToggleTextPropertyArchive::clear_property() {
  property_ = 0u;
  clear_has_property();
}
inline ::google::protobuf::uint32 CommandToggleTextPropertyArchive::property() const {
  return property_;
}
inline void CommandToggleTextPropertyArchive::set_property(::google::protobuf::uint32 value) {
  set_has_property();
  property_ = value;
}

// required .TST.CellMapArchive undo_cell_map = 4;
inline bool CommandToggleTextPropertyArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandToggleTextPropertyArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandToggleTextPropertyArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandToggleTextPropertyArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandToggleTextPropertyArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandToggleTextPropertyArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 5;
inline bool CommandToggleTextPropertyArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandToggleTextPropertyArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandToggleTextPropertyArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandToggleTextPropertyArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandToggleTextPropertyArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandToggleTextPropertyArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// required .TST.Cell default_body_cell = 6;
inline bool CommandToggleTextPropertyArchive::has_default_body_cell() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_default_body_cell() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandToggleTextPropertyArchive::clear_has_default_body_cell() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandToggleTextPropertyArchive::clear_default_body_cell() {
  if (default_body_cell_ != NULL) default_body_cell_->::TST::Cell::Clear();
  clear_has_default_body_cell();
}
inline const ::TST::Cell& CommandToggleTextPropertyArchive::default_body_cell() const {
  return default_body_cell_ != NULL ? *default_body_cell_ : *default_instance_->default_body_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::mutable_default_body_cell() {
  set_has_default_body_cell();
  if (default_body_cell_ == NULL) default_body_cell_ = new ::TST::Cell;
  return default_body_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::release_default_body_cell() {
  clear_has_default_body_cell();
  ::TST::Cell* temp = default_body_cell_;
  default_body_cell_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_default_body_cell(::TST::Cell* default_body_cell) {
  delete default_body_cell_;
  default_body_cell_ = default_body_cell;
  if (default_body_cell) {
    set_has_default_body_cell();
  } else {
    clear_has_default_body_cell();
  }
}

// required .TST.Cell default_hr_cell = 7;
inline bool CommandToggleTextPropertyArchive::has_default_hr_cell() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_default_hr_cell() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandToggleTextPropertyArchive::clear_has_default_hr_cell() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandToggleTextPropertyArchive::clear_default_hr_cell() {
  if (default_hr_cell_ != NULL) default_hr_cell_->::TST::Cell::Clear();
  clear_has_default_hr_cell();
}
inline const ::TST::Cell& CommandToggleTextPropertyArchive::default_hr_cell() const {
  return default_hr_cell_ != NULL ? *default_hr_cell_ : *default_instance_->default_hr_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::mutable_default_hr_cell() {
  set_has_default_hr_cell();
  if (default_hr_cell_ == NULL) default_hr_cell_ = new ::TST::Cell;
  return default_hr_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::release_default_hr_cell() {
  clear_has_default_hr_cell();
  ::TST::Cell* temp = default_hr_cell_;
  default_hr_cell_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_default_hr_cell(::TST::Cell* default_hr_cell) {
  delete default_hr_cell_;
  default_hr_cell_ = default_hr_cell;
  if (default_hr_cell) {
    set_has_default_hr_cell();
  } else {
    clear_has_default_hr_cell();
  }
}

// required .TST.Cell default_hc_cell = 8;
inline bool CommandToggleTextPropertyArchive::has_default_hc_cell() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_default_hc_cell() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandToggleTextPropertyArchive::clear_has_default_hc_cell() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandToggleTextPropertyArchive::clear_default_hc_cell() {
  if (default_hc_cell_ != NULL) default_hc_cell_->::TST::Cell::Clear();
  clear_has_default_hc_cell();
}
inline const ::TST::Cell& CommandToggleTextPropertyArchive::default_hc_cell() const {
  return default_hc_cell_ != NULL ? *default_hc_cell_ : *default_instance_->default_hc_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::mutable_default_hc_cell() {
  set_has_default_hc_cell();
  if (default_hc_cell_ == NULL) default_hc_cell_ = new ::TST::Cell;
  return default_hc_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::release_default_hc_cell() {
  clear_has_default_hc_cell();
  ::TST::Cell* temp = default_hc_cell_;
  default_hc_cell_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_default_hc_cell(::TST::Cell* default_hc_cell) {
  delete default_hc_cell_;
  default_hc_cell_ = default_hc_cell;
  if (default_hc_cell) {
    set_has_default_hc_cell();
  } else {
    clear_has_default_hc_cell();
  }
}

// required .TST.Cell default_fr_cell = 9;
inline bool CommandToggleTextPropertyArchive::has_default_fr_cell() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_default_fr_cell() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandToggleTextPropertyArchive::clear_has_default_fr_cell() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandToggleTextPropertyArchive::clear_default_fr_cell() {
  if (default_fr_cell_ != NULL) default_fr_cell_->::TST::Cell::Clear();
  clear_has_default_fr_cell();
}
inline const ::TST::Cell& CommandToggleTextPropertyArchive::default_fr_cell() const {
  return default_fr_cell_ != NULL ? *default_fr_cell_ : *default_instance_->default_fr_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::mutable_default_fr_cell() {
  set_has_default_fr_cell();
  if (default_fr_cell_ == NULL) default_fr_cell_ = new ::TST::Cell;
  return default_fr_cell_;
}
inline ::TST::Cell* CommandToggleTextPropertyArchive::release_default_fr_cell() {
  clear_has_default_fr_cell();
  ::TST::Cell* temp = default_fr_cell_;
  default_fr_cell_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_default_fr_cell(::TST::Cell* default_fr_cell) {
  delete default_fr_cell_;
  default_fr_cell_ = default_fr_cell;
  if (default_fr_cell) {
    set_has_default_fr_cell();
  } else {
    clear_has_default_fr_cell();
  }
}

// optional .TSP.Reference text_undo = 10;
inline bool CommandToggleTextPropertyArchive::has_text_undo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommandToggleTextPropertyArchive::set_has_text_undo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommandToggleTextPropertyArchive::clear_has_text_undo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommandToggleTextPropertyArchive::clear_text_undo() {
  if (text_undo_ != NULL) text_undo_->::TSP::Reference::Clear();
  clear_has_text_undo();
}
inline const ::TSP::Reference& CommandToggleTextPropertyArchive::text_undo() const {
  return text_undo_ != NULL ? *text_undo_ : *default_instance_->text_undo_;
}
inline ::TSP::Reference* CommandToggleTextPropertyArchive::mutable_text_undo() {
  set_has_text_undo();
  if (text_undo_ == NULL) text_undo_ = new ::TSP::Reference;
  return text_undo_;
}
inline ::TSP::Reference* CommandToggleTextPropertyArchive::release_text_undo() {
  clear_has_text_undo();
  ::TSP::Reference* temp = text_undo_;
  text_undo_ = NULL;
  return temp;
}
inline void CommandToggleTextPropertyArchive::set_allocated_text_undo(::TSP::Reference* text_undo) {
  delete text_undo_;
  text_undo_ = text_undo;
  if (text_undo) {
    set_has_text_undo();
  } else {
    clear_has_text_undo();
  }
}

// -------------------------------------------------------------------

// CommandResetFillPropertyToDefault

// required .TST.TableCommandArchive super = 1;
inline bool CommandResetFillPropertyToDefault::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandResetFillPropertyToDefault::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandResetFillPropertyToDefault::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandResetFillPropertyToDefault::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandResetFillPropertyToDefault::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandResetFillPropertyToDefault::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandResetFillPropertyToDefault::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandResetFillPropertyToDefault::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.SelectionArchive selection = 2;
inline bool CommandResetFillPropertyToDefault::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandResetFillPropertyToDefault::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandResetFillPropertyToDefault::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandResetFillPropertyToDefault::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandResetFillPropertyToDefault::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandResetFillPropertyToDefault::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandResetFillPropertyToDefault::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandResetFillPropertyToDefault::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_cell_map = 4;
inline bool CommandResetFillPropertyToDefault::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandResetFillPropertyToDefault::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandResetFillPropertyToDefault::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandResetFillPropertyToDefault::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandResetFillPropertyToDefault::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandResetFillPropertyToDefault::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandResetFillPropertyToDefault::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandResetFillPropertyToDefault::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 5;
inline bool CommandResetFillPropertyToDefault::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandResetFillPropertyToDefault::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandResetFillPropertyToDefault::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandResetFillPropertyToDefault::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandResetFillPropertyToDefault::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandResetFillPropertyToDefault::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandResetFillPropertyToDefault::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandResetFillPropertyToDefault::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandSetSingleNumberFormatParameterArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetSingleNumberFormatParameterArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetSingleNumberFormatParameterArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetSingleNumberFormatParameterArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetSingleNumberFormatParameterArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.SelectionArchive selection = 2;
inline bool CommandSetSingleNumberFormatParameterArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetSingleNumberFormatParameterArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetSingleNumberFormatParameterArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetSingleNumberFormatParameterArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_cell_map = 3;
inline bool CommandSetSingleNumberFormatParameterArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetSingleNumberFormatParameterArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetSingleNumberFormatParameterArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetSingleNumberFormatParameterArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandSetSingleNumberFormatParameterArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetSingleNumberFormatParameterArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetSingleNumberFormatParameterArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetSingleNumberFormatParameterArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetSingleNumberFormatParameterArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetSingleNumberFormatParameterArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandSetBaseArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetBaseArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetBaseArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetBaseArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetBaseArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetBaseArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetBaseArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetBaseArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetBaseArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 base = 2;
inline bool CommandSetBaseArchive::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetBaseArchive::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetBaseArchive::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetBaseArchive::clear_base() {
  base_ = 0u;
  clear_has_base();
}
inline ::google::protobuf::uint32 CommandSetBaseArchive::base() const {
  return base_;
}
inline void CommandSetBaseArchive::set_base(::google::protobuf::uint32 value) {
  set_has_base();
  base_ = value;
}

// -------------------------------------------------------------------

// CommandSetBasePlacesArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetBasePlacesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetBasePlacesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetBasePlacesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetBasePlacesArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetBasePlacesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetBasePlacesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetBasePlacesArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetBasePlacesArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 base_places = 2;
inline bool CommandSetBasePlacesArchive::has_base_places() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetBasePlacesArchive::set_has_base_places() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetBasePlacesArchive::clear_has_base_places() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetBasePlacesArchive::clear_base_places() {
  base_places_ = 0u;
  clear_has_base_places();
}
inline ::google::protobuf::uint32 CommandSetBasePlacesArchive::base_places() const {
  return base_places_;
}
inline void CommandSetBasePlacesArchive::set_base_places(::google::protobuf::uint32 value) {
  set_has_base_places();
  base_places_ = value;
}

// -------------------------------------------------------------------

// CommandSetBaseUseMinusSignArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetBaseUseMinusSignArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetBaseUseMinusSignArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetBaseUseMinusSignArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetBaseUseMinusSignArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetBaseUseMinusSignArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetBaseUseMinusSignArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetBaseUseMinusSignArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetBaseUseMinusSignArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool base_use_minus_sign = 2;
inline bool CommandSetBaseUseMinusSignArchive::has_base_use_minus_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetBaseUseMinusSignArchive::set_has_base_use_minus_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetBaseUseMinusSignArchive::clear_has_base_use_minus_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetBaseUseMinusSignArchive::clear_base_use_minus_sign() {
  base_use_minus_sign_ = false;
  clear_has_base_use_minus_sign();
}
inline bool CommandSetBaseUseMinusSignArchive::base_use_minus_sign() const {
  return base_use_minus_sign_;
}
inline void CommandSetBaseUseMinusSignArchive::set_base_use_minus_sign(bool value) {
  set_has_base_use_minus_sign();
  base_use_minus_sign_ = value;
}

// -------------------------------------------------------------------

// CommandSetControlMinimumArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetControlMinimumArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetControlMinimumArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetControlMinimumArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetControlMinimumArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetControlMinimumArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetControlMinimumArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetControlMinimumArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetControlMinimumArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required double minimum = 2;
inline bool CommandSetControlMinimumArchive::has_minimum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetControlMinimumArchive::set_has_minimum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetControlMinimumArchive::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetControlMinimumArchive::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline double CommandSetControlMinimumArchive::minimum() const {
  return minimum_;
}
inline void CommandSetControlMinimumArchive::set_minimum(double value) {
  set_has_minimum();
  minimum_ = value;
}

// required uint32 format_type = 3;
inline bool CommandSetControlMinimumArchive::has_format_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetControlMinimumArchive::set_has_format_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetControlMinimumArchive::clear_has_format_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetControlMinimumArchive::clear_format_type() {
  format_type_ = 0u;
  clear_has_format_type();
}
inline ::google::protobuf::uint32 CommandSetControlMinimumArchive::format_type() const {
  return format_type_;
}
inline void CommandSetControlMinimumArchive::set_format_type(::google::protobuf::uint32 value) {
  set_has_format_type();
  format_type_ = value;
}

// -------------------------------------------------------------------

// CommandSetControlMaximumArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetControlMaximumArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetControlMaximumArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetControlMaximumArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetControlMaximumArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetControlMaximumArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetControlMaximumArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetControlMaximumArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetControlMaximumArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required double maximum = 2;
inline bool CommandSetControlMaximumArchive::has_maximum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetControlMaximumArchive::set_has_maximum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetControlMaximumArchive::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetControlMaximumArchive::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline double CommandSetControlMaximumArchive::maximum() const {
  return maximum_;
}
inline void CommandSetControlMaximumArchive::set_maximum(double value) {
  set_has_maximum();
  maximum_ = value;
}

// required uint32 format_type = 3;
inline bool CommandSetControlMaximumArchive::has_format_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetControlMaximumArchive::set_has_format_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetControlMaximumArchive::clear_has_format_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetControlMaximumArchive::clear_format_type() {
  format_type_ = 0u;
  clear_has_format_type();
}
inline ::google::protobuf::uint32 CommandSetControlMaximumArchive::format_type() const {
  return format_type_;
}
inline void CommandSetControlMaximumArchive::set_format_type(::google::protobuf::uint32 value) {
  set_has_format_type();
  format_type_ = value;
}

// -------------------------------------------------------------------

// CommandSetControlIncrementArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetControlIncrementArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetControlIncrementArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetControlIncrementArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetControlIncrementArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetControlIncrementArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetControlIncrementArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetControlIncrementArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetControlIncrementArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required double increment = 2;
inline bool CommandSetControlIncrementArchive::has_increment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetControlIncrementArchive::set_has_increment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetControlIncrementArchive::clear_has_increment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetControlIncrementArchive::clear_increment() {
  increment_ = 0;
  clear_has_increment();
}
inline double CommandSetControlIncrementArchive::increment() const {
  return increment_;
}
inline void CommandSetControlIncrementArchive::set_increment(double value) {
  set_has_increment();
  increment_ = value;
}

// required uint32 format_type = 3;
inline bool CommandSetControlIncrementArchive::has_format_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetControlIncrementArchive::set_has_format_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetControlIncrementArchive::clear_has_format_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetControlIncrementArchive::clear_format_type() {
  format_type_ = 0u;
  clear_has_format_type();
}
inline ::google::protobuf::uint32 CommandSetControlIncrementArchive::format_type() const {
  return format_type_;
}
inline void CommandSetControlIncrementArchive::set_format_type(::google::protobuf::uint32 value) {
  set_has_format_type();
  format_type_ = value;
}

// -------------------------------------------------------------------

// CommandSetCurrencyCodeArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetCurrencyCodeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetCurrencyCodeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetCurrencyCodeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetCurrencyCodeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetCurrencyCodeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetCurrencyCodeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetCurrencyCodeArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetCurrencyCodeArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required string currency_code = 2;
inline bool CommandSetCurrencyCodeArchive::has_currency_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetCurrencyCodeArchive::set_has_currency_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetCurrencyCodeArchive::clear_has_currency_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetCurrencyCodeArchive::clear_currency_code() {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    currency_code_->clear();
  }
  clear_has_currency_code();
}
inline const ::std::string& CommandSetCurrencyCodeArchive::currency_code() const {
  return *currency_code_;
}
inline void CommandSetCurrencyCodeArchive::set_currency_code(const ::std::string& value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void CommandSetCurrencyCodeArchive::set_currency_code(const char* value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void CommandSetCurrencyCodeArchive::set_currency_code(const char* value, size_t size) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetCurrencyCodeArchive::mutable_currency_code() {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  return currency_code_;
}
inline ::std::string* CommandSetCurrencyCodeArchive::release_currency_code() {
  clear_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_code_;
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetCurrencyCodeArchive::set_allocated_currency_code(::std::string* currency_code) {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_code_;
  }
  if (currency_code) {
    set_has_currency_code();
    currency_code_ = currency_code;
  } else {
    clear_has_currency_code();
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandSetFractionAccuracyArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetFractionAccuracyArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFractionAccuracyArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFractionAccuracyArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFractionAccuracyArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetFractionAccuracyArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetFractionAccuracyArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetFractionAccuracyArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFractionAccuracyArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 fraction_accuracy = 2;
inline bool CommandSetFractionAccuracyArchive::has_fraction_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFractionAccuracyArchive::set_has_fraction_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFractionAccuracyArchive::clear_has_fraction_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFractionAccuracyArchive::clear_fraction_accuracy() {
  fraction_accuracy_ = 0u;
  clear_has_fraction_accuracy();
}
inline ::google::protobuf::uint32 CommandSetFractionAccuracyArchive::fraction_accuracy() const {
  return fraction_accuracy_;
}
inline void CommandSetFractionAccuracyArchive::set_fraction_accuracy(::google::protobuf::uint32 value) {
  set_has_fraction_accuracy();
  fraction_accuracy_ = value;
}

// -------------------------------------------------------------------

// CommandSetMultipleChoiceListFormatForEditedItemArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetMultipleChoiceListFormatForEditedItemArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleChoiceListFormatForEditedItemArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForEditedItemArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForEditedItemArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetMultipleChoiceListFormatForEditedItemArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForEditedItemArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForEditedItemArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleChoiceListFormatForEditedItemArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetMultipleChoiceListFormatForDeleteItemArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetMultipleChoiceListFormatForDeleteItemArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleChoiceListFormatForDeleteItemArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForDeleteItemArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForDeleteItemArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetMultipleChoiceListFormatForDeleteItemArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForDeleteItemArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForDeleteItemArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleChoiceListFormatForDeleteItemArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetMultipleChoiceListFormatForReorderItemArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetMultipleChoiceListFormatForReorderItemArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleChoiceListFormatForReorderItemArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForReorderItemArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForReorderItemArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetMultipleChoiceListFormatForReorderItemArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForReorderItemArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForReorderItemArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleChoiceListFormatForReorderItemArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetMultipleChoiceListFormatForInitialValueArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetMultipleChoiceListFormatForInitialValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetMultipleChoiceListFormatForInitialValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForInitialValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetMultipleChoiceListFormatForInitialValueArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetMultipleChoiceListFormatForInitialValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForInitialValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetMultipleChoiceListFormatForInitialValueArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetMultipleChoiceListFormatForInitialValueArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetNegativeNumberStyleArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetNegativeNumberStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetNegativeNumberStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetNegativeNumberStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetNegativeNumberStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetNegativeNumberStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetNegativeNumberStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetNegativeNumberStyleArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetNegativeNumberStyleArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 negative_number_style = 2;
inline bool CommandSetNegativeNumberStyleArchive::has_negative_number_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetNegativeNumberStyleArchive::set_has_negative_number_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetNegativeNumberStyleArchive::clear_has_negative_number_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetNegativeNumberStyleArchive::clear_negative_number_style() {
  negative_number_style_ = 0u;
  clear_has_negative_number_style();
}
inline ::google::protobuf::uint32 CommandSetNegativeNumberStyleArchive::negative_number_style() const {
  return negative_number_style_;
}
inline void CommandSetNegativeNumberStyleArchive::set_negative_number_style(::google::protobuf::uint32 value) {
  set_has_negative_number_style();
  negative_number_style_ = value;
}

// -------------------------------------------------------------------

// CommandSetExplicitFormatArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetExplicitFormatArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetExplicitFormatArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetExplicitFormatArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetExplicitFormatArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetExplicitFormatArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetExplicitFormatArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetExplicitFormatArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetExplicitFormatArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.SelectionArchive selection = 2;
inline bool CommandSetExplicitFormatArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetExplicitFormatArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetExplicitFormatArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetExplicitFormatArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandSetExplicitFormatArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandSetExplicitFormatArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandSetExplicitFormatArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandSetExplicitFormatArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TSK.FormatStructArchive cell_format = 3;
inline bool CommandSetExplicitFormatArchive::has_cell_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetExplicitFormatArchive::set_has_cell_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetExplicitFormatArchive::clear_has_cell_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetExplicitFormatArchive::clear_cell_format() {
  if (cell_format_ != NULL) cell_format_->::TSK::FormatStructArchive::Clear();
  clear_has_cell_format();
}
inline const ::TSK::FormatStructArchive& CommandSetExplicitFormatArchive::cell_format() const {
  return cell_format_ != NULL ? *cell_format_ : *default_instance_->cell_format_;
}
inline ::TSK::FormatStructArchive* CommandSetExplicitFormatArchive::mutable_cell_format() {
  set_has_cell_format();
  if (cell_format_ == NULL) cell_format_ = new ::TSK::FormatStructArchive;
  return cell_format_;
}
inline ::TSK::FormatStructArchive* CommandSetExplicitFormatArchive::release_cell_format() {
  clear_has_cell_format();
  ::TSK::FormatStructArchive* temp = cell_format_;
  cell_format_ = NULL;
  return temp;
}
inline void CommandSetExplicitFormatArchive::set_allocated_cell_format(::TSK::FormatStructArchive* cell_format) {
  delete cell_format_;
  cell_format_ = cell_format;
  if (cell_format) {
    set_has_cell_format();
  } else {
    clear_has_cell_format();
  }
}

// required .TST.CellMapArchive undo_cell_map = 4;
inline bool CommandSetExplicitFormatArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetExplicitFormatArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetExplicitFormatArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetExplicitFormatArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetExplicitFormatArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetExplicitFormatArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetExplicitFormatArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetExplicitFormatArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 5;
inline bool CommandSetExplicitFormatArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetExplicitFormatArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetExplicitFormatArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetExplicitFormatArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetExplicitFormatArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetExplicitFormatArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetExplicitFormatArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetExplicitFormatArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandSetNumberOfDecimalPlacesArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetNumberOfDecimalPlacesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetNumberOfDecimalPlacesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetNumberOfDecimalPlacesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetNumberOfDecimalPlacesArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetNumberOfDecimalPlacesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetNumberOfDecimalPlacesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetNumberOfDecimalPlacesArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetNumberOfDecimalPlacesArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 decimal_places = 2;
inline bool CommandSetNumberOfDecimalPlacesArchive::has_decimal_places() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetNumberOfDecimalPlacesArchive::set_has_decimal_places() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetNumberOfDecimalPlacesArchive::clear_has_decimal_places() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetNumberOfDecimalPlacesArchive::clear_decimal_places() {
  decimal_places_ = 0u;
  clear_has_decimal_places();
}
inline ::google::protobuf::uint32 CommandSetNumberOfDecimalPlacesArchive::decimal_places() const {
  return decimal_places_;
}
inline void CommandSetNumberOfDecimalPlacesArchive::set_decimal_places(::google::protobuf::uint32 value) {
  set_has_decimal_places();
  decimal_places_ = value;
}

// -------------------------------------------------------------------

// CommandSetDateTimeFormatArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetDateTimeFormatArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetDateTimeFormatArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetDateTimeFormatArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetDateTimeFormatArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetDateTimeFormatArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetDateTimeFormatArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetDateTimeFormatArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetDateTimeFormatArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetShowThousandsSeparatorArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetShowThousandsSeparatorArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetShowThousandsSeparatorArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetShowThousandsSeparatorArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetShowThousandsSeparatorArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetShowThousandsSeparatorArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetShowThousandsSeparatorArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetShowThousandsSeparatorArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetShowThousandsSeparatorArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool show_thousands_separator = 2;
inline bool CommandSetShowThousandsSeparatorArchive::has_show_thousands_separator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetShowThousandsSeparatorArchive::set_has_show_thousands_separator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetShowThousandsSeparatorArchive::clear_has_show_thousands_separator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetShowThousandsSeparatorArchive::clear_show_thousands_separator() {
  show_thousands_separator_ = false;
  clear_has_show_thousands_separator();
}
inline bool CommandSetShowThousandsSeparatorArchive::show_thousands_separator() const {
  return show_thousands_separator_;
}
inline void CommandSetShowThousandsSeparatorArchive::set_show_thousands_separator(bool value) {
  set_has_show_thousands_separator();
  show_thousands_separator_ = value;
}

// -------------------------------------------------------------------

// CommandSetUseAccountingStyleArchive

// required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
inline bool CommandSetUseAccountingStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetUseAccountingStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetUseAccountingStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetUseAccountingStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TST::CommandSetSingleNumberFormatParameterArchive::Clear();
  clear_has_super();
}
inline const ::TST::CommandSetSingleNumberFormatParameterArchive& CommandSetUseAccountingStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetUseAccountingStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive;
  return super_;
}
inline ::TST::CommandSetSingleNumberFormatParameterArchive* CommandSetUseAccountingStyleArchive::release_super() {
  clear_has_super();
  ::TST::CommandSetSingleNumberFormatParameterArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetUseAccountingStyleArchive::set_allocated_super(::TST::CommandSetSingleNumberFormatParameterArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool use_accounting_style = 2;
inline bool CommandSetUseAccountingStyleArchive::has_use_accounting_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetUseAccountingStyleArchive::set_has_use_accounting_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetUseAccountingStyleArchive::clear_has_use_accounting_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetUseAccountingStyleArchive::clear_use_accounting_style() {
  use_accounting_style_ = false;
  clear_has_use_accounting_style();
}
inline bool CommandSetUseAccountingStyleArchive::use_accounting_style() const {
  return use_accounting_style_;
}
inline void CommandSetUseAccountingStyleArchive::set_use_accounting_style(bool value) {
  set_has_use_accounting_style();
  use_accounting_style_ = value;
}

// -------------------------------------------------------------------

// CommandMoveRowsArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandMoveRowsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMoveRowsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMoveRowsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMoveRowsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandMoveRowsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandMoveRowsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandMoveRowsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMoveRowsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TST.SelectionArchive selection = 2;
inline bool CommandMoveRowsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMoveRowsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMoveRowsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMoveRowsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandMoveRowsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandMoveRowsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandMoveRowsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandMoveRowsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required uint32 start_row_index = 3;
inline bool CommandMoveRowsArchive::has_start_row_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandMoveRowsArchive::set_has_start_row_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandMoveRowsArchive::clear_has_start_row_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandMoveRowsArchive::clear_start_row_index() {
  start_row_index_ = 0u;
  clear_has_start_row_index();
}
inline ::google::protobuf::uint32 CommandMoveRowsArchive::start_row_index() const {
  return start_row_index_;
}
inline void CommandMoveRowsArchive::set_start_row_index(::google::protobuf::uint32 value) {
  set_has_start_row_index();
  start_row_index_ = value;
}

// required uint32 dest_row_index = 4;
inline bool CommandMoveRowsArchive::has_dest_row_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandMoveRowsArchive::set_has_dest_row_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandMoveRowsArchive::clear_has_dest_row_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandMoveRowsArchive::clear_dest_row_index() {
  dest_row_index_ = 0u;
  clear_has_dest_row_index();
}
inline ::google::protobuf::uint32 CommandMoveRowsArchive::dest_row_index() const {
  return dest_row_index_;
}
inline void CommandMoveRowsArchive::set_dest_row_index(::google::protobuf::uint32 value) {
  set_has_dest_row_index();
  dest_row_index_ = value;
}

// required uint32 number_of_rows = 5;
inline bool CommandMoveRowsArchive::has_number_of_rows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandMoveRowsArchive::set_has_number_of_rows() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandMoveRowsArchive::clear_has_number_of_rows() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandMoveRowsArchive::clear_number_of_rows() {
  number_of_rows_ = 0u;
  clear_has_number_of_rows();
}
inline ::google::protobuf::uint32 CommandMoveRowsArchive::number_of_rows() const {
  return number_of_rows_;
}
inline void CommandMoveRowsArchive::set_number_of_rows(::google::protobuf::uint32 value) {
  set_has_number_of_rows();
  number_of_rows_ = value;
}

// optional .TSP.Reference formula_rewrite_command = 7;
inline bool CommandMoveRowsArchive::has_formula_rewrite_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandMoveRowsArchive::set_has_formula_rewrite_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandMoveRowsArchive::clear_has_formula_rewrite_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandMoveRowsArchive::clear_formula_rewrite_command() {
  if (formula_rewrite_command_ != NULL) formula_rewrite_command_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command();
}
inline const ::TSP::Reference& CommandMoveRowsArchive::formula_rewrite_command() const {
  return formula_rewrite_command_ != NULL ? *formula_rewrite_command_ : *default_instance_->formula_rewrite_command_;
}
inline ::TSP::Reference* CommandMoveRowsArchive::mutable_formula_rewrite_command() {
  set_has_formula_rewrite_command();
  if (formula_rewrite_command_ == NULL) formula_rewrite_command_ = new ::TSP::Reference;
  return formula_rewrite_command_;
}
inline ::TSP::Reference* CommandMoveRowsArchive::release_formula_rewrite_command() {
  clear_has_formula_rewrite_command();
  ::TSP::Reference* temp = formula_rewrite_command_;
  formula_rewrite_command_ = NULL;
  return temp;
}
inline void CommandMoveRowsArchive::set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command) {
  delete formula_rewrite_command_;
  formula_rewrite_command_ = formula_rewrite_command;
  if (formula_rewrite_command) {
    set_has_formula_rewrite_command();
  } else {
    clear_has_formula_rewrite_command();
  }
}

// optional .TSP.Reference show_command = 8;
inline bool CommandMoveRowsArchive::has_show_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandMoveRowsArchive::set_has_show_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandMoveRowsArchive::clear_has_show_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandMoveRowsArchive::clear_show_command() {
  if (show_command_ != NULL) show_command_->::TSP::Reference::Clear();
  clear_has_show_command();
}
inline const ::TSP::Reference& CommandMoveRowsArchive::show_command() const {
  return show_command_ != NULL ? *show_command_ : *default_instance_->show_command_;
}
inline ::TSP::Reference* CommandMoveRowsArchive::mutable_show_command() {
  set_has_show_command();
  if (show_command_ == NULL) show_command_ = new ::TSP::Reference;
  return show_command_;
}
inline ::TSP::Reference* CommandMoveRowsArchive::release_show_command() {
  clear_has_show_command();
  ::TSP::Reference* temp = show_command_;
  show_command_ = NULL;
  return temp;
}
inline void CommandMoveRowsArchive::set_allocated_show_command(::TSP::Reference* show_command) {
  delete show_command_;
  show_command_ = show_command;
  if (show_command) {
    set_has_show_command();
  } else {
    clear_has_show_command();
  }
}

// optional .TSP.Reference unmerge_invalid_ranges_command = 9;
inline bool CommandMoveRowsArchive::has_unmerge_invalid_ranges_command() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandMoveRowsArchive::set_has_unmerge_invalid_ranges_command() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandMoveRowsArchive::clear_has_unmerge_invalid_ranges_command() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandMoveRowsArchive::clear_unmerge_invalid_ranges_command() {
  if (unmerge_invalid_ranges_command_ != NULL) unmerge_invalid_ranges_command_->::TSP::Reference::Clear();
  clear_has_unmerge_invalid_ranges_command();
}
inline const ::TSP::Reference& CommandMoveRowsArchive::unmerge_invalid_ranges_command() const {
  return unmerge_invalid_ranges_command_ != NULL ? *unmerge_invalid_ranges_command_ : *default_instance_->unmerge_invalid_ranges_command_;
}
inline ::TSP::Reference* CommandMoveRowsArchive::mutable_unmerge_invalid_ranges_command() {
  set_has_unmerge_invalid_ranges_command();
  if (unmerge_invalid_ranges_command_ == NULL) unmerge_invalid_ranges_command_ = new ::TSP::Reference;
  return unmerge_invalid_ranges_command_;
}
inline ::TSP::Reference* CommandMoveRowsArchive::release_unmerge_invalid_ranges_command() {
  clear_has_unmerge_invalid_ranges_command();
  ::TSP::Reference* temp = unmerge_invalid_ranges_command_;
  unmerge_invalid_ranges_command_ = NULL;
  return temp;
}
inline void CommandMoveRowsArchive::set_allocated_unmerge_invalid_ranges_command(::TSP::Reference* unmerge_invalid_ranges_command) {
  delete unmerge_invalid_ranges_command_;
  unmerge_invalid_ranges_command_ = unmerge_invalid_ranges_command;
  if (unmerge_invalid_ranges_command) {
    set_has_unmerge_invalid_ranges_command();
  } else {
    clear_has_unmerge_invalid_ranges_command();
  }
}

// -------------------------------------------------------------------

// CommandMoveColumnsArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandMoveColumnsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMoveColumnsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMoveColumnsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandMoveColumnsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandMoveColumnsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandMoveColumnsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMoveColumnsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TST.SelectionArchive selection = 2;
inline bool CommandMoveColumnsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMoveColumnsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMoveColumnsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandMoveColumnsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandMoveColumnsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandMoveColumnsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandMoveColumnsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required uint32 start_column_index = 3;
inline bool CommandMoveColumnsArchive::has_start_column_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_start_column_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandMoveColumnsArchive::clear_has_start_column_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandMoveColumnsArchive::clear_start_column_index() {
  start_column_index_ = 0u;
  clear_has_start_column_index();
}
inline ::google::protobuf::uint32 CommandMoveColumnsArchive::start_column_index() const {
  return start_column_index_;
}
inline void CommandMoveColumnsArchive::set_start_column_index(::google::protobuf::uint32 value) {
  set_has_start_column_index();
  start_column_index_ = value;
}

// required uint32 dest_column_index = 4;
inline bool CommandMoveColumnsArchive::has_dest_column_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_dest_column_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandMoveColumnsArchive::clear_has_dest_column_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandMoveColumnsArchive::clear_dest_column_index() {
  dest_column_index_ = 0u;
  clear_has_dest_column_index();
}
inline ::google::protobuf::uint32 CommandMoveColumnsArchive::dest_column_index() const {
  return dest_column_index_;
}
inline void CommandMoveColumnsArchive::set_dest_column_index(::google::protobuf::uint32 value) {
  set_has_dest_column_index();
  dest_column_index_ = value;
}

// required uint32 number_of_columns = 5;
inline bool CommandMoveColumnsArchive::has_number_of_columns() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_number_of_columns() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandMoveColumnsArchive::clear_has_number_of_columns() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandMoveColumnsArchive::clear_number_of_columns() {
  number_of_columns_ = 0u;
  clear_has_number_of_columns();
}
inline ::google::protobuf::uint32 CommandMoveColumnsArchive::number_of_columns() const {
  return number_of_columns_;
}
inline void CommandMoveColumnsArchive::set_number_of_columns(::google::protobuf::uint32 value) {
  set_has_number_of_columns();
  number_of_columns_ = value;
}

// optional .TSP.Reference formula_rewrite_command = 7;
inline bool CommandMoveColumnsArchive::has_formula_rewrite_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_formula_rewrite_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandMoveColumnsArchive::clear_has_formula_rewrite_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandMoveColumnsArchive::clear_formula_rewrite_command() {
  if (formula_rewrite_command_ != NULL) formula_rewrite_command_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command();
}
inline const ::TSP::Reference& CommandMoveColumnsArchive::formula_rewrite_command() const {
  return formula_rewrite_command_ != NULL ? *formula_rewrite_command_ : *default_instance_->formula_rewrite_command_;
}
inline ::TSP::Reference* CommandMoveColumnsArchive::mutable_formula_rewrite_command() {
  set_has_formula_rewrite_command();
  if (formula_rewrite_command_ == NULL) formula_rewrite_command_ = new ::TSP::Reference;
  return formula_rewrite_command_;
}
inline ::TSP::Reference* CommandMoveColumnsArchive::release_formula_rewrite_command() {
  clear_has_formula_rewrite_command();
  ::TSP::Reference* temp = formula_rewrite_command_;
  formula_rewrite_command_ = NULL;
  return temp;
}
inline void CommandMoveColumnsArchive::set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command) {
  delete formula_rewrite_command_;
  formula_rewrite_command_ = formula_rewrite_command;
  if (formula_rewrite_command) {
    set_has_formula_rewrite_command();
  } else {
    clear_has_formula_rewrite_command();
  }
}

// optional .TSP.Reference show_command = 8;
inline bool CommandMoveColumnsArchive::has_show_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandMoveColumnsArchive::set_has_show_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandMoveColumnsArchive::clear_has_show_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandMoveColumnsArchive::clear_show_command() {
  if (show_command_ != NULL) show_command_->::TSP::Reference::Clear();
  clear_has_show_command();
}
inline const ::TSP::Reference& CommandMoveColumnsArchive::show_command() const {
  return show_command_ != NULL ? *show_command_ : *default_instance_->show_command_;
}
inline ::TSP::Reference* CommandMoveColumnsArchive::mutable_show_command() {
  set_has_show_command();
  if (show_command_ == NULL) show_command_ = new ::TSP::Reference;
  return show_command_;
}
inline ::TSP::Reference* CommandMoveColumnsArchive::release_show_command() {
  clear_has_show_command();
  ::TSP::Reference* temp = show_command_;
  show_command_ = NULL;
  return temp;
}
inline void CommandMoveColumnsArchive::set_allocated_show_command(::TSP::Reference* show_command) {
  delete show_command_;
  show_command_ = show_command;
  if (show_command) {
    set_has_show_command();
  } else {
    clear_has_show_command();
  }
}

// -------------------------------------------------------------------

// CommandSortArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSortArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSortArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSortArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSortArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSortArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSortArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSortArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSortArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSK.ShuffleMappingArchive mapping = 5;
inline bool CommandSortArchive::has_mapping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSortArchive::set_has_mapping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSortArchive::clear_has_mapping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSortArchive::clear_mapping() {
  if (mapping_ != NULL) mapping_->::TSK::ShuffleMappingArchive::Clear();
  clear_has_mapping();
}
inline const ::TSK::ShuffleMappingArchive& CommandSortArchive::mapping() const {
  return mapping_ != NULL ? *mapping_ : *default_instance_->mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandSortArchive::mutable_mapping() {
  set_has_mapping();
  if (mapping_ == NULL) mapping_ = new ::TSK::ShuffleMappingArchive;
  return mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandSortArchive::release_mapping() {
  clear_has_mapping();
  ::TSK::ShuffleMappingArchive* temp = mapping_;
  mapping_ = NULL;
  return temp;
}
inline void CommandSortArchive::set_allocated_mapping(::TSK::ShuffleMappingArchive* mapping) {
  delete mapping_;
  mapping_ = mapping;
  if (mapping) {
    set_has_mapping();
  } else {
    clear_has_mapping();
  }
}

// optional .TSP.Reference formula_rewrite_command = 7;
inline bool CommandSortArchive::has_formula_rewrite_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSortArchive::set_has_formula_rewrite_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSortArchive::clear_has_formula_rewrite_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSortArchive::clear_formula_rewrite_command() {
  if (formula_rewrite_command_ != NULL) formula_rewrite_command_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command();
}
inline const ::TSP::Reference& CommandSortArchive::formula_rewrite_command() const {
  return formula_rewrite_command_ != NULL ? *formula_rewrite_command_ : *default_instance_->formula_rewrite_command_;
}
inline ::TSP::Reference* CommandSortArchive::mutable_formula_rewrite_command() {
  set_has_formula_rewrite_command();
  if (formula_rewrite_command_ == NULL) formula_rewrite_command_ = new ::TSP::Reference;
  return formula_rewrite_command_;
}
inline ::TSP::Reference* CommandSortArchive::release_formula_rewrite_command() {
  clear_has_formula_rewrite_command();
  ::TSP::Reference* temp = formula_rewrite_command_;
  formula_rewrite_command_ = NULL;
  return temp;
}
inline void CommandSortArchive::set_allocated_formula_rewrite_command(::TSP::Reference* formula_rewrite_command) {
  delete formula_rewrite_command_;
  formula_rewrite_command_ = formula_rewrite_command;
  if (formula_rewrite_command) {
    set_has_formula_rewrite_command();
  } else {
    clear_has_formula_rewrite_command();
  }
}

// -------------------------------------------------------------------

// CommandRewriteFormulasForSortArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFormulasForSortArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFormulasForSortArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFormulasForSortArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFormulasForSortArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFormulasForSortArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForSortArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForSortArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForSortArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.OwnerFormulaMapArchive formula_map = 2;
inline bool CommandRewriteFormulasForSortArchive::has_formula_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteFormulasForSortArchive::set_has_formula_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteFormulasForSortArchive::clear_has_formula_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteFormulasForSortArchive::clear_formula_map() {
  if (formula_map_ != NULL) formula_map_->::TSCE::OwnerFormulaMapArchive::Clear();
  clear_has_formula_map();
}
inline const ::TSCE::OwnerFormulaMapArchive& CommandRewriteFormulasForSortArchive::formula_map() const {
  return formula_map_ != NULL ? *formula_map_ : *default_instance_->formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForSortArchive::mutable_formula_map() {
  set_has_formula_map();
  if (formula_map_ == NULL) formula_map_ = new ::TSCE::OwnerFormulaMapArchive;
  return formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForSortArchive::release_formula_map() {
  clear_has_formula_map();
  ::TSCE::OwnerFormulaMapArchive* temp = formula_map_;
  formula_map_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForSortArchive::set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map) {
  delete formula_map_;
  formula_map_ = formula_map;
  if (formula_map) {
    set_has_formula_map();
  } else {
    clear_has_formula_map();
  }
}

// required .TSK.ShuffleMappingArchive sort_mapping = 3;
inline bool CommandRewriteFormulasForSortArchive::has_sort_mapping() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteFormulasForSortArchive::set_has_sort_mapping() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteFormulasForSortArchive::clear_has_sort_mapping() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteFormulasForSortArchive::clear_sort_mapping() {
  if (sort_mapping_ != NULL) sort_mapping_->::TSK::ShuffleMappingArchive::Clear();
  clear_has_sort_mapping();
}
inline const ::TSK::ShuffleMappingArchive& CommandRewriteFormulasForSortArchive::sort_mapping() const {
  return sort_mapping_ != NULL ? *sort_mapping_ : *default_instance_->sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteFormulasForSortArchive::mutable_sort_mapping() {
  set_has_sort_mapping();
  if (sort_mapping_ == NULL) sort_mapping_ = new ::TSK::ShuffleMappingArchive;
  return sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteFormulasForSortArchive::release_sort_mapping() {
  clear_has_sort_mapping();
  ::TSK::ShuffleMappingArchive* temp = sort_mapping_;
  sort_mapping_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForSortArchive::set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping) {
  delete sort_mapping_;
  sort_mapping_ = sort_mapping;
  if (sort_mapping) {
    set_has_sort_mapping();
  } else {
    clear_has_sort_mapping();
  }
}

// required .TSCE.CFUUIDArchive sorted_table_id = 4;
inline bool CommandRewriteFormulasForSortArchive::has_sorted_table_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteFormulasForSortArchive::set_has_sorted_table_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteFormulasForSortArchive::clear_has_sorted_table_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteFormulasForSortArchive::clear_sorted_table_id() {
  if (sorted_table_id_ != NULL) sorted_table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_sorted_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandRewriteFormulasForSortArchive::sorted_table_id() const {
  return sorted_table_id_ != NULL ? *sorted_table_id_ : *default_instance_->sorted_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteFormulasForSortArchive::mutable_sorted_table_id() {
  set_has_sorted_table_id();
  if (sorted_table_id_ == NULL) sorted_table_id_ = new ::TSCE::CFUUIDArchive;
  return sorted_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteFormulasForSortArchive::release_sorted_table_id() {
  clear_has_sorted_table_id();
  ::TSCE::CFUUIDArchive* temp = sorted_table_id_;
  sorted_table_id_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForSortArchive::set_allocated_sorted_table_id(::TSCE::CFUUIDArchive* sorted_table_id) {
  delete sorted_table_id_;
  sorted_table_id_ = sorted_table_id;
  if (sorted_table_id) {
    set_has_sorted_table_id();
  } else {
    clear_has_sorted_table_id();
  }
}

// required bool explode_ranges = 5;
inline bool CommandRewriteFormulasForSortArchive::has_explode_ranges() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRewriteFormulasForSortArchive::set_has_explode_ranges() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRewriteFormulasForSortArchive::clear_has_explode_ranges() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRewriteFormulasForSortArchive::clear_explode_ranges() {
  explode_ranges_ = false;
  clear_has_explode_ranges();
}
inline bool CommandRewriteFormulasForSortArchive::explode_ranges() const {
  return explode_ranges_;
}
inline void CommandRewriteFormulasForSortArchive::set_explode_ranges(bool value) {
  set_has_explode_ranges();
  explode_ranges_ = value;
}

// -------------------------------------------------------------------

// CommandRewriteFormulasForTectonicShiftArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFormulasForTectonicShiftArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFormulasForTectonicShiftArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForTectonicShiftArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForTectonicShiftArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.OwnerFormulaMapArchive formula_map = 2;
inline bool CommandRewriteFormulasForTectonicShiftArchive::has_formula_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::set_has_formula_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::clear_has_formula_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::clear_formula_map() {
  if (formula_map_ != NULL) formula_map_->::TSCE::OwnerFormulaMapArchive::Clear();
  clear_has_formula_map();
}
inline const ::TSCE::OwnerFormulaMapArchive& CommandRewriteFormulasForTectonicShiftArchive::formula_map() const {
  return formula_map_ != NULL ? *formula_map_ : *default_instance_->formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForTectonicShiftArchive::mutable_formula_map() {
  set_has_formula_map();
  if (formula_map_ == NULL) formula_map_ = new ::TSCE::OwnerFormulaMapArchive;
  return formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForTectonicShiftArchive::release_formula_map() {
  clear_has_formula_map();
  ::TSCE::OwnerFormulaMapArchive* temp = formula_map_;
  formula_map_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map) {
  delete formula_map_;
  formula_map_ = formula_map;
  if (formula_map) {
    set_has_formula_map();
  } else {
    clear_has_formula_map();
  }
}

// required .TSCE.TectonicShiftArchive tectonic_shift = 3;
inline bool CommandRewriteFormulasForTectonicShiftArchive::has_tectonic_shift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::set_has_tectonic_shift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::clear_has_tectonic_shift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::clear_tectonic_shift() {
  if (tectonic_shift_ != NULL) tectonic_shift_->::TSCE::TectonicShiftArchive::Clear();
  clear_has_tectonic_shift();
}
inline const ::TSCE::TectonicShiftArchive& CommandRewriteFormulasForTectonicShiftArchive::tectonic_shift() const {
  return tectonic_shift_ != NULL ? *tectonic_shift_ : *default_instance_->tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteFormulasForTectonicShiftArchive::mutable_tectonic_shift() {
  set_has_tectonic_shift();
  if (tectonic_shift_ == NULL) tectonic_shift_ = new ::TSCE::TectonicShiftArchive;
  return tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteFormulasForTectonicShiftArchive::release_tectonic_shift() {
  clear_has_tectonic_shift();
  ::TSCE::TectonicShiftArchive* temp = tectonic_shift_;
  tectonic_shift_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForTectonicShiftArchive::set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift) {
  delete tectonic_shift_;
  tectonic_shift_ = tectonic_shift;
  if (tectonic_shift) {
    set_has_tectonic_shift();
  } else {
    clear_has_tectonic_shift();
  }
}

// -------------------------------------------------------------------

// CommandRewriteFormulasForMoveArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFormulasForMoveArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFormulasForMoveArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFormulasForMoveArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForMoveArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForMoveArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForMoveArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.OwnerFormulaMapArchive formula_map = 2;
inline bool CommandRewriteFormulasForMoveArchive::has_formula_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteFormulasForMoveArchive::set_has_formula_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_has_formula_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_formula_map() {
  if (formula_map_ != NULL) formula_map_->::TSCE::OwnerFormulaMapArchive::Clear();
  clear_has_formula_map();
}
inline const ::TSCE::OwnerFormulaMapArchive& CommandRewriteFormulasForMoveArchive::formula_map() const {
  return formula_map_ != NULL ? *formula_map_ : *default_instance_->formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForMoveArchive::mutable_formula_map() {
  set_has_formula_map();
  if (formula_map_ == NULL) formula_map_ = new ::TSCE::OwnerFormulaMapArchive;
  return formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForMoveArchive::release_formula_map() {
  clear_has_formula_map();
  ::TSCE::OwnerFormulaMapArchive* temp = formula_map_;
  formula_map_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForMoveArchive::set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map) {
  delete formula_map_;
  formula_map_ = formula_map;
  if (formula_map) {
    set_has_formula_map();
  } else {
    clear_has_formula_map();
  }
}

// required .TSCE.RangeReferenceArchive from_reference = 6;
inline bool CommandRewriteFormulasForMoveArchive::has_from_reference() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteFormulasForMoveArchive::set_has_from_reference() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_has_from_reference() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_from_reference() {
  if (from_reference_ != NULL) from_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_from_reference();
}
inline const ::TSCE::RangeReferenceArchive& CommandRewriteFormulasForMoveArchive::from_reference() const {
  return from_reference_ != NULL ? *from_reference_ : *default_instance_->from_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteFormulasForMoveArchive::mutable_from_reference() {
  set_has_from_reference();
  if (from_reference_ == NULL) from_reference_ = new ::TSCE::RangeReferenceArchive;
  return from_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteFormulasForMoveArchive::release_from_reference() {
  clear_has_from_reference();
  ::TSCE::RangeReferenceArchive* temp = from_reference_;
  from_reference_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForMoveArchive::set_allocated_from_reference(::TSCE::RangeReferenceArchive* from_reference) {
  delete from_reference_;
  from_reference_ = from_reference;
  if (from_reference) {
    set_has_from_reference();
  } else {
    clear_has_from_reference();
  }
}

// required .TSCE.RangeReferenceArchive to_reference = 7;
inline bool CommandRewriteFormulasForMoveArchive::has_to_reference() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteFormulasForMoveArchive::set_has_to_reference() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_has_to_reference() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteFormulasForMoveArchive::clear_to_reference() {
  if (to_reference_ != NULL) to_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_to_reference();
}
inline const ::TSCE::RangeReferenceArchive& CommandRewriteFormulasForMoveArchive::to_reference() const {
  return to_reference_ != NULL ? *to_reference_ : *default_instance_->to_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteFormulasForMoveArchive::mutable_to_reference() {
  set_has_to_reference();
  if (to_reference_ == NULL) to_reference_ = new ::TSCE::RangeReferenceArchive;
  return to_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteFormulasForMoveArchive::release_to_reference() {
  clear_has_to_reference();
  ::TSCE::RangeReferenceArchive* temp = to_reference_;
  to_reference_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForMoveArchive::set_allocated_to_reference(::TSCE::RangeReferenceArchive* to_reference) {
  delete to_reference_;
  to_reference_ = to_reference;
  if (to_reference) {
    set_has_to_reference();
  } else {
    clear_has_to_reference();
  }
}

// -------------------------------------------------------------------

// CommandRewriteFormulasForCellMergeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFormulasForCellMergeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFormulasForCellMergeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForCellMergeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFormulasForCellMergeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.OwnerFormulaMapArchive formula_map = 2;
inline bool CommandRewriteFormulasForCellMergeArchive::has_formula_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_has_formula_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_has_formula_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_formula_map() {
  if (formula_map_ != NULL) formula_map_->::TSCE::OwnerFormulaMapArchive::Clear();
  clear_has_formula_map();
}
inline const ::TSCE::OwnerFormulaMapArchive& CommandRewriteFormulasForCellMergeArchive::formula_map() const {
  return formula_map_ != NULL ? *formula_map_ : *default_instance_->formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForCellMergeArchive::mutable_formula_map() {
  set_has_formula_map();
  if (formula_map_ == NULL) formula_map_ = new ::TSCE::OwnerFormulaMapArchive;
  return formula_map_;
}
inline ::TSCE::OwnerFormulaMapArchive* CommandRewriteFormulasForCellMergeArchive::release_formula_map() {
  clear_has_formula_map();
  ::TSCE::OwnerFormulaMapArchive* temp = formula_map_;
  formula_map_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_allocated_formula_map(::TSCE::OwnerFormulaMapArchive* formula_map) {
  delete formula_map_;
  formula_map_ = formula_map;
  if (formula_map) {
    set_has_formula_map();
  } else {
    clear_has_formula_map();
  }
}

// required .TSCE.RangeCoordinateArchive merged_range = 3;
inline bool CommandRewriteFormulasForCellMergeArchive::has_merged_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_has_merged_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_has_merged_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_merged_range() {
  if (merged_range_ != NULL) merged_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_merged_range();
}
inline const ::TSCE::RangeCoordinateArchive& CommandRewriteFormulasForCellMergeArchive::merged_range() const {
  return merged_range_ != NULL ? *merged_range_ : *default_instance_->merged_range_;
}
inline ::TSCE::RangeCoordinateArchive* CommandRewriteFormulasForCellMergeArchive::mutable_merged_range() {
  set_has_merged_range();
  if (merged_range_ == NULL) merged_range_ = new ::TSCE::RangeCoordinateArchive;
  return merged_range_;
}
inline ::TSCE::RangeCoordinateArchive* CommandRewriteFormulasForCellMergeArchive::release_merged_range() {
  clear_has_merged_range();
  ::TSCE::RangeCoordinateArchive* temp = merged_range_;
  merged_range_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_allocated_merged_range(::TSCE::RangeCoordinateArchive* merged_range) {
  delete merged_range_;
  merged_range_ = merged_range;
  if (merged_range) {
    set_has_merged_range();
  } else {
    clear_has_merged_range();
  }
}

// required .TSCE.CFUUIDArchive table_id = 4;
inline bool CommandRewriteFormulasForCellMergeArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteFormulasForCellMergeArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandRewriteFormulasForCellMergeArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteFormulasForCellMergeArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteFormulasForCellMergeArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void CommandRewriteFormulasForCellMergeArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// -------------------------------------------------------------------

// CommandRewriteFilterFormulasForTableResizeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFilterFormulasForTableResizeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFilterFormulasForTableResizeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFilterFormulasForTableResizeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFilterFormulasForTableResizeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFilterFormulasForTableResizeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFilterFormulasForTableResizeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFilterFormulasForTableResizeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForTableResizeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandRewriteFilterFormulasForTectonicShiftArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFilterFormulasForTectonicShiftArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFilterFormulasForTectonicShiftArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFilterFormulasForTectonicShiftArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFilterFormulasForTectonicShiftArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference filter_set = 2;
inline bool CommandRewriteFilterFormulasForTectonicShiftArchive::has_filter_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::set_has_filter_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_has_filter_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_filter_set() {
  if (filter_set_ != NULL) filter_set_->::TSP::Reference::Clear();
  clear_has_filter_set();
}
inline const ::TSP::Reference& CommandRewriteFilterFormulasForTectonicShiftArchive::filter_set() const {
  return filter_set_ != NULL ? *filter_set_ : *default_instance_->filter_set_;
}
inline ::TSP::Reference* CommandRewriteFilterFormulasForTectonicShiftArchive::mutable_filter_set() {
  set_has_filter_set();
  if (filter_set_ == NULL) filter_set_ = new ::TSP::Reference;
  return filter_set_;
}
inline ::TSP::Reference* CommandRewriteFilterFormulasForTectonicShiftArchive::release_filter_set() {
  clear_has_filter_set();
  ::TSP::Reference* temp = filter_set_;
  filter_set_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::set_allocated_filter_set(::TSP::Reference* filter_set) {
  delete filter_set_;
  filter_set_ = filter_set;
  if (filter_set) {
    set_has_filter_set();
  } else {
    clear_has_filter_set();
  }
}

// required .TSCE.TectonicShiftArchive tectonic_shift = 3;
inline bool CommandRewriteFilterFormulasForTectonicShiftArchive::has_tectonic_shift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::set_has_tectonic_shift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_has_tectonic_shift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_tectonic_shift() {
  if (tectonic_shift_ != NULL) tectonic_shift_->::TSCE::TectonicShiftArchive::Clear();
  clear_has_tectonic_shift();
}
inline const ::TSCE::TectonicShiftArchive& CommandRewriteFilterFormulasForTectonicShiftArchive::tectonic_shift() const {
  return tectonic_shift_ != NULL ? *tectonic_shift_ : *default_instance_->tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteFilterFormulasForTectonicShiftArchive::mutable_tectonic_shift() {
  set_has_tectonic_shift();
  if (tectonic_shift_ == NULL) tectonic_shift_ = new ::TSCE::TectonicShiftArchive;
  return tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteFilterFormulasForTectonicShiftArchive::release_tectonic_shift() {
  clear_has_tectonic_shift();
  ::TSCE::TectonicShiftArchive* temp = tectonic_shift_;
  tectonic_shift_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForTectonicShiftArchive::set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift) {
  delete tectonic_shift_;
  tectonic_shift_ = tectonic_shift;
  if (tectonic_shift) {
    set_has_tectonic_shift();
  } else {
    clear_has_tectonic_shift();
  }
}

// -------------------------------------------------------------------

// CommandRewriteFilterFormulasForSortArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteFilterFormulasForSortArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteFilterFormulasForSortArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFilterFormulasForSortArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteFilterFormulasForSortArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference filter_set = 2;
inline bool CommandRewriteFilterFormulasForSortArchive::has_filter_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_has_filter_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_has_filter_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_filter_set() {
  if (filter_set_ != NULL) filter_set_->::TSP::Reference::Clear();
  clear_has_filter_set();
}
inline const ::TSP::Reference& CommandRewriteFilterFormulasForSortArchive::filter_set() const {
  return filter_set_ != NULL ? *filter_set_ : *default_instance_->filter_set_;
}
inline ::TSP::Reference* CommandRewriteFilterFormulasForSortArchive::mutable_filter_set() {
  set_has_filter_set();
  if (filter_set_ == NULL) filter_set_ = new ::TSP::Reference;
  return filter_set_;
}
inline ::TSP::Reference* CommandRewriteFilterFormulasForSortArchive::release_filter_set() {
  clear_has_filter_set();
  ::TSP::Reference* temp = filter_set_;
  filter_set_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_allocated_filter_set(::TSP::Reference* filter_set) {
  delete filter_set_;
  filter_set_ = filter_set;
  if (filter_set) {
    set_has_filter_set();
  } else {
    clear_has_filter_set();
  }
}

// required .TSK.ShuffleMappingArchive sort_mapping = 3;
inline bool CommandRewriteFilterFormulasForSortArchive::has_sort_mapping() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_has_sort_mapping() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_has_sort_mapping() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_sort_mapping() {
  if (sort_mapping_ != NULL) sort_mapping_->::TSK::ShuffleMappingArchive::Clear();
  clear_has_sort_mapping();
}
inline const ::TSK::ShuffleMappingArchive& CommandRewriteFilterFormulasForSortArchive::sort_mapping() const {
  return sort_mapping_ != NULL ? *sort_mapping_ : *default_instance_->sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteFilterFormulasForSortArchive::mutable_sort_mapping() {
  set_has_sort_mapping();
  if (sort_mapping_ == NULL) sort_mapping_ = new ::TSK::ShuffleMappingArchive;
  return sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteFilterFormulasForSortArchive::release_sort_mapping() {
  clear_has_sort_mapping();
  ::TSK::ShuffleMappingArchive* temp = sort_mapping_;
  sort_mapping_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping) {
  delete sort_mapping_;
  sort_mapping_ = sort_mapping;
  if (sort_mapping) {
    set_has_sort_mapping();
  } else {
    clear_has_sort_mapping();
  }
}

// required .TSCE.CFUUIDArchive sorted_table_id = 4;
inline bool CommandRewriteFilterFormulasForSortArchive::has_sorted_table_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_has_sorted_table_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_has_sorted_table_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteFilterFormulasForSortArchive::clear_sorted_table_id() {
  if (sorted_table_id_ != NULL) sorted_table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_sorted_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandRewriteFilterFormulasForSortArchive::sorted_table_id() const {
  return sorted_table_id_ != NULL ? *sorted_table_id_ : *default_instance_->sorted_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteFilterFormulasForSortArchive::mutable_sorted_table_id() {
  set_has_sorted_table_id();
  if (sorted_table_id_ == NULL) sorted_table_id_ = new ::TSCE::CFUUIDArchive;
  return sorted_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteFilterFormulasForSortArchive::release_sorted_table_id() {
  clear_has_sorted_table_id();
  ::TSCE::CFUUIDArchive* temp = sorted_table_id_;
  sorted_table_id_ = NULL;
  return temp;
}
inline void CommandRewriteFilterFormulasForSortArchive::set_allocated_sorted_table_id(::TSCE::CFUUIDArchive* sorted_table_id) {
  delete sorted_table_id_;
  sorted_table_id_ = sorted_table_id;
  if (sorted_table_id) {
    set_has_sorted_table_id();
  } else {
    clear_has_sorted_table_id();
  }
}

// -------------------------------------------------------------------

// CommandRewriteConditionalStylesForTectonicShiftArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteConditionalStylesForTectonicShiftArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteConditionalStylesForTectonicShiftArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.TectonicShiftArchive tectonic_shift = 2;
inline bool CommandRewriteConditionalStylesForTectonicShiftArchive::has_tectonic_shift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_has_tectonic_shift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_has_tectonic_shift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_tectonic_shift() {
  if (tectonic_shift_ != NULL) tectonic_shift_->::TSCE::TectonicShiftArchive::Clear();
  clear_has_tectonic_shift();
}
inline const ::TSCE::TectonicShiftArchive& CommandRewriteConditionalStylesForTectonicShiftArchive::tectonic_shift() const {
  return tectonic_shift_ != NULL ? *tectonic_shift_ : *default_instance_->tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::mutable_tectonic_shift() {
  set_has_tectonic_shift();
  if (tectonic_shift_ == NULL) tectonic_shift_ = new ::TSCE::TectonicShiftArchive;
  return tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::release_tectonic_shift() {
  clear_has_tectonic_shift();
  ::TSCE::TectonicShiftArchive* temp = tectonic_shift_;
  tectonic_shift_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift) {
  delete tectonic_shift_;
  tectonic_shift_ = tectonic_shift;
  if (tectonic_shift) {
    set_has_tectonic_shift();
  } else {
    clear_has_tectonic_shift();
  }
}

// optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 3;
inline bool CommandRewriteConditionalStylesForTectonicShiftArchive::has_cells_to_rewrite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_has_cells_to_rewrite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_has_cells_to_rewrite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_cells_to_rewrite() {
  if (cells_to_rewrite_ != NULL) cells_to_rewrite_->::TSCE::CellCoordinateVectorArchive::Clear();
  clear_has_cells_to_rewrite();
}
inline const ::TSCE::CellCoordinateVectorArchive& CommandRewriteConditionalStylesForTectonicShiftArchive::cells_to_rewrite() const {
  return cells_to_rewrite_ != NULL ? *cells_to_rewrite_ : *default_instance_->cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::mutable_cells_to_rewrite() {
  set_has_cells_to_rewrite();
  if (cells_to_rewrite_ == NULL) cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive;
  return cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::release_cells_to_rewrite() {
  clear_has_cells_to_rewrite();
  ::TSCE::CellCoordinateVectorArchive* temp = cells_to_rewrite_;
  cells_to_rewrite_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite) {
  delete cells_to_rewrite_;
  cells_to_rewrite_ = cells_to_rewrite;
  if (cells_to_rewrite) {
    set_has_cells_to_rewrite();
  } else {
    clear_has_cells_to_rewrite();
  }
}

// optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 4;
inline bool CommandRewriteConditionalStylesForTectonicShiftArchive::has_conditional_style_sets() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_has_conditional_style_sets() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_has_conditional_style_sets() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_conditional_style_sets() {
  if (conditional_style_sets_ != NULL) conditional_style_sets_->::TSCE::CellCoordinateObjectMapArchive::Clear();
  clear_has_conditional_style_sets();
}
inline const ::TSCE::CellCoordinateObjectMapArchive& CommandRewriteConditionalStylesForTectonicShiftArchive::conditional_style_sets() const {
  return conditional_style_sets_ != NULL ? *conditional_style_sets_ : *default_instance_->conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::mutable_conditional_style_sets() {
  set_has_conditional_style_sets();
  if (conditional_style_sets_ == NULL) conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive;
  return conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForTectonicShiftArchive::release_conditional_style_sets() {
  clear_has_conditional_style_sets();
  ::TSCE::CellCoordinateObjectMapArchive* temp = conditional_style_sets_;
  conditional_style_sets_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForTectonicShiftArchive::set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets) {
  delete conditional_style_sets_;
  conditional_style_sets_ = conditional_style_sets;
  if (conditional_style_sets) {
    set_has_conditional_style_sets();
  } else {
    clear_has_conditional_style_sets();
  }
}

// -------------------------------------------------------------------

// CommandRewriteConditionalStylesForSortArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteConditionalStylesForSortArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteConditionalStylesForSortArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForSortArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForSortArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSK.ShuffleMappingArchive sort_mapping = 2;
inline bool CommandRewriteConditionalStylesForSortArchive::has_sort_mapping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_has_sort_mapping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_has_sort_mapping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_sort_mapping() {
  if (sort_mapping_ != NULL) sort_mapping_->::TSK::ShuffleMappingArchive::Clear();
  clear_has_sort_mapping();
}
inline const ::TSK::ShuffleMappingArchive& CommandRewriteConditionalStylesForSortArchive::sort_mapping() const {
  return sort_mapping_ != NULL ? *sort_mapping_ : *default_instance_->sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteConditionalStylesForSortArchive::mutable_sort_mapping() {
  set_has_sort_mapping();
  if (sort_mapping_ == NULL) sort_mapping_ = new ::TSK::ShuffleMappingArchive;
  return sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteConditionalStylesForSortArchive::release_sort_mapping() {
  clear_has_sort_mapping();
  ::TSK::ShuffleMappingArchive* temp = sort_mapping_;
  sort_mapping_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping) {
  delete sort_mapping_;
  sort_mapping_ = sort_mapping;
  if (sort_mapping) {
    set_has_sort_mapping();
  } else {
    clear_has_sort_mapping();
  }
}

// required .TSCE.CFUUIDArchive sorted_table_id = 3;
inline bool CommandRewriteConditionalStylesForSortArchive::has_sorted_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_has_sorted_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_has_sorted_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_sorted_table_id() {
  if (sorted_table_id_ != NULL) sorted_table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_sorted_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandRewriteConditionalStylesForSortArchive::sorted_table_id() const {
  return sorted_table_id_ != NULL ? *sorted_table_id_ : *default_instance_->sorted_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteConditionalStylesForSortArchive::mutable_sorted_table_id() {
  set_has_sorted_table_id();
  if (sorted_table_id_ == NULL) sorted_table_id_ = new ::TSCE::CFUUIDArchive;
  return sorted_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteConditionalStylesForSortArchive::release_sorted_table_id() {
  clear_has_sorted_table_id();
  ::TSCE::CFUUIDArchive* temp = sorted_table_id_;
  sorted_table_id_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_allocated_sorted_table_id(::TSCE::CFUUIDArchive* sorted_table_id) {
  delete sorted_table_id_;
  sorted_table_id_ = sorted_table_id;
  if (sorted_table_id) {
    set_has_sorted_table_id();
  } else {
    clear_has_sorted_table_id();
  }
}

// optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
inline bool CommandRewriteConditionalStylesForSortArchive::has_cells_to_rewrite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_has_cells_to_rewrite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_has_cells_to_rewrite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_cells_to_rewrite() {
  if (cells_to_rewrite_ != NULL) cells_to_rewrite_->::TSCE::CellCoordinateVectorArchive::Clear();
  clear_has_cells_to_rewrite();
}
inline const ::TSCE::CellCoordinateVectorArchive& CommandRewriteConditionalStylesForSortArchive::cells_to_rewrite() const {
  return cells_to_rewrite_ != NULL ? *cells_to_rewrite_ : *default_instance_->cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForSortArchive::mutable_cells_to_rewrite() {
  set_has_cells_to_rewrite();
  if (cells_to_rewrite_ == NULL) cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive;
  return cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForSortArchive::release_cells_to_rewrite() {
  clear_has_cells_to_rewrite();
  ::TSCE::CellCoordinateVectorArchive* temp = cells_to_rewrite_;
  cells_to_rewrite_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite) {
  delete cells_to_rewrite_;
  cells_to_rewrite_ = cells_to_rewrite;
  if (cells_to_rewrite) {
    set_has_cells_to_rewrite();
  } else {
    clear_has_cells_to_rewrite();
  }
}

// optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
inline bool CommandRewriteConditionalStylesForSortArchive::has_conditional_style_sets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_has_conditional_style_sets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_has_conditional_style_sets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRewriteConditionalStylesForSortArchive::clear_conditional_style_sets() {
  if (conditional_style_sets_ != NULL) conditional_style_sets_->::TSCE::CellCoordinateObjectMapArchive::Clear();
  clear_has_conditional_style_sets();
}
inline const ::TSCE::CellCoordinateObjectMapArchive& CommandRewriteConditionalStylesForSortArchive::conditional_style_sets() const {
  return conditional_style_sets_ != NULL ? *conditional_style_sets_ : *default_instance_->conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForSortArchive::mutable_conditional_style_sets() {
  set_has_conditional_style_sets();
  if (conditional_style_sets_ == NULL) conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive;
  return conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForSortArchive::release_conditional_style_sets() {
  clear_has_conditional_style_sets();
  ::TSCE::CellCoordinateObjectMapArchive* temp = conditional_style_sets_;
  conditional_style_sets_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForSortArchive::set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets) {
  delete conditional_style_sets_;
  conditional_style_sets_ = conditional_style_sets;
  if (conditional_style_sets) {
    set_has_conditional_style_sets();
  } else {
    clear_has_conditional_style_sets();
  }
}

// -------------------------------------------------------------------

// CommandRewriteConditionalStylesForRangeMoveArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteConditionalStylesForRangeMoveArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteConditionalStylesForRangeMoveArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForRangeMoveArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForRangeMoveArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSCE.RangeReferenceArchive from_range_reference = 7;
inline bool CommandRewriteConditionalStylesForRangeMoveArchive::has_from_range_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_has_from_range_reference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_has_from_range_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_from_range_reference() {
  if (from_range_reference_ != NULL) from_range_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_from_range_reference();
}
inline const ::TSCE::RangeReferenceArchive& CommandRewriteConditionalStylesForRangeMoveArchive::from_range_reference() const {
  return from_range_reference_ != NULL ? *from_range_reference_ : *default_instance_->from_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteConditionalStylesForRangeMoveArchive::mutable_from_range_reference() {
  set_has_from_range_reference();
  if (from_range_reference_ == NULL) from_range_reference_ = new ::TSCE::RangeReferenceArchive;
  return from_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteConditionalStylesForRangeMoveArchive::release_from_range_reference() {
  clear_has_from_range_reference();
  ::TSCE::RangeReferenceArchive* temp = from_range_reference_;
  from_range_reference_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_allocated_from_range_reference(::TSCE::RangeReferenceArchive* from_range_reference) {
  delete from_range_reference_;
  from_range_reference_ = from_range_reference;
  if (from_range_reference) {
    set_has_from_range_reference();
  } else {
    clear_has_from_range_reference();
  }
}

// optional .TSCE.RangeReferenceArchive to_range_reference = 8;
inline bool CommandRewriteConditionalStylesForRangeMoveArchive::has_to_range_reference() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_has_to_range_reference() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_has_to_range_reference() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_to_range_reference() {
  if (to_range_reference_ != NULL) to_range_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_to_range_reference();
}
inline const ::TSCE::RangeReferenceArchive& CommandRewriteConditionalStylesForRangeMoveArchive::to_range_reference() const {
  return to_range_reference_ != NULL ? *to_range_reference_ : *default_instance_->to_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteConditionalStylesForRangeMoveArchive::mutable_to_range_reference() {
  set_has_to_range_reference();
  if (to_range_reference_ == NULL) to_range_reference_ = new ::TSCE::RangeReferenceArchive;
  return to_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* CommandRewriteConditionalStylesForRangeMoveArchive::release_to_range_reference() {
  clear_has_to_range_reference();
  ::TSCE::RangeReferenceArchive* temp = to_range_reference_;
  to_range_reference_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_allocated_to_range_reference(::TSCE::RangeReferenceArchive* to_range_reference) {
  delete to_range_reference_;
  to_range_reference_ = to_range_reference;
  if (to_range_reference) {
    set_has_to_range_reference();
  } else {
    clear_has_to_range_reference();
  }
}

// optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 5;
inline bool CommandRewriteConditionalStylesForRangeMoveArchive::has_cells_to_rewrite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_has_cells_to_rewrite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_has_cells_to_rewrite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_cells_to_rewrite() {
  if (cells_to_rewrite_ != NULL) cells_to_rewrite_->::TSCE::CellCoordinateVectorArchive::Clear();
  clear_has_cells_to_rewrite();
}
inline const ::TSCE::CellCoordinateVectorArchive& CommandRewriteConditionalStylesForRangeMoveArchive::cells_to_rewrite() const {
  return cells_to_rewrite_ != NULL ? *cells_to_rewrite_ : *default_instance_->cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForRangeMoveArchive::mutable_cells_to_rewrite() {
  set_has_cells_to_rewrite();
  if (cells_to_rewrite_ == NULL) cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive;
  return cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForRangeMoveArchive::release_cells_to_rewrite() {
  clear_has_cells_to_rewrite();
  ::TSCE::CellCoordinateVectorArchive* temp = cells_to_rewrite_;
  cells_to_rewrite_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite) {
  delete cells_to_rewrite_;
  cells_to_rewrite_ = cells_to_rewrite;
  if (cells_to_rewrite) {
    set_has_cells_to_rewrite();
  } else {
    clear_has_cells_to_rewrite();
  }
}

// optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 6;
inline bool CommandRewriteConditionalStylesForRangeMoveArchive::has_conditional_style_sets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_has_conditional_style_sets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_has_conditional_style_sets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::clear_conditional_style_sets() {
  if (conditional_style_sets_ != NULL) conditional_style_sets_->::TSCE::CellCoordinateObjectMapArchive::Clear();
  clear_has_conditional_style_sets();
}
inline const ::TSCE::CellCoordinateObjectMapArchive& CommandRewriteConditionalStylesForRangeMoveArchive::conditional_style_sets() const {
  return conditional_style_sets_ != NULL ? *conditional_style_sets_ : *default_instance_->conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForRangeMoveArchive::mutable_conditional_style_sets() {
  set_has_conditional_style_sets();
  if (conditional_style_sets_ == NULL) conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive;
  return conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForRangeMoveArchive::release_conditional_style_sets() {
  clear_has_conditional_style_sets();
  ::TSCE::CellCoordinateObjectMapArchive* temp = conditional_style_sets_;
  conditional_style_sets_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForRangeMoveArchive::set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets) {
  delete conditional_style_sets_;
  conditional_style_sets_ = conditional_style_sets;
  if (conditional_style_sets) {
    set_has_conditional_style_sets();
  } else {
    clear_has_conditional_style_sets();
  }
}

// -------------------------------------------------------------------

// CommandRewriteConditionalStylesForCellMergeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteConditionalStylesForCellMergeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteConditionalStylesForCellMergeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForCellMergeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteConditionalStylesForCellMergeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.CFUUIDArchive merged_table_id = 2;
inline bool CommandRewriteConditionalStylesForCellMergeArchive::has_merged_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_has_merged_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_has_merged_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_merged_table_id() {
  if (merged_table_id_ != NULL) merged_table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_merged_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandRewriteConditionalStylesForCellMergeArchive::merged_table_id() const {
  return merged_table_id_ != NULL ? *merged_table_id_ : *default_instance_->merged_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteConditionalStylesForCellMergeArchive::mutable_merged_table_id() {
  set_has_merged_table_id();
  if (merged_table_id_ == NULL) merged_table_id_ = new ::TSCE::CFUUIDArchive;
  return merged_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandRewriteConditionalStylesForCellMergeArchive::release_merged_table_id() {
  clear_has_merged_table_id();
  ::TSCE::CFUUIDArchive* temp = merged_table_id_;
  merged_table_id_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_allocated_merged_table_id(::TSCE::CFUUIDArchive* merged_table_id) {
  delete merged_table_id_;
  merged_table_id_ = merged_table_id;
  if (merged_table_id) {
    set_has_merged_table_id();
  } else {
    clear_has_merged_table_id();
  }
}

// required .TSCE.RangeCoordinateArchive merged_range = 3;
inline bool CommandRewriteConditionalStylesForCellMergeArchive::has_merged_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_has_merged_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_has_merged_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_merged_range() {
  if (merged_range_ != NULL) merged_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_merged_range();
}
inline const ::TSCE::RangeCoordinateArchive& CommandRewriteConditionalStylesForCellMergeArchive::merged_range() const {
  return merged_range_ != NULL ? *merged_range_ : *default_instance_->merged_range_;
}
inline ::TSCE::RangeCoordinateArchive* CommandRewriteConditionalStylesForCellMergeArchive::mutable_merged_range() {
  set_has_merged_range();
  if (merged_range_ == NULL) merged_range_ = new ::TSCE::RangeCoordinateArchive;
  return merged_range_;
}
inline ::TSCE::RangeCoordinateArchive* CommandRewriteConditionalStylesForCellMergeArchive::release_merged_range() {
  clear_has_merged_range();
  ::TSCE::RangeCoordinateArchive* temp = merged_range_;
  merged_range_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_allocated_merged_range(::TSCE::RangeCoordinateArchive* merged_range) {
  delete merged_range_;
  merged_range_ = merged_range;
  if (merged_range) {
    set_has_merged_range();
  } else {
    clear_has_merged_range();
  }
}

// optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
inline bool CommandRewriteConditionalStylesForCellMergeArchive::has_cells_to_rewrite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_has_cells_to_rewrite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_has_cells_to_rewrite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_cells_to_rewrite() {
  if (cells_to_rewrite_ != NULL) cells_to_rewrite_->::TSCE::CellCoordinateVectorArchive::Clear();
  clear_has_cells_to_rewrite();
}
inline const ::TSCE::CellCoordinateVectorArchive& CommandRewriteConditionalStylesForCellMergeArchive::cells_to_rewrite() const {
  return cells_to_rewrite_ != NULL ? *cells_to_rewrite_ : *default_instance_->cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForCellMergeArchive::mutable_cells_to_rewrite() {
  set_has_cells_to_rewrite();
  if (cells_to_rewrite_ == NULL) cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive;
  return cells_to_rewrite_;
}
inline ::TSCE::CellCoordinateVectorArchive* CommandRewriteConditionalStylesForCellMergeArchive::release_cells_to_rewrite() {
  clear_has_cells_to_rewrite();
  ::TSCE::CellCoordinateVectorArchive* temp = cells_to_rewrite_;
  cells_to_rewrite_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_allocated_cells_to_rewrite(::TSCE::CellCoordinateVectorArchive* cells_to_rewrite) {
  delete cells_to_rewrite_;
  cells_to_rewrite_ = cells_to_rewrite;
  if (cells_to_rewrite) {
    set_has_cells_to_rewrite();
  } else {
    clear_has_cells_to_rewrite();
  }
}

// optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
inline bool CommandRewriteConditionalStylesForCellMergeArchive::has_conditional_style_sets() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_has_conditional_style_sets() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_has_conditional_style_sets() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::clear_conditional_style_sets() {
  if (conditional_style_sets_ != NULL) conditional_style_sets_->::TSCE::CellCoordinateObjectMapArchive::Clear();
  clear_has_conditional_style_sets();
}
inline const ::TSCE::CellCoordinateObjectMapArchive& CommandRewriteConditionalStylesForCellMergeArchive::conditional_style_sets() const {
  return conditional_style_sets_ != NULL ? *conditional_style_sets_ : *default_instance_->conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForCellMergeArchive::mutable_conditional_style_sets() {
  set_has_conditional_style_sets();
  if (conditional_style_sets_ == NULL) conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive;
  return conditional_style_sets_;
}
inline ::TSCE::CellCoordinateObjectMapArchive* CommandRewriteConditionalStylesForCellMergeArchive::release_conditional_style_sets() {
  clear_has_conditional_style_sets();
  ::TSCE::CellCoordinateObjectMapArchive* temp = conditional_style_sets_;
  conditional_style_sets_ = NULL;
  return temp;
}
inline void CommandRewriteConditionalStylesForCellMergeArchive::set_allocated_conditional_style_sets(::TSCE::CellCoordinateObjectMapArchive* conditional_style_sets) {
  delete conditional_style_sets_;
  conditional_style_sets_ = conditional_style_sets;
  if (conditional_style_sets) {
    set_has_conditional_style_sets();
  } else {
    clear_has_conditional_style_sets();
  }
}

// -------------------------------------------------------------------

// CommandMergeUnmergeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandMergeUnmergeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMergeUnmergeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMergeUnmergeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandMergeUnmergeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandMergeUnmergeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandMergeUnmergeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMergeUnmergeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.MergeActionArchive merge_action = 2;
inline bool CommandMergeUnmergeArchive::has_merge_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_merge_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMergeUnmergeArchive::clear_has_merge_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMergeUnmergeArchive::clear_merge_action() {
  merge_action_ = 0;
  clear_has_merge_action();
}
inline ::TST::MergeActionArchive CommandMergeUnmergeArchive::merge_action() const {
  return static_cast< ::TST::MergeActionArchive >(merge_action_);
}
inline void CommandMergeUnmergeArchive::set_merge_action(::TST::MergeActionArchive value) {
  assert(::TST::MergeActionArchive_IsValid(value));
  set_has_merge_action();
  merge_action_ = value;
}

// required .TST.SelectionArchive selection = 3;
inline bool CommandMergeUnmergeArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandMergeUnmergeArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandMergeUnmergeArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandMergeUnmergeArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandMergeUnmergeArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandMergeUnmergeArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandMergeUnmergeArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_cell_map = 4;
inline bool CommandMergeUnmergeArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandMergeUnmergeArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandMergeUnmergeArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandMergeUnmergeArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMergeUnmergeArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMergeUnmergeArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandMergeUnmergeArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 5;
inline bool CommandMergeUnmergeArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandMergeUnmergeArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandMergeUnmergeArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandMergeUnmergeArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMergeUnmergeArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMergeUnmergeArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandMergeUnmergeArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional .TSP.Reference old_merge_ranges = 8;
inline bool CommandMergeUnmergeArchive::has_old_merge_ranges() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_old_merge_ranges() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandMergeUnmergeArchive::clear_has_old_merge_ranges() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandMergeUnmergeArchive::clear_old_merge_ranges() {
  if (old_merge_ranges_ != NULL) old_merge_ranges_->::TSP::Reference::Clear();
  clear_has_old_merge_ranges();
}
inline const ::TSP::Reference& CommandMergeUnmergeArchive::old_merge_ranges() const {
  return old_merge_ranges_ != NULL ? *old_merge_ranges_ : *default_instance_->old_merge_ranges_;
}
inline ::TSP::Reference* CommandMergeUnmergeArchive::mutable_old_merge_ranges() {
  set_has_old_merge_ranges();
  if (old_merge_ranges_ == NULL) old_merge_ranges_ = new ::TSP::Reference;
  return old_merge_ranges_;
}
inline ::TSP::Reference* CommandMergeUnmergeArchive::release_old_merge_ranges() {
  clear_has_old_merge_ranges();
  ::TSP::Reference* temp = old_merge_ranges_;
  old_merge_ranges_ = NULL;
  return temp;
}
inline void CommandMergeUnmergeArchive::set_allocated_old_merge_ranges(::TSP::Reference* old_merge_ranges) {
  delete old_merge_ranges_;
  old_merge_ranges_ = old_merge_ranges;
  if (old_merge_ranges) {
    set_has_old_merge_ranges();
  } else {
    clear_has_old_merge_ranges();
  }
}

// optional .TSP.Reference undo_formula_rewrite_command = 9;
inline bool CommandMergeUnmergeArchive::has_undo_formula_rewrite_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandMergeUnmergeArchive::set_has_undo_formula_rewrite_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandMergeUnmergeArchive::clear_has_undo_formula_rewrite_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandMergeUnmergeArchive::clear_undo_formula_rewrite_command() {
  if (undo_formula_rewrite_command_ != NULL) undo_formula_rewrite_command_->::TSP::Reference::Clear();
  clear_has_undo_formula_rewrite_command();
}
inline const ::TSP::Reference& CommandMergeUnmergeArchive::undo_formula_rewrite_command() const {
  return undo_formula_rewrite_command_ != NULL ? *undo_formula_rewrite_command_ : *default_instance_->undo_formula_rewrite_command_;
}
inline ::TSP::Reference* CommandMergeUnmergeArchive::mutable_undo_formula_rewrite_command() {
  set_has_undo_formula_rewrite_command();
  if (undo_formula_rewrite_command_ == NULL) undo_formula_rewrite_command_ = new ::TSP::Reference;
  return undo_formula_rewrite_command_;
}
inline ::TSP::Reference* CommandMergeUnmergeArchive::release_undo_formula_rewrite_command() {
  clear_has_undo_formula_rewrite_command();
  ::TSP::Reference* temp = undo_formula_rewrite_command_;
  undo_formula_rewrite_command_ = NULL;
  return temp;
}
inline void CommandMergeUnmergeArchive::set_allocated_undo_formula_rewrite_command(::TSP::Reference* undo_formula_rewrite_command) {
  delete undo_formula_rewrite_command_;
  undo_formula_rewrite_command_ = undo_formula_rewrite_command;
  if (undo_formula_rewrite_command) {
    set_has_undo_formula_rewrite_command();
  } else {
    clear_has_undo_formula_rewrite_command();
  }
}

// -------------------------------------------------------------------

// CommandHideShowArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandHideShowArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandHideShowArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandHideShowArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandHideShowArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandHideShowArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandHideShowArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandHideShowArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandHideShowArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CommandDirectionArchive direction = 2;
inline bool CommandHideShowArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandHideShowArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandHideShowArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandHideShowArchive::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::TST::CommandDirectionArchive CommandHideShowArchive::direction() const {
  return static_cast< ::TST::CommandDirectionArchive >(direction_);
}
inline void CommandHideShowArchive::set_direction(::TST::CommandDirectionArchive value) {
  assert(::TST::CommandDirectionArchive_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required .TST.HideShowActionArchive hide_show_action = 3;
inline bool CommandHideShowArchive::has_hide_show_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandHideShowArchive::set_has_hide_show_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandHideShowArchive::clear_has_hide_show_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandHideShowArchive::clear_hide_show_action() {
  hide_show_action_ = 0;
  clear_has_hide_show_action();
}
inline ::TST::HideShowActionArchive CommandHideShowArchive::hide_show_action() const {
  return static_cast< ::TST::HideShowActionArchive >(hide_show_action_);
}
inline void CommandHideShowArchive::set_hide_show_action(::TST::HideShowActionArchive value) {
  assert(::TST::HideShowActionArchive_IsValid(value));
  set_has_hide_show_action();
  hide_show_action_ = value;
}

// required uint32 hiding_action = 4;
inline bool CommandHideShowArchive::has_hiding_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandHideShowArchive::set_has_hiding_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandHideShowArchive::clear_has_hiding_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandHideShowArchive::clear_hiding_action() {
  hiding_action_ = 0u;
  clear_has_hiding_action();
}
inline ::google::protobuf::uint32 CommandHideShowArchive::hiding_action() const {
  return hiding_action_;
}
inline void CommandHideShowArchive::set_hiding_action(::google::protobuf::uint32 value) {
  set_has_hiding_action();
  hiding_action_ = value;
}

// required .TSP.IndexSet elements_affected = 5;
inline bool CommandHideShowArchive::has_elements_affected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandHideShowArchive::set_has_elements_affected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandHideShowArchive::clear_has_elements_affected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandHideShowArchive::clear_elements_affected() {
  if (elements_affected_ != NULL) elements_affected_->::TSP::IndexSet::Clear();
  clear_has_elements_affected();
}
inline const ::TSP::IndexSet& CommandHideShowArchive::elements_affected() const {
  return elements_affected_ != NULL ? *elements_affected_ : *default_instance_->elements_affected_;
}
inline ::TSP::IndexSet* CommandHideShowArchive::mutable_elements_affected() {
  set_has_elements_affected();
  if (elements_affected_ == NULL) elements_affected_ = new ::TSP::IndexSet;
  return elements_affected_;
}
inline ::TSP::IndexSet* CommandHideShowArchive::release_elements_affected() {
  clear_has_elements_affected();
  ::TSP::IndexSet* temp = elements_affected_;
  elements_affected_ = NULL;
  return temp;
}
inline void CommandHideShowArchive::set_allocated_elements_affected(::TSP::IndexSet* elements_affected) {
  delete elements_affected_;
  elements_affected_ = elements_affected;
  if (elements_affected) {
    set_has_elements_affected();
  } else {
    clear_has_elements_affected();
  }
}

// repeated uint32 old_hiding_states = 7;
inline int CommandHideShowArchive::old_hiding_states_size() const {
  return old_hiding_states_.size();
}
inline void CommandHideShowArchive::clear_old_hiding_states() {
  old_hiding_states_.Clear();
}
inline ::google::protobuf::uint32 CommandHideShowArchive::old_hiding_states(int index) const {
  return old_hiding_states_.Get(index);
}
inline void CommandHideShowArchive::set_old_hiding_states(int index, ::google::protobuf::uint32 value) {
  old_hiding_states_.Set(index, value);
}
inline void CommandHideShowArchive::add_old_hiding_states(::google::protobuf::uint32 value) {
  old_hiding_states_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandHideShowArchive::old_hiding_states() const {
  return old_hiding_states_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandHideShowArchive::mutable_old_hiding_states() {
  return &old_hiding_states_;
}

// -------------------------------------------------------------------

// TableInfoGeometryCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool TableInfoGeometryCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableInfoGeometryCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableInfoGeometryCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& TableInfoGeometryCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* TableInfoGeometryCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* TableInfoGeometryCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TableInfoGeometryCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Size scale_factor = 2;
inline bool TableInfoGeometryCommandArchive::has_scale_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_scale_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableInfoGeometryCommandArchive::clear_has_scale_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableInfoGeometryCommandArchive::clear_scale_factor() {
  if (scale_factor_ != NULL) scale_factor_->::TSP::Size::Clear();
  clear_has_scale_factor();
}
inline const ::TSP::Size& TableInfoGeometryCommandArchive::scale_factor() const {
  return scale_factor_ != NULL ? *scale_factor_ : *default_instance_->scale_factor_;
}
inline ::TSP::Size* TableInfoGeometryCommandArchive::mutable_scale_factor() {
  set_has_scale_factor();
  if (scale_factor_ == NULL) scale_factor_ = new ::TSP::Size;
  return scale_factor_;
}
inline ::TSP::Size* TableInfoGeometryCommandArchive::release_scale_factor() {
  clear_has_scale_factor();
  ::TSP::Size* temp = scale_factor_;
  scale_factor_ = NULL;
  return temp;
}
inline void TableInfoGeometryCommandArchive::set_allocated_scale_factor(::TSP::Size* scale_factor) {
  delete scale_factor_;
  scale_factor_ = scale_factor;
  if (scale_factor) {
    set_has_scale_factor();
  } else {
    clear_has_scale_factor();
  }
}

// optional .TSP.Reference table_info = 3;
inline bool TableInfoGeometryCommandArchive::has_table_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_table_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableInfoGeometryCommandArchive::clear_has_table_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableInfoGeometryCommandArchive::clear_table_info() {
  if (table_info_ != NULL) table_info_->::TSP::Reference::Clear();
  clear_has_table_info();
}
inline const ::TSP::Reference& TableInfoGeometryCommandArchive::table_info() const {
  return table_info_ != NULL ? *table_info_ : *default_instance_->table_info_;
}
inline ::TSP::Reference* TableInfoGeometryCommandArchive::mutable_table_info() {
  set_has_table_info();
  if (table_info_ == NULL) table_info_ = new ::TSP::Reference;
  return table_info_;
}
inline ::TSP::Reference* TableInfoGeometryCommandArchive::release_table_info() {
  clear_has_table_info();
  ::TSP::Reference* temp = table_info_;
  table_info_ = NULL;
  return temp;
}
inline void TableInfoGeometryCommandArchive::set_allocated_table_info(::TSP::Reference* table_info) {
  delete table_info_;
  table_info_ = table_info;
  if (table_info) {
    set_has_table_info();
  } else {
    clear_has_table_info();
  }
}

// optional .TSD.GeometryArchive new_geometry = 4;
inline bool TableInfoGeometryCommandArchive::has_new_geometry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_new_geometry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableInfoGeometryCommandArchive::clear_has_new_geometry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableInfoGeometryCommandArchive::clear_new_geometry() {
  if (new_geometry_ != NULL) new_geometry_->::TSD::GeometryArchive::Clear();
  clear_has_new_geometry();
}
inline const ::TSD::GeometryArchive& TableInfoGeometryCommandArchive::new_geometry() const {
  return new_geometry_ != NULL ? *new_geometry_ : *default_instance_->new_geometry_;
}
inline ::TSD::GeometryArchive* TableInfoGeometryCommandArchive::mutable_new_geometry() {
  set_has_new_geometry();
  if (new_geometry_ == NULL) new_geometry_ = new ::TSD::GeometryArchive;
  return new_geometry_;
}
inline ::TSD::GeometryArchive* TableInfoGeometryCommandArchive::release_new_geometry() {
  clear_has_new_geometry();
  ::TSD::GeometryArchive* temp = new_geometry_;
  new_geometry_ = NULL;
  return temp;
}
inline void TableInfoGeometryCommandArchive::set_allocated_new_geometry(::TSD::GeometryArchive* new_geometry) {
  delete new_geometry_;
  new_geometry_ = new_geometry;
  if (new_geometry) {
    set_has_new_geometry();
  } else {
    clear_has_new_geometry();
  }
}

// optional .TSD.GeometryArchive old_geometry = 5;
inline bool TableInfoGeometryCommandArchive::has_old_geometry() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_old_geometry() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableInfoGeometryCommandArchive::clear_has_old_geometry() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableInfoGeometryCommandArchive::clear_old_geometry() {
  if (old_geometry_ != NULL) old_geometry_->::TSD::GeometryArchive::Clear();
  clear_has_old_geometry();
}
inline const ::TSD::GeometryArchive& TableInfoGeometryCommandArchive::old_geometry() const {
  return old_geometry_ != NULL ? *old_geometry_ : *default_instance_->old_geometry_;
}
inline ::TSD::GeometryArchive* TableInfoGeometryCommandArchive::mutable_old_geometry() {
  set_has_old_geometry();
  if (old_geometry_ == NULL) old_geometry_ = new ::TSD::GeometryArchive;
  return old_geometry_;
}
inline ::TSD::GeometryArchive* TableInfoGeometryCommandArchive::release_old_geometry() {
  clear_has_old_geometry();
  ::TSD::GeometryArchive* temp = old_geometry_;
  old_geometry_ = NULL;
  return temp;
}
inline void TableInfoGeometryCommandArchive::set_allocated_old_geometry(::TSD::GeometryArchive* old_geometry) {
  delete old_geometry_;
  old_geometry_ = old_geometry;
  if (old_geometry) {
    set_has_old_geometry();
  } else {
    clear_has_old_geometry();
  }
}

// optional bool turn_off_auto_resize = 6;
inline bool TableInfoGeometryCommandArchive::has_turn_off_auto_resize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_turn_off_auto_resize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableInfoGeometryCommandArchive::clear_has_turn_off_auto_resize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableInfoGeometryCommandArchive::clear_turn_off_auto_resize() {
  turn_off_auto_resize_ = false;
  clear_has_turn_off_auto_resize();
}
inline bool TableInfoGeometryCommandArchive::turn_off_auto_resize() const {
  return turn_off_auto_resize_;
}
inline void TableInfoGeometryCommandArchive::set_turn_off_auto_resize(bool value) {
  set_has_turn_off_auto_resize();
  turn_off_auto_resize_ = value;
}

// optional bool should_clear_object_placeholder_flag = 7;
inline bool TableInfoGeometryCommandArchive::has_should_clear_object_placeholder_flag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_should_clear_object_placeholder_flag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TableInfoGeometryCommandArchive::clear_has_should_clear_object_placeholder_flag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TableInfoGeometryCommandArchive::clear_should_clear_object_placeholder_flag() {
  should_clear_object_placeholder_flag_ = false;
  clear_has_should_clear_object_placeholder_flag();
}
inline bool TableInfoGeometryCommandArchive::should_clear_object_placeholder_flag() const {
  return should_clear_object_placeholder_flag_;
}
inline void TableInfoGeometryCommandArchive::set_should_clear_object_placeholder_flag(bool value) {
  set_has_should_clear_object_placeholder_flag();
  should_clear_object_placeholder_flag_ = value;
}

// optional bool did_match_object_placeholder_geometry = 8;
inline bool TableInfoGeometryCommandArchive::has_did_match_object_placeholder_geometry() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TableInfoGeometryCommandArchive::set_has_did_match_object_placeholder_geometry() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TableInfoGeometryCommandArchive::clear_has_did_match_object_placeholder_geometry() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TableInfoGeometryCommandArchive::clear_did_match_object_placeholder_geometry() {
  did_match_object_placeholder_geometry_ = false;
  clear_has_did_match_object_placeholder_geometry();
}
inline bool TableInfoGeometryCommandArchive::did_match_object_placeholder_geometry() const {
  return did_match_object_placeholder_geometry_;
}
inline void TableInfoGeometryCommandArchive::set_did_match_object_placeholder_geometry(bool value) {
  set_has_did_match_object_placeholder_geometry();
  did_match_object_placeholder_geometry_ = value;
}

// -------------------------------------------------------------------

// FormulaEditingCommandGroupArchive

// required .TSK.ProgressiveCommandGroupArchive super = 1;
inline bool FormulaEditingCommandGroupArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaEditingCommandGroupArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::ProgressiveCommandGroupArchive::Clear();
  clear_has_super();
}
inline const ::TSK::ProgressiveCommandGroupArchive& FormulaEditingCommandGroupArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::ProgressiveCommandGroupArchive* FormulaEditingCommandGroupArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::ProgressiveCommandGroupArchive;
  return super_;
}
inline ::TSK::ProgressiveCommandGroupArchive* FormulaEditingCommandGroupArchive::release_super() {
  clear_has_super();
  ::TSK::ProgressiveCommandGroupArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FormulaEditingCommandGroupArchive::set_allocated_super(::TSK::ProgressiveCommandGroupArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool undoSelectionValid = 2;
inline bool FormulaEditingCommandGroupArchive::has_undoselectionvalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_undoselectionvalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_undoselectionvalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaEditingCommandGroupArchive::clear_undoselectionvalid() {
  undoselectionvalid_ = false;
  clear_has_undoselectionvalid();
}
inline bool FormulaEditingCommandGroupArchive::undoselectionvalid() const {
  return undoselectionvalid_;
}
inline void FormulaEditingCommandGroupArchive::set_undoselectionvalid(bool value) {
  set_has_undoselectionvalid();
  undoselectionvalid_ = value;
}

// required uint32 undoSelectionStart = 3;
inline bool FormulaEditingCommandGroupArchive::has_undoselectionstart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_undoselectionstart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_undoselectionstart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormulaEditingCommandGroupArchive::clear_undoselectionstart() {
  undoselectionstart_ = 0u;
  clear_has_undoselectionstart();
}
inline ::google::protobuf::uint32 FormulaEditingCommandGroupArchive::undoselectionstart() const {
  return undoselectionstart_;
}
inline void FormulaEditingCommandGroupArchive::set_undoselectionstart(::google::protobuf::uint32 value) {
  set_has_undoselectionstart();
  undoselectionstart_ = value;
}

// required uint32 undoSelectionLength = 4;
inline bool FormulaEditingCommandGroupArchive::has_undoselectionlength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_undoselectionlength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_undoselectionlength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormulaEditingCommandGroupArchive::clear_undoselectionlength() {
  undoselectionlength_ = 0u;
  clear_has_undoselectionlength();
}
inline ::google::protobuf::uint32 FormulaEditingCommandGroupArchive::undoselectionlength() const {
  return undoselectionlength_;
}
inline void FormulaEditingCommandGroupArchive::set_undoselectionlength(::google::protobuf::uint32 value) {
  set_has_undoselectionlength();
  undoselectionlength_ = value;
}

// required uint32 undoActiveToken = 5;
inline bool FormulaEditingCommandGroupArchive::has_undoactivetoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_undoactivetoken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_undoactivetoken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormulaEditingCommandGroupArchive::clear_undoactivetoken() {
  undoactivetoken_ = 0u;
  clear_has_undoactivetoken();
}
inline ::google::protobuf::uint32 FormulaEditingCommandGroupArchive::undoactivetoken() const {
  return undoactivetoken_;
}
inline void FormulaEditingCommandGroupArchive::set_undoactivetoken(::google::protobuf::uint32 value) {
  set_has_undoactivetoken();
  undoactivetoken_ = value;
}

// required bool redoSelectionValid = 6;
inline bool FormulaEditingCommandGroupArchive::has_redoselectionvalid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_redoselectionvalid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_redoselectionvalid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormulaEditingCommandGroupArchive::clear_redoselectionvalid() {
  redoselectionvalid_ = false;
  clear_has_redoselectionvalid();
}
inline bool FormulaEditingCommandGroupArchive::redoselectionvalid() const {
  return redoselectionvalid_;
}
inline void FormulaEditingCommandGroupArchive::set_redoselectionvalid(bool value) {
  set_has_redoselectionvalid();
  redoselectionvalid_ = value;
}

// required uint32 redoSelectionStart = 7;
inline bool FormulaEditingCommandGroupArchive::has_redoselectionstart() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_redoselectionstart() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_redoselectionstart() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormulaEditingCommandGroupArchive::clear_redoselectionstart() {
  redoselectionstart_ = 0u;
  clear_has_redoselectionstart();
}
inline ::google::protobuf::uint32 FormulaEditingCommandGroupArchive::redoselectionstart() const {
  return redoselectionstart_;
}
inline void FormulaEditingCommandGroupArchive::set_redoselectionstart(::google::protobuf::uint32 value) {
  set_has_redoselectionstart();
  redoselectionstart_ = value;
}

// required uint32 redoSelectionLength = 8;
inline bool FormulaEditingCommandGroupArchive::has_redoselectionlength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_redoselectionlength() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_redoselectionlength() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FormulaEditingCommandGroupArchive::clear_redoselectionlength() {
  redoselectionlength_ = 0u;
  clear_has_redoselectionlength();
}
inline ::google::protobuf::uint32 FormulaEditingCommandGroupArchive::redoselectionlength() const {
  return redoselectionlength_;
}
inline void FormulaEditingCommandGroupArchive::set_redoselectionlength(::google::protobuf::uint32 value) {
  set_has_redoselectionlength();
  redoselectionlength_ = value;
}

// required uint32 redoActiveToken = 9;
inline bool FormulaEditingCommandGroupArchive::has_redoactivetoken() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FormulaEditingCommandGroupArchive::set_has_redoactivetoken() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FormulaEditingCommandGroupArchive::clear_has_redoactivetoken() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FormulaEditingCommandGroupArchive::clear_redoactivetoken() {
  redoactivetoken_ = 0u;
  clear_has_redoactivetoken();
}
inline ::google::protobuf::uint32 FormulaEditingCommandGroupArchive::redoactivetoken() const {
  return redoactivetoken_;
}
inline void FormulaEditingCommandGroupArchive::set_redoactivetoken(::google::protobuf::uint32 value) {
  set_has_redoactivetoken();
  redoactivetoken_ = value;
}

// -------------------------------------------------------------------

// FormulaEditingCommandSelectionBehaviorArchive

// optional bool undoSelectionValid = 2;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_undoselectionvalid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_undoselectionvalid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_undoselectionvalid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_undoselectionvalid() {
  undoselectionvalid_ = false;
  clear_has_undoselectionvalid();
}
inline bool FormulaEditingCommandSelectionBehaviorArchive::undoselectionvalid() const {
  return undoselectionvalid_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_undoselectionvalid(bool value) {
  set_has_undoselectionvalid();
  undoselectionvalid_ = value;
}

// optional uint32 undoSelectionStart = 3;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_undoselectionstart() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_undoselectionstart() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_undoselectionstart() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_undoselectionstart() {
  undoselectionstart_ = 0u;
  clear_has_undoselectionstart();
}
inline ::google::protobuf::uint32 FormulaEditingCommandSelectionBehaviorArchive::undoselectionstart() const {
  return undoselectionstart_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_undoselectionstart(::google::protobuf::uint32 value) {
  set_has_undoselectionstart();
  undoselectionstart_ = value;
}

// optional uint32 undoSelectionLength = 4;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_undoselectionlength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_undoselectionlength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_undoselectionlength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_undoselectionlength() {
  undoselectionlength_ = 0u;
  clear_has_undoselectionlength();
}
inline ::google::protobuf::uint32 FormulaEditingCommandSelectionBehaviorArchive::undoselectionlength() const {
  return undoselectionlength_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_undoselectionlength(::google::protobuf::uint32 value) {
  set_has_undoselectionlength();
  undoselectionlength_ = value;
}

// optional uint32 undoActiveToken = 5;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_undoactivetoken() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_undoactivetoken() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_undoactivetoken() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_undoactivetoken() {
  undoactivetoken_ = 0u;
  clear_has_undoactivetoken();
}
inline ::google::protobuf::uint32 FormulaEditingCommandSelectionBehaviorArchive::undoactivetoken() const {
  return undoactivetoken_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_undoactivetoken(::google::protobuf::uint32 value) {
  set_has_undoactivetoken();
  undoactivetoken_ = value;
}

// optional bool redoSelectionValid = 6;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_redoselectionvalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_redoselectionvalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_redoselectionvalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_redoselectionvalid() {
  redoselectionvalid_ = false;
  clear_has_redoselectionvalid();
}
inline bool FormulaEditingCommandSelectionBehaviorArchive::redoselectionvalid() const {
  return redoselectionvalid_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_redoselectionvalid(bool value) {
  set_has_redoselectionvalid();
  redoselectionvalid_ = value;
}

// optional uint32 redoSelectionStart = 7;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_redoselectionstart() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_redoselectionstart() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_redoselectionstart() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_redoselectionstart() {
  redoselectionstart_ = 0u;
  clear_has_redoselectionstart();
}
inline ::google::protobuf::uint32 FormulaEditingCommandSelectionBehaviorArchive::redoselectionstart() const {
  return redoselectionstart_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_redoselectionstart(::google::protobuf::uint32 value) {
  set_has_redoselectionstart();
  redoselectionstart_ = value;
}

// optional uint32 redoSelectionLength = 8;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_redoselectionlength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_redoselectionlength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_redoselectionlength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_redoselectionlength() {
  redoselectionlength_ = 0u;
  clear_has_redoselectionlength();
}
inline ::google::protobuf::uint32 FormulaEditingCommandSelectionBehaviorArchive::redoselectionlength() const {
  return redoselectionlength_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_redoselectionlength(::google::protobuf::uint32 value) {
  set_has_redoselectionlength();
  redoselectionlength_ = value;
}

// optional uint32 redoActiveToken = 9;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_redoactivetoken() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_redoactivetoken() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_redoactivetoken() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_redoactivetoken() {
  redoactivetoken_ = 0u;
  clear_has_redoactivetoken();
}
inline ::google::protobuf::uint32 FormulaEditingCommandSelectionBehaviorArchive::redoactivetoken() const {
  return redoactivetoken_;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_redoactivetoken(::google::protobuf::uint32 value) {
  set_has_redoactivetoken();
  redoactivetoken_ = value;
}

// optional .TSP.Reference storage = 10;
inline bool FormulaEditingCommandSelectionBehaviorArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& FormulaEditingCommandSelectionBehaviorArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* FormulaEditingCommandSelectionBehaviorArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* FormulaEditingCommandSelectionBehaviorArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void FormulaEditingCommandSelectionBehaviorArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// -------------------------------------------------------------------

// UndoRedoStateCommandSelectionBehaviorArchive

// optional .TSP.Reference before_undo_redo_state = 1 [deprecated = true];
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_before_undo_redo_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_has_before_undo_redo_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_has_before_undo_redo_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_before_undo_redo_state() {
  if (before_undo_redo_state_ != NULL) before_undo_redo_state_->::TSP::Reference::Clear();
  clear_has_before_undo_redo_state();
}
inline const ::TSP::Reference& UndoRedoStateCommandSelectionBehaviorArchive::before_undo_redo_state() const {
  return before_undo_redo_state_ != NULL ? *before_undo_redo_state_ : *default_instance_->before_undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::mutable_before_undo_redo_state() {
  set_has_before_undo_redo_state();
  if (before_undo_redo_state_ == NULL) before_undo_redo_state_ = new ::TSP::Reference;
  return before_undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::release_before_undo_redo_state() {
  clear_has_before_undo_redo_state();
  ::TSP::Reference* temp = before_undo_redo_state_;
  before_undo_redo_state_ = NULL;
  return temp;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_before_undo_redo_state(::TSP::Reference* before_undo_redo_state) {
  delete before_undo_redo_state_;
  before_undo_redo_state_ = before_undo_redo_state;
  if (before_undo_redo_state) {
    set_has_before_undo_redo_state();
  } else {
    clear_has_before_undo_redo_state();
  }
}

// optional .TSP.Reference after_undo_redo_state = 2 [deprecated = true];
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_after_undo_redo_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_has_after_undo_redo_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_has_after_undo_redo_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_after_undo_redo_state() {
  if (after_undo_redo_state_ != NULL) after_undo_redo_state_->::TSP::Reference::Clear();
  clear_has_after_undo_redo_state();
}
inline const ::TSP::Reference& UndoRedoStateCommandSelectionBehaviorArchive::after_undo_redo_state() const {
  return after_undo_redo_state_ != NULL ? *after_undo_redo_state_ : *default_instance_->after_undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::mutable_after_undo_redo_state() {
  set_has_after_undo_redo_state();
  if (after_undo_redo_state_ == NULL) after_undo_redo_state_ = new ::TSP::Reference;
  return after_undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::release_after_undo_redo_state() {
  clear_has_after_undo_redo_state();
  ::TSP::Reference* temp = after_undo_redo_state_;
  after_undo_redo_state_ = NULL;
  return temp;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_after_undo_redo_state(::TSP::Reference* after_undo_redo_state) {
  delete after_undo_redo_state_;
  after_undo_redo_state_ = after_undo_redo_state;
  if (after_undo_redo_state) {
    set_has_after_undo_redo_state();
  } else {
    clear_has_after_undo_redo_state();
  }
}

// optional .TSP.Reference table_info = 3;
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_table_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_has_table_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_has_table_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_table_info() {
  if (table_info_ != NULL) table_info_->::TSP::Reference::Clear();
  clear_has_table_info();
}
inline const ::TSP::Reference& UndoRedoStateCommandSelectionBehaviorArchive::table_info() const {
  return table_info_ != NULL ? *table_info_ : *default_instance_->table_info_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::mutable_table_info() {
  set_has_table_info();
  if (table_info_ == NULL) table_info_ = new ::TSP::Reference;
  return table_info_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::release_table_info() {
  clear_has_table_info();
  ::TSP::Reference* temp = table_info_;
  table_info_ = NULL;
  return temp;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_table_info(::TSP::Reference* table_info) {
  delete table_info_;
  table_info_ = table_info;
  if (table_info) {
    set_has_table_info();
  } else {
    clear_has_table_info();
  }
}

// optional .TST.SelectionArchive before_table_selection = 4;
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_before_table_selection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_has_before_table_selection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_has_before_table_selection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_before_table_selection() {
  if (before_table_selection_ != NULL) before_table_selection_->::TST::SelectionArchive::Clear();
  clear_has_before_table_selection();
}
inline const ::TST::SelectionArchive& UndoRedoStateCommandSelectionBehaviorArchive::before_table_selection() const {
  return before_table_selection_ != NULL ? *before_table_selection_ : *default_instance_->before_table_selection_;
}
inline ::TST::SelectionArchive* UndoRedoStateCommandSelectionBehaviorArchive::mutable_before_table_selection() {
  set_has_before_table_selection();
  if (before_table_selection_ == NULL) before_table_selection_ = new ::TST::SelectionArchive;
  return before_table_selection_;
}
inline ::TST::SelectionArchive* UndoRedoStateCommandSelectionBehaviorArchive::release_before_table_selection() {
  clear_has_before_table_selection();
  ::TST::SelectionArchive* temp = before_table_selection_;
  before_table_selection_ = NULL;
  return temp;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_before_table_selection(::TST::SelectionArchive* before_table_selection) {
  delete before_table_selection_;
  before_table_selection_ = before_table_selection;
  if (before_table_selection) {
    set_has_before_table_selection();
  } else {
    clear_has_before_table_selection();
  }
}

// optional .TST.SelectionArchive after_table_selection = 6;
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_after_table_selection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_has_after_table_selection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_has_after_table_selection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_after_table_selection() {
  if (after_table_selection_ != NULL) after_table_selection_->::TST::SelectionArchive::Clear();
  clear_has_after_table_selection();
}
inline const ::TST::SelectionArchive& UndoRedoStateCommandSelectionBehaviorArchive::after_table_selection() const {
  return after_table_selection_ != NULL ? *after_table_selection_ : *default_instance_->after_table_selection_;
}
inline ::TST::SelectionArchive* UndoRedoStateCommandSelectionBehaviorArchive::mutable_after_table_selection() {
  set_has_after_table_selection();
  if (after_table_selection_ == NULL) after_table_selection_ = new ::TST::SelectionArchive;
  return after_table_selection_;
}
inline ::TST::SelectionArchive* UndoRedoStateCommandSelectionBehaviorArchive::release_after_table_selection() {
  clear_has_after_table_selection();
  ::TST::SelectionArchive* temp = after_table_selection_;
  after_table_selection_ = NULL;
  return temp;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_after_table_selection(::TST::SelectionArchive* after_table_selection) {
  delete after_table_selection_;
  after_table_selection_ = after_table_selection;
  if (after_table_selection) {
    set_has_after_table_selection();
  } else {
    clear_has_after_table_selection();
  }
}

// -------------------------------------------------------------------

// TableCommandSelectionBehaviorArchive

// optional .TST.SelectionArchive before_table_selection = 1;
inline bool TableCommandSelectionBehaviorArchive::has_before_table_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableCommandSelectionBehaviorArchive::set_has_before_table_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableCommandSelectionBehaviorArchive::clear_has_before_table_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableCommandSelectionBehaviorArchive::clear_before_table_selection() {
  if (before_table_selection_ != NULL) before_table_selection_->::TST::SelectionArchive::Clear();
  clear_has_before_table_selection();
}
inline const ::TST::SelectionArchive& TableCommandSelectionBehaviorArchive::before_table_selection() const {
  return before_table_selection_ != NULL ? *before_table_selection_ : *default_instance_->before_table_selection_;
}
inline ::TST::SelectionArchive* TableCommandSelectionBehaviorArchive::mutable_before_table_selection() {
  set_has_before_table_selection();
  if (before_table_selection_ == NULL) before_table_selection_ = new ::TST::SelectionArchive;
  return before_table_selection_;
}
inline ::TST::SelectionArchive* TableCommandSelectionBehaviorArchive::release_before_table_selection() {
  clear_has_before_table_selection();
  ::TST::SelectionArchive* temp = before_table_selection_;
  before_table_selection_ = NULL;
  return temp;
}
inline void TableCommandSelectionBehaviorArchive::set_allocated_before_table_selection(::TST::SelectionArchive* before_table_selection) {
  delete before_table_selection_;
  before_table_selection_ = before_table_selection;
  if (before_table_selection) {
    set_has_before_table_selection();
  } else {
    clear_has_before_table_selection();
  }
}

// optional .TST.SelectionArchive after_table_selection = 2;
inline bool TableCommandSelectionBehaviorArchive::has_after_table_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableCommandSelectionBehaviorArchive::set_has_after_table_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableCommandSelectionBehaviorArchive::clear_has_after_table_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableCommandSelectionBehaviorArchive::clear_after_table_selection() {
  if (after_table_selection_ != NULL) after_table_selection_->::TST::SelectionArchive::Clear();
  clear_has_after_table_selection();
}
inline const ::TST::SelectionArchive& TableCommandSelectionBehaviorArchive::after_table_selection() const {
  return after_table_selection_ != NULL ? *after_table_selection_ : *default_instance_->after_table_selection_;
}
inline ::TST::SelectionArchive* TableCommandSelectionBehaviorArchive::mutable_after_table_selection() {
  set_has_after_table_selection();
  if (after_table_selection_ == NULL) after_table_selection_ = new ::TST::SelectionArchive;
  return after_table_selection_;
}
inline ::TST::SelectionArchive* TableCommandSelectionBehaviorArchive::release_after_table_selection() {
  clear_has_after_table_selection();
  ::TST::SelectionArchive* temp = after_table_selection_;
  after_table_selection_ = NULL;
  return temp;
}
inline void TableCommandSelectionBehaviorArchive::set_allocated_after_table_selection(::TST::SelectionArchive* after_table_selection) {
  delete after_table_selection_;
  after_table_selection_ = after_table_selection;
  if (after_table_selection) {
    set_has_after_table_selection();
  } else {
    clear_has_after_table_selection();
  }
}

// optional .TSP.Reference table_info = 3;
inline bool TableCommandSelectionBehaviorArchive::has_table_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableCommandSelectionBehaviorArchive::set_has_table_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableCommandSelectionBehaviorArchive::clear_has_table_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableCommandSelectionBehaviorArchive::clear_table_info() {
  if (table_info_ != NULL) table_info_->::TSP::Reference::Clear();
  clear_has_table_info();
}
inline const ::TSP::Reference& TableCommandSelectionBehaviorArchive::table_info() const {
  return table_info_ != NULL ? *table_info_ : *default_instance_->table_info_;
}
inline ::TSP::Reference* TableCommandSelectionBehaviorArchive::mutable_table_info() {
  set_has_table_info();
  if (table_info_ == NULL) table_info_ = new ::TSP::Reference;
  return table_info_;
}
inline ::TSP::Reference* TableCommandSelectionBehaviorArchive::release_table_info() {
  clear_has_table_info();
  ::TSP::Reference* temp = table_info_;
  table_info_ = NULL;
  return temp;
}
inline void TableCommandSelectionBehaviorArchive::set_allocated_table_info(::TSP::Reference* table_info) {
  delete table_info_;
  table_info_ = table_info;
  if (table_info) {
    set_has_table_info();
  } else {
    clear_has_table_info();
  }
}

// optional uint32 last_column_hit_by_tap = 4;
inline bool TableCommandSelectionBehaviorArchive::has_last_column_hit_by_tap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableCommandSelectionBehaviorArchive::set_has_last_column_hit_by_tap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableCommandSelectionBehaviorArchive::clear_has_last_column_hit_by_tap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableCommandSelectionBehaviorArchive::clear_last_column_hit_by_tap() {
  last_column_hit_by_tap_ = 0u;
  clear_has_last_column_hit_by_tap();
}
inline ::google::protobuf::uint32 TableCommandSelectionBehaviorArchive::last_column_hit_by_tap() const {
  return last_column_hit_by_tap_;
}
inline void TableCommandSelectionBehaviorArchive::set_last_column_hit_by_tap(::google::protobuf::uint32 value) {
  set_has_last_column_hit_by_tap();
  last_column_hit_by_tap_ = value;
}

// -------------------------------------------------------------------

// DisableTableNameSelectionBehaviorArchive

// required .TST.TableCommandSelectionBehaviorArchive super = 1;
inline bool DisableTableNameSelectionBehaviorArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisableTableNameSelectionBehaviorArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisableTableNameSelectionBehaviorArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisableTableNameSelectionBehaviorArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandSelectionBehaviorArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandSelectionBehaviorArchive& DisableTableNameSelectionBehaviorArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandSelectionBehaviorArchive* DisableTableNameSelectionBehaviorArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandSelectionBehaviorArchive;
  return super_;
}
inline ::TST::TableCommandSelectionBehaviorArchive* DisableTableNameSelectionBehaviorArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandSelectionBehaviorArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DisableTableNameSelectionBehaviorArchive::set_allocated_super(::TST::TableCommandSelectionBehaviorArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandApplyCellCommentArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandApplyCellCommentArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyCellCommentArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyCellCommentArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyCellCommentArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandApplyCellCommentArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandApplyCellCommentArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandApplyCellCommentArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyCellCommentArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellID cell_id = 2;
inline bool CommandApplyCellCommentArchive::has_cell_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyCellCommentArchive::set_has_cell_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyCellCommentArchive::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyCellCommentArchive::clear_cell_id() {
  if (cell_id_ != NULL) cell_id_->::TST::CellID::Clear();
  clear_has_cell_id();
}
inline const ::TST::CellID& CommandApplyCellCommentArchive::cell_id() const {
  return cell_id_ != NULL ? *cell_id_ : *default_instance_->cell_id_;
}
inline ::TST::CellID* CommandApplyCellCommentArchive::mutable_cell_id() {
  set_has_cell_id();
  if (cell_id_ == NULL) cell_id_ = new ::TST::CellID;
  return cell_id_;
}
inline ::TST::CellID* CommandApplyCellCommentArchive::release_cell_id() {
  clear_has_cell_id();
  ::TST::CellID* temp = cell_id_;
  cell_id_ = NULL;
  return temp;
}
inline void CommandApplyCellCommentArchive::set_allocated_cell_id(::TST::CellID* cell_id) {
  delete cell_id_;
  cell_id_ = cell_id;
  if (cell_id) {
    set_has_cell_id();
  } else {
    clear_has_cell_id();
  }
}

// optional .TSP.Reference old_comment_storage = 3;
inline bool CommandApplyCellCommentArchive::has_old_comment_storage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyCellCommentArchive::set_has_old_comment_storage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyCellCommentArchive::clear_has_old_comment_storage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyCellCommentArchive::clear_old_comment_storage() {
  if (old_comment_storage_ != NULL) old_comment_storage_->::TSP::Reference::Clear();
  clear_has_old_comment_storage();
}
inline const ::TSP::Reference& CommandApplyCellCommentArchive::old_comment_storage() const {
  return old_comment_storage_ != NULL ? *old_comment_storage_ : *default_instance_->old_comment_storage_;
}
inline ::TSP::Reference* CommandApplyCellCommentArchive::mutable_old_comment_storage() {
  set_has_old_comment_storage();
  if (old_comment_storage_ == NULL) old_comment_storage_ = new ::TSP::Reference;
  return old_comment_storage_;
}
inline ::TSP::Reference* CommandApplyCellCommentArchive::release_old_comment_storage() {
  clear_has_old_comment_storage();
  ::TSP::Reference* temp = old_comment_storage_;
  old_comment_storage_ = NULL;
  return temp;
}
inline void CommandApplyCellCommentArchive::set_allocated_old_comment_storage(::TSP::Reference* old_comment_storage) {
  delete old_comment_storage_;
  old_comment_storage_ = old_comment_storage;
  if (old_comment_storage) {
    set_has_old_comment_storage();
  } else {
    clear_has_old_comment_storage();
  }
}

// optional .TSP.Reference new_comment_storage = 4;
inline bool CommandApplyCellCommentArchive::has_new_comment_storage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandApplyCellCommentArchive::set_has_new_comment_storage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandApplyCellCommentArchive::clear_has_new_comment_storage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandApplyCellCommentArchive::clear_new_comment_storage() {
  if (new_comment_storage_ != NULL) new_comment_storage_->::TSP::Reference::Clear();
  clear_has_new_comment_storage();
}
inline const ::TSP::Reference& CommandApplyCellCommentArchive::new_comment_storage() const {
  return new_comment_storage_ != NULL ? *new_comment_storage_ : *default_instance_->new_comment_storage_;
}
inline ::TSP::Reference* CommandApplyCellCommentArchive::mutable_new_comment_storage() {
  set_has_new_comment_storage();
  if (new_comment_storage_ == NULL) new_comment_storage_ = new ::TSP::Reference;
  return new_comment_storage_;
}
inline ::TSP::Reference* CommandApplyCellCommentArchive::release_new_comment_storage() {
  clear_has_new_comment_storage();
  ::TSP::Reference* temp = new_comment_storage_;
  new_comment_storage_ = NULL;
  return temp;
}
inline void CommandApplyCellCommentArchive::set_allocated_new_comment_storage(::TSP::Reference* new_comment_storage) {
  delete new_comment_storage_;
  new_comment_storage_ = new_comment_storage;
  if (new_comment_storage) {
    set_has_new_comment_storage();
  } else {
    clear_has_new_comment_storage();
  }
}

// -------------------------------------------------------------------

// CommandApplyConditionalStyleSetArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandApplyConditionalStyleSetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandApplyConditionalStyleSetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandApplyConditionalStyleSetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandApplyConditionalStyleSetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandApplyConditionalStyleSetArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandApplyConditionalStyleSetArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.SelectionArchive selection = 2;
inline bool CommandApplyConditionalStyleSetArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandApplyConditionalStyleSetArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandApplyConditionalStyleSetArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandApplyConditionalStyleSetArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandApplyConditionalStyleSetArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandApplyConditionalStyleSetArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// required .TST.CellMapArchive undo_cell_map = 3;
inline bool CommandApplyConditionalStyleSetArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandApplyConditionalStyleSetArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyConditionalStyleSetArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyConditionalStyleSetArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyConditionalStyleSetArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyConditionalStyleSetArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandApplyConditionalStyleSetArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandApplyConditionalStyleSetArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandApplyConditionalStyleSetArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandApplyConditionalStyleSetArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyConditionalStyleSetArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandApplyConditionalStyleSetArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandApplyConditionalStyleSetArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// -------------------------------------------------------------------

// CommandSetFormulaTokenizationArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSetFormulaTokenizationArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFormulaTokenizationArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFormulaTokenizationArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFormulaTokenizationArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetFormulaTokenizationArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetFormulaTokenizationArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetFormulaTokenizationArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFormulaTokenizationArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required bool tokenization = 2;
inline bool CommandSetFormulaTokenizationArchive::has_tokenization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFormulaTokenizationArchive::set_has_tokenization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFormulaTokenizationArchive::clear_has_tokenization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFormulaTokenizationArchive::clear_tokenization() {
  tokenization_ = false;
  clear_has_tokenization();
}
inline bool CommandSetFormulaTokenizationArchive::tokenization() const {
  return tokenization_;
}
inline void CommandSetFormulaTokenizationArchive::set_tokenization(bool value) {
  set_has_tokenization();
  tokenization_ = value;
}

// -------------------------------------------------------------------

// CommandSetFilterEnabledArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetFilterEnabledArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFilterEnabledArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFilterEnabledArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFilterEnabledArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetFilterEnabledArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetFilterEnabledArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetFilterEnabledArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFilterEnabledArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 filter_index = 2;
inline bool CommandSetFilterEnabledArchive::has_filter_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFilterEnabledArchive::set_has_filter_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFilterEnabledArchive::clear_has_filter_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFilterEnabledArchive::clear_filter_index() {
  filter_index_ = 0u;
  clear_has_filter_index();
}
inline ::google::protobuf::uint32 CommandSetFilterEnabledArchive::filter_index() const {
  return filter_index_;
}
inline void CommandSetFilterEnabledArchive::set_filter_index(::google::protobuf::uint32 value) {
  set_has_filter_index();
  filter_index_ = value;
}

// required bool enabled = 4;
inline bool CommandSetFilterEnabledArchive::has_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetFilterEnabledArchive::set_has_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetFilterEnabledArchive::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetFilterEnabledArchive::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool CommandSetFilterEnabledArchive::enabled() const {
  return enabled_;
}
inline void CommandSetFilterEnabledArchive::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// CommandSetFilterRuleEnabledArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetFilterRuleEnabledArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFilterRuleEnabledArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetFilterRuleEnabledArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetFilterRuleEnabledArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetFilterRuleEnabledArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFilterRuleEnabledArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 filter_index = 2;
inline bool CommandSetFilterRuleEnabledArchive::has_filter_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFilterRuleEnabledArchive::set_has_filter_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_has_filter_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_filter_index() {
  filter_index_ = 0u;
  clear_has_filter_index();
}
inline ::google::protobuf::uint32 CommandSetFilterRuleEnabledArchive::filter_index() const {
  return filter_index_;
}
inline void CommandSetFilterRuleEnabledArchive::set_filter_index(::google::protobuf::uint32 value) {
  set_has_filter_index();
  filter_index_ = value;
}

// required uint32 rule_index = 3;
inline bool CommandSetFilterRuleEnabledArchive::has_rule_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetFilterRuleEnabledArchive::set_has_rule_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_has_rule_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_rule_index() {
  rule_index_ = 0u;
  clear_has_rule_index();
}
inline ::google::protobuf::uint32 CommandSetFilterRuleEnabledArchive::rule_index() const {
  return rule_index_;
}
inline void CommandSetFilterRuleEnabledArchive::set_rule_index(::google::protobuf::uint32 value) {
  set_has_rule_index();
  rule_index_ = value;
}

// required bool enabled = 4;
inline bool CommandSetFilterRuleEnabledArchive::has_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetFilterRuleEnabledArchive::set_has_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetFilterRuleEnabledArchive::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool CommandSetFilterRuleEnabledArchive::enabled() const {
  return enabled_;
}
inline void CommandSetFilterRuleEnabledArchive::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// CommandSetFilterSetTypeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetFilterSetTypeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetFilterSetTypeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetFilterSetTypeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetFilterSetTypeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetFilterSetTypeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetFilterSetTypeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetFilterSetTypeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetFilterSetTypeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.FilterSetArchive.FilterSetType old_filter_set_type = 2;
inline bool CommandSetFilterSetTypeArchive::has_old_filter_set_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetFilterSetTypeArchive::set_has_old_filter_set_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetFilterSetTypeArchive::clear_has_old_filter_set_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetFilterSetTypeArchive::clear_old_filter_set_type() {
  old_filter_set_type_ = 0;
  clear_has_old_filter_set_type();
}
inline ::TST::FilterSetArchive_FilterSetType CommandSetFilterSetTypeArchive::old_filter_set_type() const {
  return static_cast< ::TST::FilterSetArchive_FilterSetType >(old_filter_set_type_);
}
inline void CommandSetFilterSetTypeArchive::set_old_filter_set_type(::TST::FilterSetArchive_FilterSetType value) {
  assert(::TST::FilterSetArchive_FilterSetType_IsValid(value));
  set_has_old_filter_set_type();
  old_filter_set_type_ = value;
}

// required .TST.FilterSetArchive.FilterSetType new_filter_set_type = 3;
inline bool CommandSetFilterSetTypeArchive::has_new_filter_set_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetFilterSetTypeArchive::set_has_new_filter_set_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetFilterSetTypeArchive::clear_has_new_filter_set_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetFilterSetTypeArchive::clear_new_filter_set_type() {
  new_filter_set_type_ = 0;
  clear_has_new_filter_set_type();
}
inline ::TST::FilterSetArchive_FilterSetType CommandSetFilterSetTypeArchive::new_filter_set_type() const {
  return static_cast< ::TST::FilterSetArchive_FilterSetType >(new_filter_set_type_);
}
inline void CommandSetFilterSetTypeArchive::set_new_filter_set_type(::TST::FilterSetArchive_FilterSetType value) {
  assert(::TST::FilterSetArchive_FilterSetType_IsValid(value));
  set_has_new_filter_set_type();
  new_filter_set_type_ = value;
}

// -------------------------------------------------------------------

// CommandSetStyleNetworkArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetStyleNetworkArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetStyleNetworkArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetStyleNetworkArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetStyleNetworkArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetStyleNetworkArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetStyleNetworkArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetStyleNetworkArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetStyleNetworkArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.TableStyleNetworkArchive old_style_network = 2;
inline bool CommandSetStyleNetworkArchive::has_old_style_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetStyleNetworkArchive::set_has_old_style_network() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetStyleNetworkArchive::clear_has_old_style_network() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetStyleNetworkArchive::clear_old_style_network() {
  if (old_style_network_ != NULL) old_style_network_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_old_style_network();
}
inline const ::TST::TableStyleNetworkArchive& CommandSetStyleNetworkArchive::old_style_network() const {
  return old_style_network_ != NULL ? *old_style_network_ : *default_instance_->old_style_network_;
}
inline ::TST::TableStyleNetworkArchive* CommandSetStyleNetworkArchive::mutable_old_style_network() {
  set_has_old_style_network();
  if (old_style_network_ == NULL) old_style_network_ = new ::TST::TableStyleNetworkArchive;
  return old_style_network_;
}
inline ::TST::TableStyleNetworkArchive* CommandSetStyleNetworkArchive::release_old_style_network() {
  clear_has_old_style_network();
  ::TST::TableStyleNetworkArchive* temp = old_style_network_;
  old_style_network_ = NULL;
  return temp;
}
inline void CommandSetStyleNetworkArchive::set_allocated_old_style_network(::TST::TableStyleNetworkArchive* old_style_network) {
  delete old_style_network_;
  old_style_network_ = old_style_network;
  if (old_style_network) {
    set_has_old_style_network();
  } else {
    clear_has_old_style_network();
  }
}

// required .TST.TableStyleNetworkArchive new_style_network = 3;
inline bool CommandSetStyleNetworkArchive::has_new_style_network() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetStyleNetworkArchive::set_has_new_style_network() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetStyleNetworkArchive::clear_has_new_style_network() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetStyleNetworkArchive::clear_new_style_network() {
  if (new_style_network_ != NULL) new_style_network_->::TST::TableStyleNetworkArchive::Clear();
  clear_has_new_style_network();
}
inline const ::TST::TableStyleNetworkArchive& CommandSetStyleNetworkArchive::new_style_network() const {
  return new_style_network_ != NULL ? *new_style_network_ : *default_instance_->new_style_network_;
}
inline ::TST::TableStyleNetworkArchive* CommandSetStyleNetworkArchive::mutable_new_style_network() {
  set_has_new_style_network();
  if (new_style_network_ == NULL) new_style_network_ = new ::TST::TableStyleNetworkArchive;
  return new_style_network_;
}
inline ::TST::TableStyleNetworkArchive* CommandSetStyleNetworkArchive::release_new_style_network() {
  clear_has_new_style_network();
  ::TST::TableStyleNetworkArchive* temp = new_style_network_;
  new_style_network_ = NULL;
  return temp;
}
inline void CommandSetStyleNetworkArchive::set_allocated_new_style_network(::TST::TableStyleNetworkArchive* new_style_network) {
  delete new_style_network_;
  new_style_network_ = new_style_network;
  if (new_style_network) {
    set_has_new_style_network();
  } else {
    clear_has_new_style_network();
  }
}

// -------------------------------------------------------------------

// CommandMutateCellsArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandMutateCellsArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMutateCellsArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMutateCellsArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMutateCellsArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandMutateCellsArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandMutateCellsArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandMutateCellsArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandMutateCellsArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellMapArchive undo_cell_map = 2;
inline bool CommandMutateCellsArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMutateCellsArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMutateCellsArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMutateCellsArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandMutateCellsArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMutateCellsArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMutateCellsArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandMutateCellsArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// required .TST.CellMapArchive redo_cell_map = 3;
inline bool CommandMutateCellsArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandMutateCellsArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandMutateCellsArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandMutateCellsArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandMutateCellsArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMutateCellsArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandMutateCellsArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandMutateCellsArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional .TST.SelectionArchive selection = 4;
inline bool CommandMutateCellsArchive::has_selection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandMutateCellsArchive::set_has_selection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandMutateCellsArchive::clear_has_selection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandMutateCellsArchive::clear_selection() {
  if (selection_ != NULL) selection_->::TST::SelectionArchive::Clear();
  clear_has_selection();
}
inline const ::TST::SelectionArchive& CommandMutateCellsArchive::selection() const {
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
}
inline ::TST::SelectionArchive* CommandMutateCellsArchive::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::TST::SelectionArchive;
  return selection_;
}
inline ::TST::SelectionArchive* CommandMutateCellsArchive::release_selection() {
  clear_has_selection();
  ::TST::SelectionArchive* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void CommandMutateCellsArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// -------------------------------------------------------------------

// CommandDisableFilterRulesForColumnArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandDisableFilterRulesForColumnArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDisableFilterRulesForColumnArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDisableFilterRulesForColumnArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDisableFilterRulesForColumnArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandDisableFilterRulesForColumnArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandDisableFilterRulesForColumnArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandDisableFilterRulesForColumnArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDisableFilterRulesForColumnArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required uint32 column_index = 2;
inline bool CommandDisableFilterRulesForColumnArchive::has_column_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDisableFilterRulesForColumnArchive::set_has_column_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDisableFilterRulesForColumnArchive::clear_has_column_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDisableFilterRulesForColumnArchive::clear_column_index() {
  column_index_ = 0u;
  clear_has_column_index();
}
inline ::google::protobuf::uint32 CommandDisableFilterRulesForColumnArchive::column_index() const {
  return column_index_;
}
inline void CommandDisableFilterRulesForColumnArchive::set_column_index(::google::protobuf::uint32 value) {
  set_has_column_index();
  column_index_ = value;
}

// repeated uint32 rule_indices = 3;
inline int CommandDisableFilterRulesForColumnArchive::rule_indices_size() const {
  return rule_indices_.size();
}
inline void CommandDisableFilterRulesForColumnArchive::clear_rule_indices() {
  rule_indices_.Clear();
}
inline ::google::protobuf::uint32 CommandDisableFilterRulesForColumnArchive::rule_indices(int index) const {
  return rule_indices_.Get(index);
}
inline void CommandDisableFilterRulesForColumnArchive::set_rule_indices(int index, ::google::protobuf::uint32 value) {
  rule_indices_.Set(index, value);
}
inline void CommandDisableFilterRulesForColumnArchive::add_rule_indices(::google::protobuf::uint32 value) {
  rule_indices_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CommandDisableFilterRulesForColumnArchive::rule_indices() const {
  return rule_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CommandDisableFilterRulesForColumnArchive::mutable_rule_indices() {
  return &rule_indices_;
}

// -------------------------------------------------------------------

// CommandSetTextStyleArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetTextStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetTextStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetTextStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetTextStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetTextStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetTextStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetTextStyleArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetTextStyleArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TST.CellRegion region = 2;
inline bool CommandSetTextStyleArchive::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetTextStyleArchive::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetTextStyleArchive::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetTextStyleArchive::clear_region() {
  if (region_ != NULL) region_->::TST::CellRegion::Clear();
  clear_has_region();
}
inline const ::TST::CellRegion& CommandSetTextStyleArchive::region() const {
  return region_ != NULL ? *region_ : *default_instance_->region_;
}
inline ::TST::CellRegion* CommandSetTextStyleArchive::mutable_region() {
  set_has_region();
  if (region_ == NULL) region_ = new ::TST::CellRegion;
  return region_;
}
inline ::TST::CellRegion* CommandSetTextStyleArchive::release_region() {
  clear_has_region();
  ::TST::CellRegion* temp = region_;
  region_ = NULL;
  return temp;
}
inline void CommandSetTextStyleArchive::set_allocated_region(::TST::CellRegion* region) {
  delete region_;
  region_ = region;
  if (region) {
    set_has_region();
  } else {
    clear_has_region();
  }
}

// optional .TST.CellMapArchive undo_cell_map = 3;
inline bool CommandSetTextStyleArchive::has_undo_cell_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetTextStyleArchive::set_has_undo_cell_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetTextStyleArchive::clear_has_undo_cell_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetTextStyleArchive::clear_undo_cell_map() {
  if (undo_cell_map_ != NULL) undo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_undo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetTextStyleArchive::undo_cell_map() const {
  return undo_cell_map_ != NULL ? *undo_cell_map_ : *default_instance_->undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTextStyleArchive::mutable_undo_cell_map() {
  set_has_undo_cell_map();
  if (undo_cell_map_ == NULL) undo_cell_map_ = new ::TST::CellMapArchive;
  return undo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTextStyleArchive::release_undo_cell_map() {
  clear_has_undo_cell_map();
  ::TST::CellMapArchive* temp = undo_cell_map_;
  undo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetTextStyleArchive::set_allocated_undo_cell_map(::TST::CellMapArchive* undo_cell_map) {
  delete undo_cell_map_;
  undo_cell_map_ = undo_cell_map;
  if (undo_cell_map) {
    set_has_undo_cell_map();
  } else {
    clear_has_undo_cell_map();
  }
}

// optional .TST.CellMapArchive redo_cell_map = 4;
inline bool CommandSetTextStyleArchive::has_redo_cell_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetTextStyleArchive::set_has_redo_cell_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetTextStyleArchive::clear_has_redo_cell_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetTextStyleArchive::clear_redo_cell_map() {
  if (redo_cell_map_ != NULL) redo_cell_map_->::TST::CellMapArchive::Clear();
  clear_has_redo_cell_map();
}
inline const ::TST::CellMapArchive& CommandSetTextStyleArchive::redo_cell_map() const {
  return redo_cell_map_ != NULL ? *redo_cell_map_ : *default_instance_->redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTextStyleArchive::mutable_redo_cell_map() {
  set_has_redo_cell_map();
  if (redo_cell_map_ == NULL) redo_cell_map_ = new ::TST::CellMapArchive;
  return redo_cell_map_;
}
inline ::TST::CellMapArchive* CommandSetTextStyleArchive::release_redo_cell_map() {
  clear_has_redo_cell_map();
  ::TST::CellMapArchive* temp = redo_cell_map_;
  redo_cell_map_ = NULL;
  return temp;
}
inline void CommandSetTextStyleArchive::set_allocated_redo_cell_map(::TST::CellMapArchive* redo_cell_map) {
  delete redo_cell_map_;
  redo_cell_map_ = redo_cell_map;
  if (redo_cell_map) {
    set_has_redo_cell_map();
  } else {
    clear_has_redo_cell_map();
  }
}

// optional .TSP.Reference subcommands = 5;
inline bool CommandSetTextStyleArchive::has_subcommands() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetTextStyleArchive::set_has_subcommands() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetTextStyleArchive::clear_has_subcommands() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetTextStyleArchive::clear_subcommands() {
  if (subcommands_ != NULL) subcommands_->::TSP::Reference::Clear();
  clear_has_subcommands();
}
inline const ::TSP::Reference& CommandSetTextStyleArchive::subcommands() const {
  return subcommands_ != NULL ? *subcommands_ : *default_instance_->subcommands_;
}
inline ::TSP::Reference* CommandSetTextStyleArchive::mutable_subcommands() {
  set_has_subcommands();
  if (subcommands_ == NULL) subcommands_ = new ::TSP::Reference;
  return subcommands_;
}
inline ::TSP::Reference* CommandSetTextStyleArchive::release_subcommands() {
  clear_has_subcommands();
  ::TSP::Reference* temp = subcommands_;
  subcommands_ = NULL;
  return temp;
}
inline void CommandSetTextStyleArchive::set_allocated_subcommands(::TSP::Reference* subcommands) {
  delete subcommands_;
  subcommands_ = subcommands;
  if (subcommands) {
    set_has_subcommands();
  } else {
    clear_has_subcommands();
  }
}

// -------------------------------------------------------------------

// CommandNotifyForTransformingArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandNotifyForTransformingArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandNotifyForTransformingArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandNotifyForTransformingArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandNotifyForTransformingArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandNotifyForTransformingArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandNotifyForTransformingArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandNotifyForTransformingArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandNotifyForTransformingArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetStorageLanguageArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSetStorageLanguageArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetStorageLanguageArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetStorageLanguageArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetStorageLanguageArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetStorageLanguageArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetStorageLanguageArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetStorageLanguageArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetStorageLanguageArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference storage = 2;
inline bool CommandSetStorageLanguageArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetStorageLanguageArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetStorageLanguageArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetStorageLanguageArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& CommandSetStorageLanguageArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* CommandSetStorageLanguageArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* CommandSetStorageLanguageArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void CommandSetStorageLanguageArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// required string language = 3;
inline bool CommandSetStorageLanguageArchive::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetStorageLanguageArchive::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetStorageLanguageArchive::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetStorageLanguageArchive::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& CommandSetStorageLanguageArchive::language() const {
  return *language_;
}
inline void CommandSetStorageLanguageArchive::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void CommandSetStorageLanguageArchive::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void CommandSetStorageLanguageArchive::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetStorageLanguageArchive::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* CommandSetStorageLanguageArchive::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetStorageLanguageArchive::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 range_location = 4;
inline bool CommandSetStorageLanguageArchive::has_range_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetStorageLanguageArchive::set_has_range_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetStorageLanguageArchive::clear_has_range_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetStorageLanguageArchive::clear_range_location() {
  range_location_ = 0u;
  clear_has_range_location();
}
inline ::google::protobuf::uint32 CommandSetStorageLanguageArchive::range_location() const {
  return range_location_;
}
inline void CommandSetStorageLanguageArchive::set_range_location(::google::protobuf::uint32 value) {
  set_has_range_location();
  range_location_ = value;
}

// required uint32 range_length = 5;
inline bool CommandSetStorageLanguageArchive::has_range_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetStorageLanguageArchive::set_has_range_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetStorageLanguageArchive::clear_has_range_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetStorageLanguageArchive::clear_range_length() {
  range_length_ = 0u;
  clear_has_range_length();
}
inline ::google::protobuf::uint32 CommandSetStorageLanguageArchive::range_length() const {
  return range_length_;
}
inline void CommandSetStorageLanguageArchive::set_range_length(::google::protobuf::uint32 value) {
  set_has_range_length();
  range_length_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool CommandSetStorageLanguageArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSetStorageLanguageArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSetStorageLanguageArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSetStorageLanguageArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& CommandSetStorageLanguageArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* CommandSetStorageLanguageArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* CommandSetStorageLanguageArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void CommandSetStorageLanguageArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// CommandSetSortOrderArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandSetSortOrderArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetSortOrderArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetSortOrderArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetSortOrderArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandSetSortOrderArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandSetSortOrderArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandSetSortOrderArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetSortOrderArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TST.TableSortOrderArchive old_sort_order = 2;
inline bool CommandSetSortOrderArchive::has_old_sort_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetSortOrderArchive::set_has_old_sort_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetSortOrderArchive::clear_has_old_sort_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetSortOrderArchive::clear_old_sort_order() {
  if (old_sort_order_ != NULL) old_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_old_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandSetSortOrderArchive::old_sort_order() const {
  return old_sort_order_ != NULL ? *old_sort_order_ : *default_instance_->old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandSetSortOrderArchive::mutable_old_sort_order() {
  set_has_old_sort_order();
  if (old_sort_order_ == NULL) old_sort_order_ = new ::TST::TableSortOrderArchive;
  return old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandSetSortOrderArchive::release_old_sort_order() {
  clear_has_old_sort_order();
  ::TST::TableSortOrderArchive* temp = old_sort_order_;
  old_sort_order_ = NULL;
  return temp;
}
inline void CommandSetSortOrderArchive::set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order) {
  delete old_sort_order_;
  old_sort_order_ = old_sort_order;
  if (old_sort_order) {
    set_has_old_sort_order();
  } else {
    clear_has_old_sort_order();
  }
}

// optional .TST.TableSortOrderArchive new_sort_order = 3;
inline bool CommandSetSortOrderArchive::has_new_sort_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetSortOrderArchive::set_has_new_sort_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetSortOrderArchive::clear_has_new_sort_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetSortOrderArchive::clear_new_sort_order() {
  if (new_sort_order_ != NULL) new_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_new_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandSetSortOrderArchive::new_sort_order() const {
  return new_sort_order_ != NULL ? *new_sort_order_ : *default_instance_->new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandSetSortOrderArchive::mutable_new_sort_order() {
  set_has_new_sort_order();
  if (new_sort_order_ == NULL) new_sort_order_ = new ::TST::TableSortOrderArchive;
  return new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandSetSortOrderArchive::release_new_sort_order() {
  clear_has_new_sort_order();
  ::TST::TableSortOrderArchive* temp = new_sort_order_;
  new_sort_order_ = NULL;
  return temp;
}
inline void CommandSetSortOrderArchive::set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order) {
  delete new_sort_order_;
  new_sort_order_ = new_sort_order;
  if (new_sort_order) {
    set_has_new_sort_order();
  } else {
    clear_has_new_sort_order();
  }
}

// -------------------------------------------------------------------

// CommandRewriteSortOrderForTectonicShiftArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteSortOrderForTectonicShiftArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteSortOrderForTectonicShiftArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteSortOrderForTectonicShiftArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteSortOrderForTectonicShiftArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSCE.TectonicShiftArchive tectonic_shift = 2;
inline bool CommandRewriteSortOrderForTectonicShiftArchive::has_tectonic_shift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_has_tectonic_shift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_has_tectonic_shift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_tectonic_shift() {
  if (tectonic_shift_ != NULL) tectonic_shift_->::TSCE::TectonicShiftArchive::Clear();
  clear_has_tectonic_shift();
}
inline const ::TSCE::TectonicShiftArchive& CommandRewriteSortOrderForTectonicShiftArchive::tectonic_shift() const {
  return tectonic_shift_ != NULL ? *tectonic_shift_ : *default_instance_->tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteSortOrderForTectonicShiftArchive::mutable_tectonic_shift() {
  set_has_tectonic_shift();
  if (tectonic_shift_ == NULL) tectonic_shift_ = new ::TSCE::TectonicShiftArchive;
  return tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* CommandRewriteSortOrderForTectonicShiftArchive::release_tectonic_shift() {
  clear_has_tectonic_shift();
  ::TSCE::TectonicShiftArchive* temp = tectonic_shift_;
  tectonic_shift_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift) {
  delete tectonic_shift_;
  tectonic_shift_ = tectonic_shift;
  if (tectonic_shift) {
    set_has_tectonic_shift();
  } else {
    clear_has_tectonic_shift();
  }
}

// optional .TST.TableSortOrderArchive old_sort_order = 3;
inline bool CommandRewriteSortOrderForTectonicShiftArchive::has_old_sort_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_has_old_sort_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_has_old_sort_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_old_sort_order() {
  if (old_sort_order_ != NULL) old_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_old_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandRewriteSortOrderForTectonicShiftArchive::old_sort_order() const {
  return old_sort_order_ != NULL ? *old_sort_order_ : *default_instance_->old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTectonicShiftArchive::mutable_old_sort_order() {
  set_has_old_sort_order();
  if (old_sort_order_ == NULL) old_sort_order_ = new ::TST::TableSortOrderArchive;
  return old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTectonicShiftArchive::release_old_sort_order() {
  clear_has_old_sort_order();
  ::TST::TableSortOrderArchive* temp = old_sort_order_;
  old_sort_order_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order) {
  delete old_sort_order_;
  old_sort_order_ = old_sort_order;
  if (old_sort_order) {
    set_has_old_sort_order();
  } else {
    clear_has_old_sort_order();
  }
}

// optional .TST.TableSortOrderArchive new_sort_order = 4;
inline bool CommandRewriteSortOrderForTectonicShiftArchive::has_new_sort_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_has_new_sort_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_has_new_sort_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::clear_new_sort_order() {
  if (new_sort_order_ != NULL) new_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_new_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandRewriteSortOrderForTectonicShiftArchive::new_sort_order() const {
  return new_sort_order_ != NULL ? *new_sort_order_ : *default_instance_->new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTectonicShiftArchive::mutable_new_sort_order() {
  set_has_new_sort_order();
  if (new_sort_order_ == NULL) new_sort_order_ = new ::TST::TableSortOrderArchive;
  return new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTectonicShiftArchive::release_new_sort_order() {
  clear_has_new_sort_order();
  ::TST::TableSortOrderArchive* temp = new_sort_order_;
  new_sort_order_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTectonicShiftArchive::set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order) {
  delete new_sort_order_;
  new_sort_order_ = new_sort_order;
  if (new_sort_order) {
    set_has_new_sort_order();
  } else {
    clear_has_new_sort_order();
  }
}

// -------------------------------------------------------------------

// CommandRewriteSortOrderForSortArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteSortOrderForSortArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteSortOrderForSortArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteSortOrderForSortArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteSortOrderForSortArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteSortOrderForSortArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForSortArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSK.ShuffleMappingArchive sort_mapping = 2;
inline bool CommandRewriteSortOrderForSortArchive::has_sort_mapping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteSortOrderForSortArchive::set_has_sort_mapping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_has_sort_mapping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_sort_mapping() {
  if (sort_mapping_ != NULL) sort_mapping_->::TSK::ShuffleMappingArchive::Clear();
  clear_has_sort_mapping();
}
inline const ::TSK::ShuffleMappingArchive& CommandRewriteSortOrderForSortArchive::sort_mapping() const {
  return sort_mapping_ != NULL ? *sort_mapping_ : *default_instance_->sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteSortOrderForSortArchive::mutable_sort_mapping() {
  set_has_sort_mapping();
  if (sort_mapping_ == NULL) sort_mapping_ = new ::TSK::ShuffleMappingArchive;
  return sort_mapping_;
}
inline ::TSK::ShuffleMappingArchive* CommandRewriteSortOrderForSortArchive::release_sort_mapping() {
  clear_has_sort_mapping();
  ::TSK::ShuffleMappingArchive* temp = sort_mapping_;
  sort_mapping_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForSortArchive::set_allocated_sort_mapping(::TSK::ShuffleMappingArchive* sort_mapping) {
  delete sort_mapping_;
  sort_mapping_ = sort_mapping;
  if (sort_mapping) {
    set_has_sort_mapping();
  } else {
    clear_has_sort_mapping();
  }
}

// optional .TST.TableSortOrderArchive old_sort_order = 3;
inline bool CommandRewriteSortOrderForSortArchive::has_old_sort_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteSortOrderForSortArchive::set_has_old_sort_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_has_old_sort_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_old_sort_order() {
  if (old_sort_order_ != NULL) old_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_old_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandRewriteSortOrderForSortArchive::old_sort_order() const {
  return old_sort_order_ != NULL ? *old_sort_order_ : *default_instance_->old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForSortArchive::mutable_old_sort_order() {
  set_has_old_sort_order();
  if (old_sort_order_ == NULL) old_sort_order_ = new ::TST::TableSortOrderArchive;
  return old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForSortArchive::release_old_sort_order() {
  clear_has_old_sort_order();
  ::TST::TableSortOrderArchive* temp = old_sort_order_;
  old_sort_order_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForSortArchive::set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order) {
  delete old_sort_order_;
  old_sort_order_ = old_sort_order;
  if (old_sort_order) {
    set_has_old_sort_order();
  } else {
    clear_has_old_sort_order();
  }
}

// optional .TST.TableSortOrderArchive new_sort_order = 4;
inline bool CommandRewriteSortOrderForSortArchive::has_new_sort_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRewriteSortOrderForSortArchive::set_has_new_sort_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_has_new_sort_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRewriteSortOrderForSortArchive::clear_new_sort_order() {
  if (new_sort_order_ != NULL) new_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_new_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandRewriteSortOrderForSortArchive::new_sort_order() const {
  return new_sort_order_ != NULL ? *new_sort_order_ : *default_instance_->new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForSortArchive::mutable_new_sort_order() {
  set_has_new_sort_order();
  if (new_sort_order_ == NULL) new_sort_order_ = new ::TST::TableSortOrderArchive;
  return new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForSortArchive::release_new_sort_order() {
  clear_has_new_sort_order();
  ::TST::TableSortOrderArchive* temp = new_sort_order_;
  new_sort_order_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForSortArchive::set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order) {
  delete new_sort_order_;
  new_sort_order_ = new_sort_order;
  if (new_sort_order) {
    set_has_new_sort_order();
  } else {
    clear_has_new_sort_order();
  }
}

// -------------------------------------------------------------------

// CommandRewriteSortOrderForTableResizeArchive

// required .TST.TableCommandArchive super = 1;
inline bool CommandRewriteSortOrderForTableResizeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRewriteSortOrderForTableResizeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRewriteSortOrderForTableResizeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRewriteSortOrderForTableResizeArchive::clear_super() {
  if (super_ != NULL) super_->::TST::TableCommandArchive::Clear();
  clear_has_super();
}
inline const ::TST::TableCommandArchive& CommandRewriteSortOrderForTableResizeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TST::TableCommandArchive* CommandRewriteSortOrderForTableResizeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TST::TableCommandArchive;
  return super_;
}
inline ::TST::TableCommandArchive* CommandRewriteSortOrderForTableResizeArchive::release_super() {
  clear_has_super();
  ::TST::TableCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTableResizeArchive::set_allocated_super(::TST::TableCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TST.TableSortOrderArchive old_sort_order = 2;
inline bool CommandRewriteSortOrderForTableResizeArchive::has_old_sort_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRewriteSortOrderForTableResizeArchive::set_has_old_sort_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRewriteSortOrderForTableResizeArchive::clear_has_old_sort_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRewriteSortOrderForTableResizeArchive::clear_old_sort_order() {
  if (old_sort_order_ != NULL) old_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_old_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandRewriteSortOrderForTableResizeArchive::old_sort_order() const {
  return old_sort_order_ != NULL ? *old_sort_order_ : *default_instance_->old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTableResizeArchive::mutable_old_sort_order() {
  set_has_old_sort_order();
  if (old_sort_order_ == NULL) old_sort_order_ = new ::TST::TableSortOrderArchive;
  return old_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTableResizeArchive::release_old_sort_order() {
  clear_has_old_sort_order();
  ::TST::TableSortOrderArchive* temp = old_sort_order_;
  old_sort_order_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTableResizeArchive::set_allocated_old_sort_order(::TST::TableSortOrderArchive* old_sort_order) {
  delete old_sort_order_;
  old_sort_order_ = old_sort_order;
  if (old_sort_order) {
    set_has_old_sort_order();
  } else {
    clear_has_old_sort_order();
  }
}

// optional .TST.TableSortOrderArchive new_sort_order = 3;
inline bool CommandRewriteSortOrderForTableResizeArchive::has_new_sort_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRewriteSortOrderForTableResizeArchive::set_has_new_sort_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRewriteSortOrderForTableResizeArchive::clear_has_new_sort_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRewriteSortOrderForTableResizeArchive::clear_new_sort_order() {
  if (new_sort_order_ != NULL) new_sort_order_->::TST::TableSortOrderArchive::Clear();
  clear_has_new_sort_order();
}
inline const ::TST::TableSortOrderArchive& CommandRewriteSortOrderForTableResizeArchive::new_sort_order() const {
  return new_sort_order_ != NULL ? *new_sort_order_ : *default_instance_->new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTableResizeArchive::mutable_new_sort_order() {
  set_has_new_sort_order();
  if (new_sort_order_ == NULL) new_sort_order_ = new ::TST::TableSortOrderArchive;
  return new_sort_order_;
}
inline ::TST::TableSortOrderArchive* CommandRewriteSortOrderForTableResizeArchive::release_new_sort_order() {
  clear_has_new_sort_order();
  ::TST::TableSortOrderArchive* temp = new_sort_order_;
  new_sort_order_ = NULL;
  return temp;
}
inline void CommandRewriteSortOrderForTableResizeArchive::set_allocated_new_sort_order(::TST::TableSortOrderArchive* new_sort_order) {
  delete new_sort_order_;
  new_sort_order_ = new_sort_order;
  if (new_sort_order) {
    set_has_new_sort_order();
  } else {
    clear_has_new_sort_order();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TST

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::CommandDirectionArchive>() {
  return ::TST::CommandDirectionArchive_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::CommandRegionArchive>() {
  return ::TST::CommandRegionArchive_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSTCommandArchives_2eproto__INCLUDED
