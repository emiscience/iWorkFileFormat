// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDArchives.proto

#ifndef PROTOBUF_TSDArchives_2eproto__INCLUDED
#define PROTOBUF_TSDArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TSD {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSDArchives_2eproto();
void protobuf_AssignDesc_TSDArchives_2eproto();
void protobuf_ShutdownFile_TSDArchives_2eproto();

class EdgeInsetsArchive;
class GeometryArchive;
class PointPathSourceArchive;
class ScalarPathSourceArchive;
class BezierPathSourceArchive;
class CalloutPathSourceArchive;
class ConnectionLinePathSourceArchive;
class EditableBezierPathSourceArchive;
class EditableBezierPathSourceArchive_Node;
class EditableBezierPathSourceArchive_Subpath;
class PathSourceArchive;
class AngleGradientArchive;
class TransformGradientArchive;
class GradientArchive;
class GradientArchive_GradientStop;
class ImageFillArchive;
class FillArchive;
class StrokePatternArchive;
class StrokeArchive;
class SmartStrokeArchive;
class FrameArchive;
class PatternedStrokeArchive;
class LineEndArchive;
class ShadowArchive;
class DropShadowArchive;
class ContactShadowArchive;
class CurvedShadowArchive;
class ReflectionArchive;
class ImageAdjustmentsArchive;
class ShapeStylePropertiesArchive;
class ShapeStyleArchive;
class MediaStylePropertiesArchive;
class MediaStyleArchive;
class ThemePresetsArchive;
class ThemeReplaceFillPresetCommandArchive;
class DrawableArchive;
class ContainerArchive;
class GroupArchive;
class ShapeArchive;
class ConnectionLineArchive;
class ImageArchive;
class MaskArchive;
class MovieArchive;
class ExteriorTextWrapArchive;
class GuideArchive;
class UserDefinedGuideArchive;
class GuideStorageArchive;
class CanvasSelectionArchive;
class CommentStorageArchive;

enum PointPathSourceArchive_PointPathSourceType {
  PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow = 0,
  PointPathSourceArchive_PointPathSourceType_kTSDRightSingleArrow = 1,
  PointPathSourceArchive_PointPathSourceType_kTSDDoubleArrow = 10,
  PointPathSourceArchive_PointPathSourceType_kTSDStar = 100,
  PointPathSourceArchive_PointPathSourceType_kTSDPlus = 200
};
bool PointPathSourceArchive_PointPathSourceType_IsValid(int value);
const PointPathSourceArchive_PointPathSourceType PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MIN = PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow;
const PointPathSourceArchive_PointPathSourceType PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX = PointPathSourceArchive_PointPathSourceType_kTSDPlus;
const int PointPathSourceArchive_PointPathSourceType_PointPathSourceType_ARRAYSIZE = PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PointPathSourceArchive_PointPathSourceType_descriptor();
inline const ::std::string& PointPathSourceArchive_PointPathSourceType_Name(PointPathSourceArchive_PointPathSourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PointPathSourceArchive_PointPathSourceType_descriptor(), value);
}
inline bool PointPathSourceArchive_PointPathSourceType_Parse(
    const ::std::string& name, PointPathSourceArchive_PointPathSourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PointPathSourceArchive_PointPathSourceType>(
    PointPathSourceArchive_PointPathSourceType_descriptor(), name, value);
}
enum ScalarPathSourceArchive_ScalarPathSourceType {
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle = 0,
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDRegularPolygon = 1,
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron = 2
};
bool ScalarPathSourceArchive_ScalarPathSourceType_IsValid(int value);
const ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MIN = ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle;
const ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX = ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron;
const int ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_ARRAYSIZE = ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
inline const ::std::string& ScalarPathSourceArchive_ScalarPathSourceType_Name(ScalarPathSourceArchive_ScalarPathSourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScalarPathSourceArchive_ScalarPathSourceType_descriptor(), value);
}
inline bool ScalarPathSourceArchive_ScalarPathSourceType_Parse(
    const ::std::string& name, ScalarPathSourceArchive_ScalarPathSourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScalarPathSourceArchive_ScalarPathSourceType>(
    ScalarPathSourceArchive_ScalarPathSourceType_descriptor(), name, value);
}
enum ConnectionLinePathSourceArchive_ConnectionLinePathSourceType {
  ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic = 0,
  ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal = 1
};
bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(int value);
const ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MIN = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic;
const ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal;
const int ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_ARRAYSIZE = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
inline const ::std::string& ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name(ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor(), value);
}
inline bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Parse(
    const ::std::string& name, ConnectionLinePathSourceArchive_ConnectionLinePathSourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>(
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor(), name, value);
}
enum EditableBezierPathSourceArchive_NodeType {
  EditableBezierPathSourceArchive_NodeType_sharp = 1,
  EditableBezierPathSourceArchive_NodeType_bezier = 2,
  EditableBezierPathSourceArchive_NodeType_smooth = 3
};
bool EditableBezierPathSourceArchive_NodeType_IsValid(int value);
const EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_NodeType_NodeType_MIN = EditableBezierPathSourceArchive_NodeType_sharp;
const EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_NodeType_NodeType_MAX = EditableBezierPathSourceArchive_NodeType_smooth;
const int EditableBezierPathSourceArchive_NodeType_NodeType_ARRAYSIZE = EditableBezierPathSourceArchive_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EditableBezierPathSourceArchive_NodeType_descriptor();
inline const ::std::string& EditableBezierPathSourceArchive_NodeType_Name(EditableBezierPathSourceArchive_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EditableBezierPathSourceArchive_NodeType_descriptor(), value);
}
inline bool EditableBezierPathSourceArchive_NodeType_Parse(
    const ::std::string& name, EditableBezierPathSourceArchive_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EditableBezierPathSourceArchive_NodeType>(
    EditableBezierPathSourceArchive_NodeType_descriptor(), name, value);
}
enum GradientArchive_GradientType {
  GradientArchive_GradientType_Linear = 0,
  GradientArchive_GradientType_Radial = 1
};
bool GradientArchive_GradientType_IsValid(int value);
const GradientArchive_GradientType GradientArchive_GradientType_GradientType_MIN = GradientArchive_GradientType_Linear;
const GradientArchive_GradientType GradientArchive_GradientType_GradientType_MAX = GradientArchive_GradientType_Radial;
const int GradientArchive_GradientType_GradientType_ARRAYSIZE = GradientArchive_GradientType_GradientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GradientArchive_GradientType_descriptor();
inline const ::std::string& GradientArchive_GradientType_Name(GradientArchive_GradientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GradientArchive_GradientType_descriptor(), value);
}
inline bool GradientArchive_GradientType_Parse(
    const ::std::string& name, GradientArchive_GradientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GradientArchive_GradientType>(
    GradientArchive_GradientType_descriptor(), name, value);
}
enum ImageFillArchive_ImageFillTechnique {
  ImageFillArchive_ImageFillTechnique_NaturalSize = 0,
  ImageFillArchive_ImageFillTechnique_Stretch = 1,
  ImageFillArchive_ImageFillTechnique_Tile = 2,
  ImageFillArchive_ImageFillTechnique_ScaleToFill = 3,
  ImageFillArchive_ImageFillTechnique_ScaleToFit = 4
};
bool ImageFillArchive_ImageFillTechnique_IsValid(int value);
const ImageFillArchive_ImageFillTechnique ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MIN = ImageFillArchive_ImageFillTechnique_NaturalSize;
const ImageFillArchive_ImageFillTechnique ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX = ImageFillArchive_ImageFillTechnique_ScaleToFit;
const int ImageFillArchive_ImageFillTechnique_ImageFillTechnique_ARRAYSIZE = ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageFillArchive_ImageFillTechnique_descriptor();
inline const ::std::string& ImageFillArchive_ImageFillTechnique_Name(ImageFillArchive_ImageFillTechnique value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageFillArchive_ImageFillTechnique_descriptor(), value);
}
inline bool ImageFillArchive_ImageFillTechnique_Parse(
    const ::std::string& name, ImageFillArchive_ImageFillTechnique* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFillArchive_ImageFillTechnique>(
    ImageFillArchive_ImageFillTechnique_descriptor(), name, value);
}
enum StrokePatternArchive_StrokePatternType {
  StrokePatternArchive_StrokePatternType_TSDPattern = 0,
  StrokePatternArchive_StrokePatternType_TSDSolidPattern = 1,
  StrokePatternArchive_StrokePatternType_TSDEmptyPattern = 2
};
bool StrokePatternArchive_StrokePatternType_IsValid(int value);
const StrokePatternArchive_StrokePatternType StrokePatternArchive_StrokePatternType_StrokePatternType_MIN = StrokePatternArchive_StrokePatternType_TSDPattern;
const StrokePatternArchive_StrokePatternType StrokePatternArchive_StrokePatternType_StrokePatternType_MAX = StrokePatternArchive_StrokePatternType_TSDEmptyPattern;
const int StrokePatternArchive_StrokePatternType_StrokePatternType_ARRAYSIZE = StrokePatternArchive_StrokePatternType_StrokePatternType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrokePatternArchive_StrokePatternType_descriptor();
inline const ::std::string& StrokePatternArchive_StrokePatternType_Name(StrokePatternArchive_StrokePatternType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrokePatternArchive_StrokePatternType_descriptor(), value);
}
inline bool StrokePatternArchive_StrokePatternType_Parse(
    const ::std::string& name, StrokePatternArchive_StrokePatternType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokePatternArchive_StrokePatternType>(
    StrokePatternArchive_StrokePatternType_descriptor(), name, value);
}
enum StrokeArchive_LineCap {
  StrokeArchive_LineCap_ButtCap = 0,
  StrokeArchive_LineCap_RoundCap = 1,
  StrokeArchive_LineCap_SquareCap = 2
};
bool StrokeArchive_LineCap_IsValid(int value);
const StrokeArchive_LineCap StrokeArchive_LineCap_LineCap_MIN = StrokeArchive_LineCap_ButtCap;
const StrokeArchive_LineCap StrokeArchive_LineCap_LineCap_MAX = StrokeArchive_LineCap_SquareCap;
const int StrokeArchive_LineCap_LineCap_ARRAYSIZE = StrokeArchive_LineCap_LineCap_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrokeArchive_LineCap_descriptor();
inline const ::std::string& StrokeArchive_LineCap_Name(StrokeArchive_LineCap value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrokeArchive_LineCap_descriptor(), value);
}
inline bool StrokeArchive_LineCap_Parse(
    const ::std::string& name, StrokeArchive_LineCap* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeArchive_LineCap>(
    StrokeArchive_LineCap_descriptor(), name, value);
}
enum ShadowArchive_ShadowType {
  ShadowArchive_ShadowType_TSDDropShadow = 0,
  ShadowArchive_ShadowType_TSDContactShadow = 1,
  ShadowArchive_ShadowType_TSDCurvedShadow = 2
};
bool ShadowArchive_ShadowType_IsValid(int value);
const ShadowArchive_ShadowType ShadowArchive_ShadowType_ShadowType_MIN = ShadowArchive_ShadowType_TSDDropShadow;
const ShadowArchive_ShadowType ShadowArchive_ShadowType_ShadowType_MAX = ShadowArchive_ShadowType_TSDCurvedShadow;
const int ShadowArchive_ShadowType_ShadowType_ARRAYSIZE = ShadowArchive_ShadowType_ShadowType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShadowArchive_ShadowType_descriptor();
inline const ::std::string& ShadowArchive_ShadowType_Name(ShadowArchive_ShadowType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShadowArchive_ShadowType_descriptor(), value);
}
inline bool ShadowArchive_ShadowType_Parse(
    const ::std::string& name, ShadowArchive_ShadowType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShadowArchive_ShadowType>(
    ShadowArchive_ShadowType_descriptor(), name, value);
}
enum MovieArchive_MovieLoopOption {
  MovieArchive_MovieLoopOption_None = 0,
  MovieArchive_MovieLoopOption_Repeat = 1,
  MovieArchive_MovieLoopOption_BackAndForth = 2
};
bool MovieArchive_MovieLoopOption_IsValid(int value);
const MovieArchive_MovieLoopOption MovieArchive_MovieLoopOption_MovieLoopOption_MIN = MovieArchive_MovieLoopOption_None;
const MovieArchive_MovieLoopOption MovieArchive_MovieLoopOption_MovieLoopOption_MAX = MovieArchive_MovieLoopOption_BackAndForth;
const int MovieArchive_MovieLoopOption_MovieLoopOption_ARRAYSIZE = MovieArchive_MovieLoopOption_MovieLoopOption_MAX + 1;

const ::google::protobuf::EnumDescriptor* MovieArchive_MovieLoopOption_descriptor();
inline const ::std::string& MovieArchive_MovieLoopOption_Name(MovieArchive_MovieLoopOption value) {
  return ::google::protobuf::internal::NameOfEnum(
    MovieArchive_MovieLoopOption_descriptor(), value);
}
inline bool MovieArchive_MovieLoopOption_Parse(
    const ::std::string& name, MovieArchive_MovieLoopOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovieArchive_MovieLoopOption>(
    MovieArchive_MovieLoopOption_descriptor(), name, value);
}
enum GuideArchive_GuideType {
  GuideArchive_GuideType_Horizontal = 0,
  GuideArchive_GuideType_Vertical = 1
};
bool GuideArchive_GuideType_IsValid(int value);
const GuideArchive_GuideType GuideArchive_GuideType_GuideType_MIN = GuideArchive_GuideType_Horizontal;
const GuideArchive_GuideType GuideArchive_GuideType_GuideType_MAX = GuideArchive_GuideType_Vertical;
const int GuideArchive_GuideType_GuideType_ARRAYSIZE = GuideArchive_GuideType_GuideType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuideArchive_GuideType_descriptor();
inline const ::std::string& GuideArchive_GuideType_Name(GuideArchive_GuideType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuideArchive_GuideType_descriptor(), value);
}
inline bool GuideArchive_GuideType_Parse(
    const ::std::string& name, GuideArchive_GuideType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuideArchive_GuideType>(
    GuideArchive_GuideType_descriptor(), name, value);
}
enum UserDefinedGuideArchive_GuideType {
  UserDefinedGuideArchive_GuideType_Horizontal = 0,
  UserDefinedGuideArchive_GuideType_Vertical = 1
};
bool UserDefinedGuideArchive_GuideType_IsValid(int value);
const UserDefinedGuideArchive_GuideType UserDefinedGuideArchive_GuideType_GuideType_MIN = UserDefinedGuideArchive_GuideType_Horizontal;
const UserDefinedGuideArchive_GuideType UserDefinedGuideArchive_GuideType_GuideType_MAX = UserDefinedGuideArchive_GuideType_Vertical;
const int UserDefinedGuideArchive_GuideType_GuideType_ARRAYSIZE = UserDefinedGuideArchive_GuideType_GuideType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserDefinedGuideArchive_GuideType_descriptor();
inline const ::std::string& UserDefinedGuideArchive_GuideType_Name(UserDefinedGuideArchive_GuideType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserDefinedGuideArchive_GuideType_descriptor(), value);
}
inline bool UserDefinedGuideArchive_GuideType_Parse(
    const ::std::string& name, UserDefinedGuideArchive_GuideType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserDefinedGuideArchive_GuideType>(
    UserDefinedGuideArchive_GuideType_descriptor(), name, value);
}
enum LineJoin {
  MiterJoin = 0,
  RoundJoin = 1,
  BevelJoin = 2
};
bool LineJoin_IsValid(int value);
const LineJoin LineJoin_MIN = MiterJoin;
const LineJoin LineJoin_MAX = BevelJoin;
const int LineJoin_ARRAYSIZE = LineJoin_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineJoin_descriptor();
inline const ::std::string& LineJoin_Name(LineJoin value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineJoin_descriptor(), value);
}
inline bool LineJoin_Parse(
    const ::std::string& name, LineJoin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineJoin>(
    LineJoin_descriptor(), name, value);
}
// ===================================================================

class EdgeInsetsArchive : public ::google::protobuf::Message {
 public:
  EdgeInsetsArchive();
  virtual ~EdgeInsetsArchive();

  EdgeInsetsArchive(const EdgeInsetsArchive& from);

  inline EdgeInsetsArchive& operator=(const EdgeInsetsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeInsetsArchive& default_instance();

  void Swap(EdgeInsetsArchive* other);

  // implements Message ----------------------------------------------

  EdgeInsetsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgeInsetsArchive& from);
  void MergeFrom(const EdgeInsetsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float top = 1;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 1;
  inline float top() const;
  inline void set_top(float value);

  // required float left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline float left() const;
  inline void set_left(float value);

  // required float bottom = 3;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 3;
  inline float bottom() const;
  inline void set_bottom(float value);

  // required float right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline float right() const;
  inline void set_right(float value);

  // @@protoc_insertion_point(class_scope:TSD.EdgeInsetsArchive)
 private:
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_right();
  inline void clear_has_right();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float top_;
  float left_;
  float bottom_;
  float right_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static EdgeInsetsArchive* default_instance_;
};
// -------------------------------------------------------------------

class GeometryArchive : public ::google::protobuf::Message {
 public:
  GeometryArchive();
  virtual ~GeometryArchive();

  GeometryArchive(const GeometryArchive& from);

  inline GeometryArchive& operator=(const GeometryArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeometryArchive& default_instance();

  void Swap(GeometryArchive* other);

  // implements Message ----------------------------------------------

  GeometryArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeometryArchive& from);
  void MergeFrom(const GeometryArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Point position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::TSP::Point& position() const;
  inline ::TSP::Point* mutable_position();
  inline ::TSP::Point* release_position();
  inline void set_allocated_position(::TSP::Point* position);

  // optional .TSP.Size size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::TSP::Size& size() const;
  inline ::TSP::Size* mutable_size();
  inline ::TSP::Size* release_size();
  inline void set_allocated_size(::TSP::Size* size);

  // optional uint32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional float angle = 4;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 4;
  inline float angle() const;
  inline void set_angle(float value);

  // @@protoc_insertion_point(class_scope:TSD.GeometryArchive)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Point* position_;
  ::TSP::Size* size_;
  ::google::protobuf::uint32 flags_;
  float angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static GeometryArchive* default_instance_;
};
// -------------------------------------------------------------------

class PointPathSourceArchive : public ::google::protobuf::Message {
 public:
  PointPathSourceArchive();
  virtual ~PointPathSourceArchive();

  PointPathSourceArchive(const PointPathSourceArchive& from);

  inline PointPathSourceArchive& operator=(const PointPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointPathSourceArchive& default_instance();

  void Swap(PointPathSourceArchive* other);

  // implements Message ----------------------------------------------

  PointPathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointPathSourceArchive& from);
  void MergeFrom(const PointPathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PointPathSourceArchive_PointPathSourceType PointPathSourceType;
  static const PointPathSourceType kTSDLeftSingleArrow = PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow;
  static const PointPathSourceType kTSDRightSingleArrow = PointPathSourceArchive_PointPathSourceType_kTSDRightSingleArrow;
  static const PointPathSourceType kTSDDoubleArrow = PointPathSourceArchive_PointPathSourceType_kTSDDoubleArrow;
  static const PointPathSourceType kTSDStar = PointPathSourceArchive_PointPathSourceType_kTSDStar;
  static const PointPathSourceType kTSDPlus = PointPathSourceArchive_PointPathSourceType_kTSDPlus;
  static inline bool PointPathSourceType_IsValid(int value) {
    return PointPathSourceArchive_PointPathSourceType_IsValid(value);
  }
  static const PointPathSourceType PointPathSourceType_MIN =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MIN;
  static const PointPathSourceType PointPathSourceType_MAX =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX;
  static const int PointPathSourceType_ARRAYSIZE =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PointPathSourceType_descriptor() {
    return PointPathSourceArchive_PointPathSourceType_descriptor();
  }
  static inline const ::std::string& PointPathSourceType_Name(PointPathSourceType value) {
    return PointPathSourceArchive_PointPathSourceType_Name(value);
  }
  static inline bool PointPathSourceType_Parse(const ::std::string& name,
      PointPathSourceType* value) {
    return PointPathSourceArchive_PointPathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSD::PointPathSourceArchive_PointPathSourceType type() const;
  inline void set_type(::TSD::PointPathSourceArchive_PointPathSourceType value);

  // optional .TSP.Point point = 2;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 2;
  inline const ::TSP::Point& point() const;
  inline ::TSP::Point* mutable_point();
  inline ::TSP::Point* release_point();
  inline void set_allocated_point(::TSP::Point* point);

  // optional .TSP.Size naturalSize = 3;
  inline bool has_naturalsize() const;
  inline void clear_naturalsize();
  static const int kNaturalSizeFieldNumber = 3;
  inline const ::TSP::Size& naturalsize() const;
  inline ::TSP::Size* mutable_naturalsize();
  inline ::TSP::Size* release_naturalsize();
  inline void set_allocated_naturalsize(::TSP::Size* naturalsize);

  // @@protoc_insertion_point(class_scope:TSD.PointPathSourceArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_naturalsize();
  inline void clear_has_naturalsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Point* point_;
  ::TSP::Size* naturalsize_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static PointPathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class ScalarPathSourceArchive : public ::google::protobuf::Message {
 public:
  ScalarPathSourceArchive();
  virtual ~ScalarPathSourceArchive();

  ScalarPathSourceArchive(const ScalarPathSourceArchive& from);

  inline ScalarPathSourceArchive& operator=(const ScalarPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScalarPathSourceArchive& default_instance();

  void Swap(ScalarPathSourceArchive* other);

  // implements Message ----------------------------------------------

  ScalarPathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScalarPathSourceArchive& from);
  void MergeFrom(const ScalarPathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceType;
  static const ScalarPathSourceType kTSDRoundedRectangle = ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle;
  static const ScalarPathSourceType kTSDRegularPolygon = ScalarPathSourceArchive_ScalarPathSourceType_kTSDRegularPolygon;
  static const ScalarPathSourceType kTSDChevron = ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron;
  static inline bool ScalarPathSourceType_IsValid(int value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_IsValid(value);
  }
  static const ScalarPathSourceType ScalarPathSourceType_MIN =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MIN;
  static const ScalarPathSourceType ScalarPathSourceType_MAX =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX;
  static const int ScalarPathSourceType_ARRAYSIZE =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScalarPathSourceType_descriptor() {
    return ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
  }
  static inline const ::std::string& ScalarPathSourceType_Name(ScalarPathSourceType value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_Name(value);
  }
  static inline bool ScalarPathSourceType_Parse(const ::std::string& name,
      ScalarPathSourceType* value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSD::ScalarPathSourceArchive_ScalarPathSourceType type() const;
  inline void set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value);

  // optional float scalar = 2;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 2;
  inline float scalar() const;
  inline void set_scalar(float value);

  // optional .TSP.Size naturalSize = 3;
  inline bool has_naturalsize() const;
  inline void clear_naturalsize();
  static const int kNaturalSizeFieldNumber = 3;
  inline const ::TSP::Size& naturalsize() const;
  inline ::TSP::Size* mutable_naturalsize();
  inline ::TSP::Size* release_naturalsize();
  inline void set_allocated_naturalsize(::TSP::Size* naturalsize);

  // @@protoc_insertion_point(class_scope:TSD.ScalarPathSourceArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_naturalsize();
  inline void clear_has_naturalsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float scalar_;
  ::TSP::Size* naturalsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ScalarPathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class BezierPathSourceArchive : public ::google::protobuf::Message {
 public:
  BezierPathSourceArchive();
  virtual ~BezierPathSourceArchive();

  BezierPathSourceArchive(const BezierPathSourceArchive& from);

  inline BezierPathSourceArchive& operator=(const BezierPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BezierPathSourceArchive& default_instance();

  void Swap(BezierPathSourceArchive* other);

  // implements Message ----------------------------------------------

  BezierPathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BezierPathSourceArchive& from);
  void MergeFrom(const BezierPathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path_string = 1 [deprecated = true];
  inline bool has_path_string() const PROTOBUF_DEPRECATED;
  inline void clear_path_string() PROTOBUF_DEPRECATED;
  static const int kPathStringFieldNumber = 1;
  inline const ::std::string& path_string() const PROTOBUF_DEPRECATED;
  inline void set_path_string(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_path_string(const char* value) PROTOBUF_DEPRECATED;
  inline void set_path_string(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_path_string() PROTOBUF_DEPRECATED;
  inline ::std::string* release_path_string() PROTOBUF_DEPRECATED;
  inline void set_allocated_path_string(::std::string* path_string) PROTOBUF_DEPRECATED;

  // optional .TSP.Size naturalSize = 2;
  inline bool has_naturalsize() const;
  inline void clear_naturalsize();
  static const int kNaturalSizeFieldNumber = 2;
  inline const ::TSP::Size& naturalsize() const;
  inline ::TSP::Size* mutable_naturalsize();
  inline ::TSP::Size* release_naturalsize();
  inline void set_allocated_naturalsize(::TSP::Size* naturalsize);

  // optional .TSP.Path path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::TSP::Path& path() const;
  inline ::TSP::Path* mutable_path();
  inline ::TSP::Path* release_path();
  inline void set_allocated_path(::TSP::Path* path);

  // @@protoc_insertion_point(class_scope:TSD.BezierPathSourceArchive)
 private:
  inline void set_has_path_string();
  inline void clear_has_path_string();
  inline void set_has_naturalsize();
  inline void clear_has_naturalsize();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_string_;
  ::TSP::Size* naturalsize_;
  ::TSP::Path* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static BezierPathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class CalloutPathSourceArchive : public ::google::protobuf::Message {
 public:
  CalloutPathSourceArchive();
  virtual ~CalloutPathSourceArchive();

  CalloutPathSourceArchive(const CalloutPathSourceArchive& from);

  inline CalloutPathSourceArchive& operator=(const CalloutPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalloutPathSourceArchive& default_instance();

  void Swap(CalloutPathSourceArchive* other);

  // implements Message ----------------------------------------------

  CalloutPathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalloutPathSourceArchive& from);
  void MergeFrom(const CalloutPathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Size natural_size = 1;
  inline bool has_natural_size() const;
  inline void clear_natural_size();
  static const int kNaturalSizeFieldNumber = 1;
  inline const ::TSP::Size& natural_size() const;
  inline ::TSP::Size* mutable_natural_size();
  inline ::TSP::Size* release_natural_size();
  inline void set_allocated_natural_size(::TSP::Size* natural_size);

  // optional .TSP.Point tail_position = 2;
  inline bool has_tail_position() const;
  inline void clear_tail_position();
  static const int kTailPositionFieldNumber = 2;
  inline const ::TSP::Point& tail_position() const;
  inline ::TSP::Point* mutable_tail_position();
  inline ::TSP::Point* release_tail_position();
  inline void set_allocated_tail_position(::TSP::Point* tail_position);

  // optional float tail_size = 3;
  inline bool has_tail_size() const;
  inline void clear_tail_size();
  static const int kTailSizeFieldNumber = 3;
  inline float tail_size() const;
  inline void set_tail_size(float value);

  // optional float corner_radius = 4;
  inline bool has_corner_radius() const;
  inline void clear_corner_radius();
  static const int kCornerRadiusFieldNumber = 4;
  inline float corner_radius() const;
  inline void set_corner_radius(float value);

  // optional bool center_tail = 5;
  inline bool has_center_tail() const;
  inline void clear_center_tail();
  static const int kCenterTailFieldNumber = 5;
  inline bool center_tail() const;
  inline void set_center_tail(bool value);

  // @@protoc_insertion_point(class_scope:TSD.CalloutPathSourceArchive)
 private:
  inline void set_has_natural_size();
  inline void clear_has_natural_size();
  inline void set_has_tail_position();
  inline void clear_has_tail_position();
  inline void set_has_tail_size();
  inline void clear_has_tail_size();
  inline void set_has_corner_radius();
  inline void clear_has_corner_radius();
  inline void set_has_center_tail();
  inline void clear_has_center_tail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Size* natural_size_;
  ::TSP::Point* tail_position_;
  float tail_size_;
  float corner_radius_;
  bool center_tail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static CalloutPathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionLinePathSourceArchive : public ::google::protobuf::Message {
 public:
  ConnectionLinePathSourceArchive();
  virtual ~ConnectionLinePathSourceArchive();

  ConnectionLinePathSourceArchive(const ConnectionLinePathSourceArchive& from);

  inline ConnectionLinePathSourceArchive& operator=(const ConnectionLinePathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionLinePathSourceArchive& default_instance();

  void Swap(ConnectionLinePathSourceArchive* other);

  // implements Message ----------------------------------------------

  ConnectionLinePathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionLinePathSourceArchive& from);
  void MergeFrom(const ConnectionLinePathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceType;
  static const ConnectionLinePathSourceType kTSDConnectionLineTypeQuadratic = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic;
  static const ConnectionLinePathSourceType kTSDConnectionLineTypeOrthogonal = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal;
  static inline bool ConnectionLinePathSourceType_IsValid(int value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(value);
  }
  static const ConnectionLinePathSourceType ConnectionLinePathSourceType_MIN =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MIN;
  static const ConnectionLinePathSourceType ConnectionLinePathSourceType_MAX =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX;
  static const int ConnectionLinePathSourceType_ARRAYSIZE =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ConnectionLinePathSourceType_descriptor() {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
  }
  static inline const ::std::string& ConnectionLinePathSourceType_Name(ConnectionLinePathSourceType value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name(value);
  }
  static inline bool ConnectionLinePathSourceType_Parse(const ::std::string& name,
      ConnectionLinePathSourceType* value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSD.BezierPathSourceArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::BezierPathSourceArchive& super() const;
  inline ::TSD::BezierPathSourceArchive* mutable_super();
  inline ::TSD::BezierPathSourceArchive* release_super();
  inline void set_allocated_super(::TSD::BezierPathSourceArchive* super);

  // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType type() const;
  inline void set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value);

  // optional float outset_from = 3;
  inline bool has_outset_from() const;
  inline void clear_outset_from();
  static const int kOutsetFromFieldNumber = 3;
  inline float outset_from() const;
  inline void set_outset_from(float value);

  // optional float outset_to = 4;
  inline bool has_outset_to() const;
  inline void clear_outset_to();
  static const int kOutsetToFieldNumber = 4;
  inline float outset_to() const;
  inline void set_outset_to(float value);

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLinePathSourceArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_outset_from();
  inline void clear_has_outset_from();
  inline void set_has_outset_to();
  inline void clear_has_outset_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::BezierPathSourceArchive* super_;
  int type_;
  float outset_from_;
  float outset_to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ConnectionLinePathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive_Node : public ::google::protobuf::Message {
 public:
  EditableBezierPathSourceArchive_Node();
  virtual ~EditableBezierPathSourceArchive_Node();

  EditableBezierPathSourceArchive_Node(const EditableBezierPathSourceArchive_Node& from);

  inline EditableBezierPathSourceArchive_Node& operator=(const EditableBezierPathSourceArchive_Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditableBezierPathSourceArchive_Node& default_instance();

  void Swap(EditableBezierPathSourceArchive_Node* other);

  // implements Message ----------------------------------------------

  EditableBezierPathSourceArchive_Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditableBezierPathSourceArchive_Node& from);
  void MergeFrom(const EditableBezierPathSourceArchive_Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Point inControlPoint = 1;
  inline bool has_incontrolpoint() const;
  inline void clear_incontrolpoint();
  static const int kInControlPointFieldNumber = 1;
  inline const ::TSP::Point& incontrolpoint() const;
  inline ::TSP::Point* mutable_incontrolpoint();
  inline ::TSP::Point* release_incontrolpoint();
  inline void set_allocated_incontrolpoint(::TSP::Point* incontrolpoint);

  // required .TSP.Point nodePoint = 2;
  inline bool has_nodepoint() const;
  inline void clear_nodepoint();
  static const int kNodePointFieldNumber = 2;
  inline const ::TSP::Point& nodepoint() const;
  inline ::TSP::Point* mutable_nodepoint();
  inline ::TSP::Point* release_nodepoint();
  inline void set_allocated_nodepoint(::TSP::Point* nodepoint);

  // required .TSP.Point outControlPoint = 3;
  inline bool has_outcontrolpoint() const;
  inline void clear_outcontrolpoint();
  static const int kOutControlPointFieldNumber = 3;
  inline const ::TSP::Point& outcontrolpoint() const;
  inline ::TSP::Point* mutable_outcontrolpoint();
  inline ::TSP::Point* release_outcontrolpoint();
  inline void set_allocated_outcontrolpoint(::TSP::Point* outcontrolpoint);

  // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::TSD::EditableBezierPathSourceArchive_NodeType type() const;
  inline void set_type(::TSD::EditableBezierPathSourceArchive_NodeType value);

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive.Node)
 private:
  inline void set_has_incontrolpoint();
  inline void clear_has_incontrolpoint();
  inline void set_has_nodepoint();
  inline void clear_has_nodepoint();
  inline void set_has_outcontrolpoint();
  inline void clear_has_outcontrolpoint();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Point* incontrolpoint_;
  ::TSP::Point* nodepoint_;
  ::TSP::Point* outcontrolpoint_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static EditableBezierPathSourceArchive_Node* default_instance_;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive_Subpath : public ::google::protobuf::Message {
 public:
  EditableBezierPathSourceArchive_Subpath();
  virtual ~EditableBezierPathSourceArchive_Subpath();

  EditableBezierPathSourceArchive_Subpath(const EditableBezierPathSourceArchive_Subpath& from);

  inline EditableBezierPathSourceArchive_Subpath& operator=(const EditableBezierPathSourceArchive_Subpath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditableBezierPathSourceArchive_Subpath& default_instance();

  void Swap(EditableBezierPathSourceArchive_Subpath* other);

  // implements Message ----------------------------------------------

  EditableBezierPathSourceArchive_Subpath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditableBezierPathSourceArchive_Subpath& from);
  void MergeFrom(const EditableBezierPathSourceArchive_Subpath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::TSD::EditableBezierPathSourceArchive_Node& nodes(int index) const;
  inline ::TSD::EditableBezierPathSourceArchive_Node* mutable_nodes(int index);
  inline ::TSD::EditableBezierPathSourceArchive_Node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >*
      mutable_nodes();

  // required bool closed = 2;
  inline bool has_closed() const;
  inline void clear_closed();
  static const int kClosedFieldNumber = 2;
  inline bool closed() const;
  inline void set_closed(bool value);

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive.Subpath)
 private:
  inline void set_has_closed();
  inline void clear_has_closed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node > nodes_;
  bool closed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static EditableBezierPathSourceArchive_Subpath* default_instance_;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive : public ::google::protobuf::Message {
 public:
  EditableBezierPathSourceArchive();
  virtual ~EditableBezierPathSourceArchive();

  EditableBezierPathSourceArchive(const EditableBezierPathSourceArchive& from);

  inline EditableBezierPathSourceArchive& operator=(const EditableBezierPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EditableBezierPathSourceArchive& default_instance();

  void Swap(EditableBezierPathSourceArchive* other);

  // implements Message ----------------------------------------------

  EditableBezierPathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EditableBezierPathSourceArchive& from);
  void MergeFrom(const EditableBezierPathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EditableBezierPathSourceArchive_Node Node;
  typedef EditableBezierPathSourceArchive_Subpath Subpath;

  typedef EditableBezierPathSourceArchive_NodeType NodeType;
  static const NodeType sharp = EditableBezierPathSourceArchive_NodeType_sharp;
  static const NodeType bezier = EditableBezierPathSourceArchive_NodeType_bezier;
  static const NodeType smooth = EditableBezierPathSourceArchive_NodeType_smooth;
  static inline bool NodeType_IsValid(int value) {
    return EditableBezierPathSourceArchive_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    EditableBezierPathSourceArchive_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    EditableBezierPathSourceArchive_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    EditableBezierPathSourceArchive_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return EditableBezierPathSourceArchive_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return EditableBezierPathSourceArchive_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return EditableBezierPathSourceArchive_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  inline int subpaths_size() const;
  inline void clear_subpaths();
  static const int kSubpathsFieldNumber = 1;
  inline const ::TSD::EditableBezierPathSourceArchive_Subpath& subpaths(int index) const;
  inline ::TSD::EditableBezierPathSourceArchive_Subpath* mutable_subpaths(int index);
  inline ::TSD::EditableBezierPathSourceArchive_Subpath* add_subpaths();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >&
      subpaths() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >*
      mutable_subpaths();

  // optional .TSP.Size naturalSize = 2;
  inline bool has_naturalsize() const;
  inline void clear_naturalsize();
  static const int kNaturalSizeFieldNumber = 2;
  inline const ::TSP::Size& naturalsize() const;
  inline ::TSP::Size* mutable_naturalsize();
  inline ::TSP::Size* release_naturalsize();
  inline void set_allocated_naturalsize(::TSP::Size* naturalsize);

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive)
 private:
  inline void set_has_naturalsize();
  inline void clear_has_naturalsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath > subpaths_;
  ::TSP::Size* naturalsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static EditableBezierPathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class PathSourceArchive : public ::google::protobuf::Message {
 public:
  PathSourceArchive();
  virtual ~PathSourceArchive();

  PathSourceArchive(const PathSourceArchive& from);

  inline PathSourceArchive& operator=(const PathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathSourceArchive& default_instance();

  void Swap(PathSourceArchive* other);

  // implements Message ----------------------------------------------

  PathSourceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathSourceArchive& from);
  void MergeFrom(const PathSourceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool horizontalFlip = 1;
  inline bool has_horizontalflip() const;
  inline void clear_horizontalflip();
  static const int kHorizontalFlipFieldNumber = 1;
  inline bool horizontalflip() const;
  inline void set_horizontalflip(bool value);

  // optional bool verticalFlip = 2;
  inline bool has_verticalflip() const;
  inline void clear_verticalflip();
  static const int kVerticalFlipFieldNumber = 2;
  inline bool verticalflip() const;
  inline void set_verticalflip(bool value);

  // optional .TSD.PointPathSourceArchive point_path_source = 3;
  inline bool has_point_path_source() const;
  inline void clear_point_path_source();
  static const int kPointPathSourceFieldNumber = 3;
  inline const ::TSD::PointPathSourceArchive& point_path_source() const;
  inline ::TSD::PointPathSourceArchive* mutable_point_path_source();
  inline ::TSD::PointPathSourceArchive* release_point_path_source();
  inline void set_allocated_point_path_source(::TSD::PointPathSourceArchive* point_path_source);

  // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
  inline bool has_scalar_path_source() const;
  inline void clear_scalar_path_source();
  static const int kScalarPathSourceFieldNumber = 4;
  inline const ::TSD::ScalarPathSourceArchive& scalar_path_source() const;
  inline ::TSD::ScalarPathSourceArchive* mutable_scalar_path_source();
  inline ::TSD::ScalarPathSourceArchive* release_scalar_path_source();
  inline void set_allocated_scalar_path_source(::TSD::ScalarPathSourceArchive* scalar_path_source);

  // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
  inline bool has_bezier_path_source() const;
  inline void clear_bezier_path_source();
  static const int kBezierPathSourceFieldNumber = 5;
  inline const ::TSD::BezierPathSourceArchive& bezier_path_source() const;
  inline ::TSD::BezierPathSourceArchive* mutable_bezier_path_source();
  inline ::TSD::BezierPathSourceArchive* release_bezier_path_source();
  inline void set_allocated_bezier_path_source(::TSD::BezierPathSourceArchive* bezier_path_source);

  // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
  inline bool has_callout_path_source() const;
  inline void clear_callout_path_source();
  static const int kCalloutPathSourceFieldNumber = 6;
  inline const ::TSD::CalloutPathSourceArchive& callout_path_source() const;
  inline ::TSD::CalloutPathSourceArchive* mutable_callout_path_source();
  inline ::TSD::CalloutPathSourceArchive* release_callout_path_source();
  inline void set_allocated_callout_path_source(::TSD::CalloutPathSourceArchive* callout_path_source);

  // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
  inline bool has_connection_line_path_source() const;
  inline void clear_connection_line_path_source();
  static const int kConnectionLinePathSourceFieldNumber = 7;
  inline const ::TSD::ConnectionLinePathSourceArchive& connection_line_path_source() const;
  inline ::TSD::ConnectionLinePathSourceArchive* mutable_connection_line_path_source();
  inline ::TSD::ConnectionLinePathSourceArchive* release_connection_line_path_source();
  inline void set_allocated_connection_line_path_source(::TSD::ConnectionLinePathSourceArchive* connection_line_path_source);

  // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
  inline bool has_editable_bezier_path_source() const;
  inline void clear_editable_bezier_path_source();
  static const int kEditableBezierPathSourceFieldNumber = 8;
  inline const ::TSD::EditableBezierPathSourceArchive& editable_bezier_path_source() const;
  inline ::TSD::EditableBezierPathSourceArchive* mutable_editable_bezier_path_source();
  inline ::TSD::EditableBezierPathSourceArchive* release_editable_bezier_path_source();
  inline void set_allocated_editable_bezier_path_source(::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source);

  // @@protoc_insertion_point(class_scope:TSD.PathSourceArchive)
 private:
  inline void set_has_horizontalflip();
  inline void clear_has_horizontalflip();
  inline void set_has_verticalflip();
  inline void clear_has_verticalflip();
  inline void set_has_point_path_source();
  inline void clear_has_point_path_source();
  inline void set_has_scalar_path_source();
  inline void clear_has_scalar_path_source();
  inline void set_has_bezier_path_source();
  inline void clear_has_bezier_path_source();
  inline void set_has_callout_path_source();
  inline void clear_has_callout_path_source();
  inline void set_has_connection_line_path_source();
  inline void clear_has_connection_line_path_source();
  inline void set_has_editable_bezier_path_source();
  inline void clear_has_editable_bezier_path_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::PointPathSourceArchive* point_path_source_;
  ::TSD::ScalarPathSourceArchive* scalar_path_source_;
  ::TSD::BezierPathSourceArchive* bezier_path_source_;
  ::TSD::CalloutPathSourceArchive* callout_path_source_;
  ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source_;
  ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source_;
  bool horizontalflip_;
  bool verticalflip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static PathSourceArchive* default_instance_;
};
// -------------------------------------------------------------------

class AngleGradientArchive : public ::google::protobuf::Message {
 public:
  AngleGradientArchive();
  virtual ~AngleGradientArchive();

  AngleGradientArchive(const AngleGradientArchive& from);

  inline AngleGradientArchive& operator=(const AngleGradientArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AngleGradientArchive& default_instance();

  void Swap(AngleGradientArchive* other);

  // implements Message ----------------------------------------------

  AngleGradientArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AngleGradientArchive& from);
  void MergeFrom(const AngleGradientArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float gradientangle = 2;
  inline bool has_gradientangle() const;
  inline void clear_gradientangle();
  static const int kGradientangleFieldNumber = 2;
  inline float gradientangle() const;
  inline void set_gradientangle(float value);

  // @@protoc_insertion_point(class_scope:TSD.AngleGradientArchive)
 private:
  inline void set_has_gradientangle();
  inline void clear_has_gradientangle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float gradientangle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static AngleGradientArchive* default_instance_;
};
// -------------------------------------------------------------------

class TransformGradientArchive : public ::google::protobuf::Message {
 public:
  TransformGradientArchive();
  virtual ~TransformGradientArchive();

  TransformGradientArchive(const TransformGradientArchive& from);

  inline TransformGradientArchive& operator=(const TransformGradientArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformGradientArchive& default_instance();

  void Swap(TransformGradientArchive* other);

  // implements Message ----------------------------------------------

  TransformGradientArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransformGradientArchive& from);
  void MergeFrom(const TransformGradientArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Point start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::TSP::Point& start() const;
  inline ::TSP::Point* mutable_start();
  inline ::TSP::Point* release_start();
  inline void set_allocated_start(::TSP::Point* start);

  // optional .TSP.Point end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::TSP::Point& end() const;
  inline ::TSP::Point* mutable_end();
  inline ::TSP::Point* release_end();
  inline void set_allocated_end(::TSP::Point* end);

  // optional .TSP.Size baseNaturalSize = 3;
  inline bool has_basenaturalsize() const;
  inline void clear_basenaturalsize();
  static const int kBaseNaturalSizeFieldNumber = 3;
  inline const ::TSP::Size& basenaturalsize() const;
  inline ::TSP::Size* mutable_basenaturalsize();
  inline ::TSP::Size* release_basenaturalsize();
  inline void set_allocated_basenaturalsize(::TSP::Size* basenaturalsize);

  // @@protoc_insertion_point(class_scope:TSD.TransformGradientArchive)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_basenaturalsize();
  inline void clear_has_basenaturalsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Point* start_;
  ::TSP::Point* end_;
  ::TSP::Size* basenaturalsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static TransformGradientArchive* default_instance_;
};
// -------------------------------------------------------------------

class GradientArchive_GradientStop : public ::google::protobuf::Message {
 public:
  GradientArchive_GradientStop();
  virtual ~GradientArchive_GradientStop();

  GradientArchive_GradientStop(const GradientArchive_GradientStop& from);

  inline GradientArchive_GradientStop& operator=(const GradientArchive_GradientStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GradientArchive_GradientStop& default_instance();

  void Swap(GradientArchive_GradientStop* other);

  // implements Message ----------------------------------------------

  GradientArchive_GradientStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GradientArchive_GradientStop& from);
  void MergeFrom(const GradientArchive_GradientStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Color color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // optional float fraction = 2;
  inline bool has_fraction() const;
  inline void clear_fraction();
  static const int kFractionFieldNumber = 2;
  inline float fraction() const;
  inline void set_fraction(float value);

  // optional float inflection = 3;
  inline bool has_inflection() const;
  inline void clear_inflection();
  static const int kInflectionFieldNumber = 3;
  inline float inflection() const;
  inline void set_inflection(float value);

  // @@protoc_insertion_point(class_scope:TSD.GradientArchive.GradientStop)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_fraction();
  inline void clear_has_fraction();
  inline void set_has_inflection();
  inline void clear_has_inflection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Color* color_;
  float fraction_;
  float inflection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static GradientArchive_GradientStop* default_instance_;
};
// -------------------------------------------------------------------

class GradientArchive : public ::google::protobuf::Message {
 public:
  GradientArchive();
  virtual ~GradientArchive();

  GradientArchive(const GradientArchive& from);

  inline GradientArchive& operator=(const GradientArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GradientArchive& default_instance();

  void Swap(GradientArchive* other);

  // implements Message ----------------------------------------------

  GradientArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GradientArchive& from);
  void MergeFrom(const GradientArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GradientArchive_GradientStop GradientStop;

  typedef GradientArchive_GradientType GradientType;
  static const GradientType Linear = GradientArchive_GradientType_Linear;
  static const GradientType Radial = GradientArchive_GradientType_Radial;
  static inline bool GradientType_IsValid(int value) {
    return GradientArchive_GradientType_IsValid(value);
  }
  static const GradientType GradientType_MIN =
    GradientArchive_GradientType_GradientType_MIN;
  static const GradientType GradientType_MAX =
    GradientArchive_GradientType_GradientType_MAX;
  static const int GradientType_ARRAYSIZE =
    GradientArchive_GradientType_GradientType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GradientType_descriptor() {
    return GradientArchive_GradientType_descriptor();
  }
  static inline const ::std::string& GradientType_Name(GradientType value) {
    return GradientArchive_GradientType_Name(value);
  }
  static inline bool GradientType_Parse(const ::std::string& name,
      GradientType* value) {
    return GradientArchive_GradientType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSD.GradientArchive.GradientType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSD::GradientArchive_GradientType type() const;
  inline void set_type(::TSD::GradientArchive_GradientType value);

  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  inline int stops_size() const;
  inline void clear_stops();
  static const int kStopsFieldNumber = 2;
  inline const ::TSD::GradientArchive_GradientStop& stops(int index) const;
  inline ::TSD::GradientArchive_GradientStop* mutable_stops(int index);
  inline ::TSD::GradientArchive_GradientStop* add_stops();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >&
      stops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >*
      mutable_stops();

  // optional float opacity = 3;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 3;
  inline float opacity() const;
  inline void set_opacity(float value);

  // optional bool advancedGradient = 4;
  inline bool has_advancedgradient() const;
  inline void clear_advancedgradient();
  static const int kAdvancedGradientFieldNumber = 4;
  inline bool advancedgradient() const;
  inline void set_advancedgradient(bool value);

  // optional .TSD.AngleGradientArchive anglegradient = 5;
  inline bool has_anglegradient() const;
  inline void clear_anglegradient();
  static const int kAnglegradientFieldNumber = 5;
  inline const ::TSD::AngleGradientArchive& anglegradient() const;
  inline ::TSD::AngleGradientArchive* mutable_anglegradient();
  inline ::TSD::AngleGradientArchive* release_anglegradient();
  inline void set_allocated_anglegradient(::TSD::AngleGradientArchive* anglegradient);

  // optional .TSD.TransformGradientArchive transformgradient = 6;
  inline bool has_transformgradient() const;
  inline void clear_transformgradient();
  static const int kTransformgradientFieldNumber = 6;
  inline const ::TSD::TransformGradientArchive& transformgradient() const;
  inline ::TSD::TransformGradientArchive* mutable_transformgradient();
  inline ::TSD::TransformGradientArchive* release_transformgradient();
  inline void set_allocated_transformgradient(::TSD::TransformGradientArchive* transformgradient);

  // @@protoc_insertion_point(class_scope:TSD.GradientArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_advancedgradient();
  inline void clear_has_advancedgradient();
  inline void set_has_anglegradient();
  inline void clear_has_anglegradient();
  inline void set_has_transformgradient();
  inline void clear_has_transformgradient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSD::GradientArchive_GradientStop > stops_;
  int type_;
  float opacity_;
  ::TSD::AngleGradientArchive* anglegradient_;
  ::TSD::TransformGradientArchive* transformgradient_;
  bool advancedgradient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static GradientArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageFillArchive : public ::google::protobuf::Message {
 public:
  ImageFillArchive();
  virtual ~ImageFillArchive();

  ImageFillArchive(const ImageFillArchive& from);

  inline ImageFillArchive& operator=(const ImageFillArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFillArchive& default_instance();

  void Swap(ImageFillArchive* other);

  // implements Message ----------------------------------------------

  ImageFillArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageFillArchive& from);
  void MergeFrom(const ImageFillArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ImageFillArchive_ImageFillTechnique ImageFillTechnique;
  static const ImageFillTechnique NaturalSize = ImageFillArchive_ImageFillTechnique_NaturalSize;
  static const ImageFillTechnique Stretch = ImageFillArchive_ImageFillTechnique_Stretch;
  static const ImageFillTechnique Tile = ImageFillArchive_ImageFillTechnique_Tile;
  static const ImageFillTechnique ScaleToFill = ImageFillArchive_ImageFillTechnique_ScaleToFill;
  static const ImageFillTechnique ScaleToFit = ImageFillArchive_ImageFillTechnique_ScaleToFit;
  static inline bool ImageFillTechnique_IsValid(int value) {
    return ImageFillArchive_ImageFillTechnique_IsValid(value);
  }
  static const ImageFillTechnique ImageFillTechnique_MIN =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MIN;
  static const ImageFillTechnique ImageFillTechnique_MAX =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX;
  static const int ImageFillTechnique_ARRAYSIZE =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageFillTechnique_descriptor() {
    return ImageFillArchive_ImageFillTechnique_descriptor();
  }
  static inline const ::std::string& ImageFillTechnique_Name(ImageFillTechnique value) {
    return ImageFillArchive_ImageFillTechnique_Name(value);
  }
  static inline bool ImageFillTechnique_Parse(const ::std::string& name,
      ImageFillTechnique* value) {
    return ImageFillArchive_ImageFillTechnique_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.DataReference imagedata = 6;
  inline bool has_imagedata() const;
  inline void clear_imagedata();
  static const int kImagedataFieldNumber = 6;
  inline const ::TSP::DataReference& imagedata() const;
  inline ::TSP::DataReference* mutable_imagedata();
  inline ::TSP::DataReference* release_imagedata();
  inline void set_allocated_imagedata(::TSP::DataReference* imagedata);

  // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
  inline bool has_technique() const;
  inline void clear_technique();
  static const int kTechniqueFieldNumber = 2;
  inline ::TSD::ImageFillArchive_ImageFillTechnique technique() const;
  inline void set_technique(::TSD::ImageFillArchive_ImageFillTechnique value);

  // optional .TSP.Color tint = 3;
  inline bool has_tint() const;
  inline void clear_tint();
  static const int kTintFieldNumber = 3;
  inline const ::TSP::Color& tint() const;
  inline ::TSP::Color* mutable_tint();
  inline ::TSP::Color* release_tint();
  inline void set_allocated_tint(::TSP::Color* tint);

  // optional .TSP.Size fillsize = 4;
  inline bool has_fillsize() const;
  inline void clear_fillsize();
  static const int kFillsizeFieldNumber = 4;
  inline const ::TSP::Size& fillsize() const;
  inline ::TSP::Size* mutable_fillsize();
  inline ::TSP::Size* release_fillsize();
  inline void set_allocated_fillsize(::TSP::Size* fillsize);

  // optional .TSP.DataReference originalimagedata = 7;
  inline bool has_originalimagedata() const;
  inline void clear_originalimagedata();
  static const int kOriginalimagedataFieldNumber = 7;
  inline const ::TSP::DataReference& originalimagedata() const;
  inline ::TSP::DataReference* mutable_originalimagedata();
  inline ::TSP::DataReference* release_originalimagedata();
  inline void set_allocated_originalimagedata(::TSP::DataReference* originalimagedata);

  // optional bool interpretsUntaggedImageDataAsGeneric = 8;
  inline bool has_interpretsuntaggedimagedataasgeneric() const;
  inline void clear_interpretsuntaggedimagedataasgeneric();
  static const int kInterpretsUntaggedImageDataAsGenericFieldNumber = 8;
  inline bool interpretsuntaggedimagedataasgeneric() const;
  inline void set_interpretsuntaggedimagedataasgeneric(bool value);

  // optional .TSP.Reference database_imagedata = 1;
  inline bool has_database_imagedata() const;
  inline void clear_database_imagedata();
  static const int kDatabaseImagedataFieldNumber = 1;
  inline const ::TSP::Reference& database_imagedata() const;
  inline ::TSP::Reference* mutable_database_imagedata();
  inline ::TSP::Reference* release_database_imagedata();
  inline void set_allocated_database_imagedata(::TSP::Reference* database_imagedata);

  // optional .TSP.Reference database_originalimagedata = 5;
  inline bool has_database_originalimagedata() const;
  inline void clear_database_originalimagedata();
  static const int kDatabaseOriginalimagedataFieldNumber = 5;
  inline const ::TSP::Reference& database_originalimagedata() const;
  inline ::TSP::Reference* mutable_database_originalimagedata();
  inline ::TSP::Reference* release_database_originalimagedata();
  inline void set_allocated_database_originalimagedata(::TSP::Reference* database_originalimagedata);

  // @@protoc_insertion_point(class_scope:TSD.ImageFillArchive)
 private:
  inline void set_has_imagedata();
  inline void clear_has_imagedata();
  inline void set_has_technique();
  inline void clear_has_technique();
  inline void set_has_tint();
  inline void clear_has_tint();
  inline void set_has_fillsize();
  inline void clear_has_fillsize();
  inline void set_has_originalimagedata();
  inline void clear_has_originalimagedata();
  inline void set_has_interpretsuntaggedimagedataasgeneric();
  inline void clear_has_interpretsuntaggedimagedataasgeneric();
  inline void set_has_database_imagedata();
  inline void clear_has_database_imagedata();
  inline void set_has_database_originalimagedata();
  inline void clear_has_database_originalimagedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::DataReference* imagedata_;
  ::TSP::Color* tint_;
  ::TSP::Size* fillsize_;
  int technique_;
  bool interpretsuntaggedimagedataasgeneric_;
  ::TSP::DataReference* originalimagedata_;
  ::TSP::Reference* database_imagedata_;
  ::TSP::Reference* database_originalimagedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageFillArchive* default_instance_;
};
// -------------------------------------------------------------------

class FillArchive : public ::google::protobuf::Message {
 public:
  FillArchive();
  virtual ~FillArchive();

  FillArchive(const FillArchive& from);

  inline FillArchive& operator=(const FillArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FillArchive& default_instance();

  void Swap(FillArchive* other);

  // implements Message ----------------------------------------------

  FillArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FillArchive& from);
  void MergeFrom(const FillArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Color color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // optional .TSD.GradientArchive gradient = 2;
  inline bool has_gradient() const;
  inline void clear_gradient();
  static const int kGradientFieldNumber = 2;
  inline const ::TSD::GradientArchive& gradient() const;
  inline ::TSD::GradientArchive* mutable_gradient();
  inline ::TSD::GradientArchive* release_gradient();
  inline void set_allocated_gradient(::TSD::GradientArchive* gradient);

  // optional .TSD.ImageFillArchive image = 3;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 3;
  inline const ::TSD::ImageFillArchive& image() const;
  inline ::TSD::ImageFillArchive* mutable_image();
  inline ::TSD::ImageFillArchive* release_image();
  inline void set_allocated_image(::TSD::ImageFillArchive* image);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FillArchive)
  // @@protoc_insertion_point(class_scope:TSD.FillArchive)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_gradient();
  inline void clear_has_gradient();
  inline void set_has_image();
  inline void clear_has_image();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Color* color_;
  ::TSD::GradientArchive* gradient_;
  ::TSD::ImageFillArchive* image_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static FillArchive* default_instance_;
};
// -------------------------------------------------------------------

class StrokePatternArchive : public ::google::protobuf::Message {
 public:
  StrokePatternArchive();
  virtual ~StrokePatternArchive();

  StrokePatternArchive(const StrokePatternArchive& from);

  inline StrokePatternArchive& operator=(const StrokePatternArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrokePatternArchive& default_instance();

  void Swap(StrokePatternArchive* other);

  // implements Message ----------------------------------------------

  StrokePatternArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrokePatternArchive& from);
  void MergeFrom(const StrokePatternArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StrokePatternArchive_StrokePatternType StrokePatternType;
  static const StrokePatternType TSDPattern = StrokePatternArchive_StrokePatternType_TSDPattern;
  static const StrokePatternType TSDSolidPattern = StrokePatternArchive_StrokePatternType_TSDSolidPattern;
  static const StrokePatternType TSDEmptyPattern = StrokePatternArchive_StrokePatternType_TSDEmptyPattern;
  static inline bool StrokePatternType_IsValid(int value) {
    return StrokePatternArchive_StrokePatternType_IsValid(value);
  }
  static const StrokePatternType StrokePatternType_MIN =
    StrokePatternArchive_StrokePatternType_StrokePatternType_MIN;
  static const StrokePatternType StrokePatternType_MAX =
    StrokePatternArchive_StrokePatternType_StrokePatternType_MAX;
  static const int StrokePatternType_ARRAYSIZE =
    StrokePatternArchive_StrokePatternType_StrokePatternType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StrokePatternType_descriptor() {
    return StrokePatternArchive_StrokePatternType_descriptor();
  }
  static inline const ::std::string& StrokePatternType_Name(StrokePatternType value) {
    return StrokePatternArchive_StrokePatternType_Name(value);
  }
  static inline bool StrokePatternType_Parse(const ::std::string& name,
      StrokePatternType* value) {
    return StrokePatternArchive_StrokePatternType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSD::StrokePatternArchive_StrokePatternType type() const;
  inline void set_type(::TSD::StrokePatternArchive_StrokePatternType value);

  // optional float phase = 2;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 2;
  inline float phase() const;
  inline void set_phase(float value);

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated float pattern = 4;
  inline int pattern_size() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 4;
  inline float pattern(int index) const;
  inline void set_pattern(int index, float value);
  inline void add_pattern(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      pattern() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_pattern();

  // @@protoc_insertion_point(class_scope:TSD.StrokePatternArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float phase_;
  ::google::protobuf::RepeatedField< float > pattern_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static StrokePatternArchive* default_instance_;
};
// -------------------------------------------------------------------

class StrokeArchive : public ::google::protobuf::Message {
 public:
  StrokeArchive();
  virtual ~StrokeArchive();

  StrokeArchive(const StrokeArchive& from);

  inline StrokeArchive& operator=(const StrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrokeArchive& default_instance();

  void Swap(StrokeArchive* other);

  // implements Message ----------------------------------------------

  StrokeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrokeArchive& from);
  void MergeFrom(const StrokeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StrokeArchive_LineCap LineCap;
  static const LineCap ButtCap = StrokeArchive_LineCap_ButtCap;
  static const LineCap RoundCap = StrokeArchive_LineCap_RoundCap;
  static const LineCap SquareCap = StrokeArchive_LineCap_SquareCap;
  static inline bool LineCap_IsValid(int value) {
    return StrokeArchive_LineCap_IsValid(value);
  }
  static const LineCap LineCap_MIN =
    StrokeArchive_LineCap_LineCap_MIN;
  static const LineCap LineCap_MAX =
    StrokeArchive_LineCap_LineCap_MAX;
  static const int LineCap_ARRAYSIZE =
    StrokeArchive_LineCap_LineCap_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LineCap_descriptor() {
    return StrokeArchive_LineCap_descriptor();
  }
  static inline const ::std::string& LineCap_Name(LineCap value) {
    return StrokeArchive_LineCap_Name(value);
  }
  static inline bool LineCap_Parse(const ::std::string& name,
      LineCap* value) {
    return StrokeArchive_LineCap_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Color color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // optional float width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline float width() const;
  inline void set_width(float value);

  // optional .TSD.StrokeArchive.LineCap cap = 3;
  inline bool has_cap() const;
  inline void clear_cap();
  static const int kCapFieldNumber = 3;
  inline ::TSD::StrokeArchive_LineCap cap() const;
  inline void set_cap(::TSD::StrokeArchive_LineCap value);

  // optional .TSD.LineJoin join = 4;
  inline bool has_join() const;
  inline void clear_join();
  static const int kJoinFieldNumber = 4;
  inline ::TSD::LineJoin join() const;
  inline void set_join(::TSD::LineJoin value);

  // optional float miterLimit = 5;
  inline bool has_miterlimit() const;
  inline void clear_miterlimit();
  static const int kMiterLimitFieldNumber = 5;
  inline float miterlimit() const;
  inline void set_miterlimit(float value);

  // optional .TSD.StrokePatternArchive pattern = 6;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 6;
  inline const ::TSD::StrokePatternArchive& pattern() const;
  inline ::TSD::StrokePatternArchive* mutable_pattern();
  inline ::TSD::StrokePatternArchive* release_pattern();
  inline void set_allocated_pattern(::TSD::StrokePatternArchive* pattern);

  // optional .TSD.SmartStrokeArchive smartStroke = 7;
  inline bool has_smartstroke() const;
  inline void clear_smartstroke();
  static const int kSmartStrokeFieldNumber = 7;
  inline const ::TSD::SmartStrokeArchive& smartstroke() const;
  inline ::TSD::SmartStrokeArchive* mutable_smartstroke();
  inline ::TSD::SmartStrokeArchive* release_smartstroke();
  inline void set_allocated_smartstroke(::TSD::SmartStrokeArchive* smartstroke);

  // optional .TSD.FrameArchive frame = 8;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 8;
  inline const ::TSD::FrameArchive& frame() const;
  inline ::TSD::FrameArchive* mutable_frame();
  inline ::TSD::FrameArchive* release_frame();
  inline void set_allocated_frame(::TSD::FrameArchive* frame);

  // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
  inline bool has_patterned_stroke() const;
  inline void clear_patterned_stroke();
  static const int kPatternedStrokeFieldNumber = 9;
  inline const ::TSD::PatternedStrokeArchive& patterned_stroke() const;
  inline ::TSD::PatternedStrokeArchive* mutable_patterned_stroke();
  inline ::TSD::PatternedStrokeArchive* release_patterned_stroke();
  inline void set_allocated_patterned_stroke(::TSD::PatternedStrokeArchive* patterned_stroke);

  // @@protoc_insertion_point(class_scope:TSD.StrokeArchive)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_cap();
  inline void clear_has_cap();
  inline void set_has_join();
  inline void clear_has_join();
  inline void set_has_miterlimit();
  inline void clear_has_miterlimit();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_smartstroke();
  inline void clear_has_smartstroke();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_patterned_stroke();
  inline void clear_has_patterned_stroke();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Color* color_;
  float width_;
  int cap_;
  int join_;
  float miterlimit_;
  ::TSD::StrokePatternArchive* pattern_;
  ::TSD::SmartStrokeArchive* smartstroke_;
  ::TSD::FrameArchive* frame_;
  ::TSD::PatternedStrokeArchive* patterned_stroke_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static StrokeArchive* default_instance_;
};
// -------------------------------------------------------------------

class SmartStrokeArchive : public ::google::protobuf::Message {
 public:
  SmartStrokeArchive();
  virtual ~SmartStrokeArchive();

  SmartStrokeArchive(const SmartStrokeArchive& from);

  inline SmartStrokeArchive& operator=(const SmartStrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmartStrokeArchive& default_instance();

  void Swap(SmartStrokeArchive* other);

  // implements Message ----------------------------------------------

  SmartStrokeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmartStrokeArchive& from);
  void MergeFrom(const SmartStrokeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string strokeName = 2;
  inline bool has_strokename() const;
  inline void clear_strokename();
  static const int kStrokeNameFieldNumber = 2;
  inline const ::std::string& strokename() const;
  inline void set_strokename(const ::std::string& value);
  inline void set_strokename(const char* value);
  inline void set_strokename(const char* value, size_t size);
  inline ::std::string* mutable_strokename();
  inline ::std::string* release_strokename();
  inline void set_allocated_strokename(::std::string* strokename);

  // optional int32 randomSeed = 3;
  inline bool has_randomseed() const;
  inline void clear_randomseed();
  static const int kRandomSeedFieldNumber = 3;
  inline ::google::protobuf::int32 randomseed() const;
  inline void set_randomseed(::google::protobuf::int32 value);

  // optional .TSP.ReferenceDictionary parameterValues = 4;
  inline bool has_parametervalues() const;
  inline void clear_parametervalues();
  static const int kParameterValuesFieldNumber = 4;
  inline const ::TSP::ReferenceDictionary& parametervalues() const;
  inline ::TSP::ReferenceDictionary* mutable_parametervalues();
  inline ::TSP::ReferenceDictionary* release_parametervalues();
  inline void set_allocated_parametervalues(::TSP::ReferenceDictionary* parametervalues);

  // @@protoc_insertion_point(class_scope:TSD.SmartStrokeArchive)
 private:
  inline void set_has_strokename();
  inline void clear_has_strokename();
  inline void set_has_randomseed();
  inline void clear_has_randomseed();
  inline void set_has_parametervalues();
  inline void clear_has_parametervalues();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strokename_;
  ::TSP::ReferenceDictionary* parametervalues_;
  ::google::protobuf::int32 randomseed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static SmartStrokeArchive* default_instance_;
};
// -------------------------------------------------------------------

class FrameArchive : public ::google::protobuf::Message {
 public:
  FrameArchive();
  virtual ~FrameArchive();

  FrameArchive(const FrameArchive& from);

  inline FrameArchive& operator=(const FrameArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameArchive& default_instance();

  void Swap(FrameArchive* other);

  // implements Message ----------------------------------------------

  FrameArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameArchive& from);
  void MergeFrom(const FrameArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string frameName = 2;
  inline bool has_framename() const;
  inline void clear_framename();
  static const int kFrameNameFieldNumber = 2;
  inline const ::std::string& framename() const;
  inline void set_framename(const ::std::string& value);
  inline void set_framename(const char* value);
  inline void set_framename(const char* value, size_t size);
  inline ::std::string* mutable_framename();
  inline ::std::string* release_framename();
  inline void set_allocated_framename(::std::string* framename);

  // optional float assetScale = 3;
  inline bool has_assetscale() const;
  inline void clear_assetscale();
  static const int kAssetScaleFieldNumber = 3;
  inline float assetscale() const;
  inline void set_assetscale(float value);

  // @@protoc_insertion_point(class_scope:TSD.FrameArchive)
 private:
  inline void set_has_framename();
  inline void clear_has_framename();
  inline void set_has_assetscale();
  inline void clear_has_assetscale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* framename_;
  float assetscale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static FrameArchive* default_instance_;
};
// -------------------------------------------------------------------

class PatternedStrokeArchive : public ::google::protobuf::Message {
 public:
  PatternedStrokeArchive();
  virtual ~PatternedStrokeArchive();

  PatternedStrokeArchive(const PatternedStrokeArchive& from);

  inline PatternedStrokeArchive& operator=(const PatternedStrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatternedStrokeArchive& default_instance();

  void Swap(PatternedStrokeArchive* other);

  // implements Message ----------------------------------------------

  PatternedStrokeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatternedStrokeArchive& from);
  void MergeFrom(const PatternedStrokeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pattern_name = 2;
  inline bool has_pattern_name() const;
  inline void clear_pattern_name();
  static const int kPatternNameFieldNumber = 2;
  inline const ::std::string& pattern_name() const;
  inline void set_pattern_name(const ::std::string& value);
  inline void set_pattern_name(const char* value);
  inline void set_pattern_name(const char* value, size_t size);
  inline ::std::string* mutable_pattern_name();
  inline ::std::string* release_pattern_name();
  inline void set_allocated_pattern_name(::std::string* pattern_name);

  // @@protoc_insertion_point(class_scope:TSD.PatternedStrokeArchive)
 private:
  inline void set_has_pattern_name();
  inline void clear_has_pattern_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pattern_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static PatternedStrokeArchive* default_instance_;
};
// -------------------------------------------------------------------

class LineEndArchive : public ::google::protobuf::Message {
 public:
  LineEndArchive();
  virtual ~LineEndArchive();

  LineEndArchive(const LineEndArchive& from);

  inline LineEndArchive& operator=(const LineEndArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineEndArchive& default_instance();

  void Swap(LineEndArchive* other);

  // implements Message ----------------------------------------------

  LineEndArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineEndArchive& from);
  void MergeFrom(const LineEndArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Path path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::TSP::Path& path() const;
  inline ::TSP::Path* mutable_path();
  inline ::TSP::Path* release_path();
  inline void set_allocated_path(::TSP::Path* path);

  // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
  inline bool has_line_join() const;
  inline void clear_line_join();
  static const int kLineJoinFieldNumber = 2;
  inline ::TSD::LineJoin line_join() const;
  inline void set_line_join(::TSD::LineJoin value);

  // optional .TSP.Point end_point = 3;
  inline bool has_end_point() const;
  inline void clear_end_point();
  static const int kEndPointFieldNumber = 3;
  inline const ::TSP::Point& end_point() const;
  inline ::TSP::Point* mutable_end_point();
  inline ::TSP::Point* release_end_point();
  inline void set_allocated_end_point(::TSP::Point* end_point);

  // optional bool is_filled = 4;
  inline bool has_is_filled() const;
  inline void clear_is_filled();
  static const int kIsFilledFieldNumber = 4;
  inline bool is_filled() const;
  inline void set_is_filled(bool value);

  // optional string identifier = 5;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 5;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  inline void set_allocated_identifier(::std::string* identifier);

  // @@protoc_insertion_point(class_scope:TSD.LineEndArchive)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_line_join();
  inline void clear_has_line_join();
  inline void set_has_end_point();
  inline void clear_has_end_point();
  inline void set_has_is_filled();
  inline void clear_has_is_filled();
  inline void set_has_identifier();
  inline void clear_has_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Path* path_;
  ::TSP::Point* end_point_;
  int line_join_;
  bool is_filled_;
  ::std::string* identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static LineEndArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShadowArchive : public ::google::protobuf::Message {
 public:
  ShadowArchive();
  virtual ~ShadowArchive();

  ShadowArchive(const ShadowArchive& from);

  inline ShadowArchive& operator=(const ShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShadowArchive& default_instance();

  void Swap(ShadowArchive* other);

  // implements Message ----------------------------------------------

  ShadowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShadowArchive& from);
  void MergeFrom(const ShadowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ShadowArchive_ShadowType ShadowType;
  static const ShadowType TSDDropShadow = ShadowArchive_ShadowType_TSDDropShadow;
  static const ShadowType TSDContactShadow = ShadowArchive_ShadowType_TSDContactShadow;
  static const ShadowType TSDCurvedShadow = ShadowArchive_ShadowType_TSDCurvedShadow;
  static inline bool ShadowType_IsValid(int value) {
    return ShadowArchive_ShadowType_IsValid(value);
  }
  static const ShadowType ShadowType_MIN =
    ShadowArchive_ShadowType_ShadowType_MIN;
  static const ShadowType ShadowType_MAX =
    ShadowArchive_ShadowType_ShadowType_MAX;
  static const int ShadowType_ARRAYSIZE =
    ShadowArchive_ShadowType_ShadowType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ShadowType_descriptor() {
    return ShadowArchive_ShadowType_descriptor();
  }
  static inline const ::std::string& ShadowType_Name(ShadowType value) {
    return ShadowArchive_ShadowType_Name(value);
  }
  static inline bool ShadowType_Parse(const ::std::string& name,
      ShadowType* value) {
    return ShadowArchive_ShadowType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSP.Color color = 1;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 1;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // optional float angle = 2 [default = 315];
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 2;
  inline float angle() const;
  inline void set_angle(float value);

  // optional float offset = 3 [default = 5];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline float offset() const;
  inline void set_offset(float value);

  // optional int32 radius = 4 [default = 1];
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline ::google::protobuf::int32 radius() const;
  inline void set_radius(::google::protobuf::int32 value);

  // optional float opacity = 5 [default = 1];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 5;
  inline float opacity() const;
  inline void set_opacity(float value);

  // optional bool is_enabled = 6 [default = true];
  inline bool has_is_enabled() const;
  inline void clear_is_enabled();
  static const int kIsEnabledFieldNumber = 6;
  inline bool is_enabled() const;
  inline void set_is_enabled(bool value);

  // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::TSD::ShadowArchive_ShadowType type() const;
  inline void set_type(::TSD::ShadowArchive_ShadowType value);

  // optional .TSD.DropShadowArchive dropShadow = 8;
  inline bool has_dropshadow() const;
  inline void clear_dropshadow();
  static const int kDropShadowFieldNumber = 8;
  inline const ::TSD::DropShadowArchive& dropshadow() const;
  inline ::TSD::DropShadowArchive* mutable_dropshadow();
  inline ::TSD::DropShadowArchive* release_dropshadow();
  inline void set_allocated_dropshadow(::TSD::DropShadowArchive* dropshadow);

  // optional .TSD.ContactShadowArchive contactShadow = 9;
  inline bool has_contactshadow() const;
  inline void clear_contactshadow();
  static const int kContactShadowFieldNumber = 9;
  inline const ::TSD::ContactShadowArchive& contactshadow() const;
  inline ::TSD::ContactShadowArchive* mutable_contactshadow();
  inline ::TSD::ContactShadowArchive* release_contactshadow();
  inline void set_allocated_contactshadow(::TSD::ContactShadowArchive* contactshadow);

  // optional .TSD.CurvedShadowArchive curvedShadow = 10;
  inline bool has_curvedshadow() const;
  inline void clear_curvedshadow();
  static const int kCurvedShadowFieldNumber = 10;
  inline const ::TSD::CurvedShadowArchive& curvedshadow() const;
  inline ::TSD::CurvedShadowArchive* mutable_curvedshadow();
  inline ::TSD::CurvedShadowArchive* release_curvedshadow();
  inline void set_allocated_curvedshadow(::TSD::CurvedShadowArchive* curvedshadow);

  // @@protoc_insertion_point(class_scope:TSD.ShadowArchive)
 private:
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_is_enabled();
  inline void clear_has_is_enabled();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dropshadow();
  inline void clear_has_dropshadow();
  inline void set_has_contactshadow();
  inline void clear_has_contactshadow();
  inline void set_has_curvedshadow();
  inline void clear_has_curvedshadow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Color* color_;
  float angle_;
  float offset_;
  ::google::protobuf::int32 radius_;
  float opacity_;
  bool is_enabled_;
  int type_;
  ::TSD::DropShadowArchive* dropshadow_;
  ::TSD::ContactShadowArchive* contactshadow_;
  ::TSD::CurvedShadowArchive* curvedshadow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ShadowArchive* default_instance_;
};
// -------------------------------------------------------------------

class DropShadowArchive : public ::google::protobuf::Message {
 public:
  DropShadowArchive();
  virtual ~DropShadowArchive();

  DropShadowArchive(const DropShadowArchive& from);

  inline DropShadowArchive& operator=(const DropShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropShadowArchive& default_instance();

  void Swap(DropShadowArchive* other);

  // implements Message ----------------------------------------------

  DropShadowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropShadowArchive& from);
  void MergeFrom(const DropShadowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSD.DropShadowArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static DropShadowArchive* default_instance_;
};
// -------------------------------------------------------------------

class ContactShadowArchive : public ::google::protobuf::Message {
 public:
  ContactShadowArchive();
  virtual ~ContactShadowArchive();

  ContactShadowArchive(const ContactShadowArchive& from);

  inline ContactShadowArchive& operator=(const ContactShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactShadowArchive& default_instance();

  void Swap(ContactShadowArchive* other);

  // implements Message ----------------------------------------------

  ContactShadowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactShadowArchive& from);
  void MergeFrom(const ContactShadowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float height = 2 [default = 0.2];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline float height() const;
  inline void set_height(float value);

  // optional float offset = 4 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline float offset() const;
  inline void set_offset(float value);

  // @@protoc_insertion_point(class_scope:TSD.ContactShadowArchive)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float height_;
  float offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ContactShadowArchive* default_instance_;
};
// -------------------------------------------------------------------

class CurvedShadowArchive : public ::google::protobuf::Message {
 public:
  CurvedShadowArchive();
  virtual ~CurvedShadowArchive();

  CurvedShadowArchive(const CurvedShadowArchive& from);

  inline CurvedShadowArchive& operator=(const CurvedShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurvedShadowArchive& default_instance();

  void Swap(CurvedShadowArchive* other);

  // implements Message ----------------------------------------------

  CurvedShadowArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurvedShadowArchive& from);
  void MergeFrom(const CurvedShadowArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float curve = 1 [default = 0.6];
  inline bool has_curve() const;
  inline void clear_curve();
  static const int kCurveFieldNumber = 1;
  inline float curve() const;
  inline void set_curve(float value);

  // @@protoc_insertion_point(class_scope:TSD.CurvedShadowArchive)
 private:
  inline void set_has_curve();
  inline void clear_has_curve();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float curve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static CurvedShadowArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReflectionArchive : public ::google::protobuf::Message {
 public:
  ReflectionArchive();
  virtual ~ReflectionArchive();

  ReflectionArchive(const ReflectionArchive& from);

  inline ReflectionArchive& operator=(const ReflectionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReflectionArchive& default_instance();

  void Swap(ReflectionArchive* other);

  // implements Message ----------------------------------------------

  ReflectionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReflectionArchive& from);
  void MergeFrom(const ReflectionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float opacity = 1 [default = 0.5];
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 1;
  inline float opacity() const;
  inline void set_opacity(float value);

  // @@protoc_insertion_point(class_scope:TSD.ReflectionArchive)
 private:
  inline void set_has_opacity();
  inline void clear_has_opacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float opacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ReflectionArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageAdjustmentsArchive : public ::google::protobuf::Message {
 public:
  ImageAdjustmentsArchive();
  virtual ~ImageAdjustmentsArchive();

  ImageAdjustmentsArchive(const ImageAdjustmentsArchive& from);

  inline ImageAdjustmentsArchive& operator=(const ImageAdjustmentsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageAdjustmentsArchive& default_instance();

  void Swap(ImageAdjustmentsArchive* other);

  // implements Message ----------------------------------------------

  ImageAdjustmentsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageAdjustmentsArchive& from);
  void MergeFrom(const ImageAdjustmentsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float exposure = 1;
  inline bool has_exposure() const;
  inline void clear_exposure();
  static const int kExposureFieldNumber = 1;
  inline float exposure() const;
  inline void set_exposure(float value);

  // optional float saturation = 2;
  inline bool has_saturation() const;
  inline void clear_saturation();
  static const int kSaturationFieldNumber = 2;
  inline float saturation() const;
  inline void set_saturation(float value);

  // optional float contrast = 3;
  inline bool has_contrast() const;
  inline void clear_contrast();
  static const int kContrastFieldNumber = 3;
  inline float contrast() const;
  inline void set_contrast(float value);

  // optional float highlights = 4;
  inline bool has_highlights() const;
  inline void clear_highlights();
  static const int kHighlightsFieldNumber = 4;
  inline float highlights() const;
  inline void set_highlights(float value);

  // optional float shadows = 5;
  inline bool has_shadows() const;
  inline void clear_shadows();
  static const int kShadowsFieldNumber = 5;
  inline float shadows() const;
  inline void set_shadows(float value);

  // optional float sharpness = 6;
  inline bool has_sharpness() const;
  inline void clear_sharpness();
  static const int kSharpnessFieldNumber = 6;
  inline float sharpness() const;
  inline void set_sharpness(float value);

  // optional float denoise = 7;
  inline bool has_denoise() const;
  inline void clear_denoise();
  static const int kDenoiseFieldNumber = 7;
  inline float denoise() const;
  inline void set_denoise(float value);

  // optional float temperature = 8;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 8;
  inline float temperature() const;
  inline void set_temperature(float value);

  // optional float tint = 9;
  inline bool has_tint() const;
  inline void clear_tint();
  static const int kTintFieldNumber = 9;
  inline float tint() const;
  inline void set_tint(float value);

  // optional float bottom_level = 10;
  inline bool has_bottom_level() const;
  inline void clear_bottom_level();
  static const int kBottomLevelFieldNumber = 10;
  inline float bottom_level() const;
  inline void set_bottom_level(float value);

  // optional float top_level = 11 [default = 1];
  inline bool has_top_level() const;
  inline void clear_top_level();
  static const int kTopLevelFieldNumber = 11;
  inline float top_level() const;
  inline void set_top_level(float value);

  // optional float gamma = 12;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 12;
  inline float gamma() const;
  inline void set_gamma(float value);

  // optional bool enhance = 13 [default = false];
  inline bool has_enhance() const;
  inline void clear_enhance();
  static const int kEnhanceFieldNumber = 13;
  inline bool enhance() const;
  inline void set_enhance(bool value);

  // optional bool represents_sage_adjustments = 14 [default = false];
  inline bool has_represents_sage_adjustments() const;
  inline void clear_represents_sage_adjustments();
  static const int kRepresentsSageAdjustmentsFieldNumber = 14;
  inline bool represents_sage_adjustments() const;
  inline void set_represents_sage_adjustments(bool value);

  // @@protoc_insertion_point(class_scope:TSD.ImageAdjustmentsArchive)
 private:
  inline void set_has_exposure();
  inline void clear_has_exposure();
  inline void set_has_saturation();
  inline void clear_has_saturation();
  inline void set_has_contrast();
  inline void clear_has_contrast();
  inline void set_has_highlights();
  inline void clear_has_highlights();
  inline void set_has_shadows();
  inline void clear_has_shadows();
  inline void set_has_sharpness();
  inline void clear_has_sharpness();
  inline void set_has_denoise();
  inline void clear_has_denoise();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_tint();
  inline void clear_has_tint();
  inline void set_has_bottom_level();
  inline void clear_has_bottom_level();
  inline void set_has_top_level();
  inline void clear_has_top_level();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_enhance();
  inline void clear_has_enhance();
  inline void set_has_represents_sage_adjustments();
  inline void clear_has_represents_sage_adjustments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float exposure_;
  float saturation_;
  float contrast_;
  float highlights_;
  float shadows_;
  float sharpness_;
  float denoise_;
  float temperature_;
  float tint_;
  float bottom_level_;
  float top_level_;
  float gamma_;
  bool enhance_;
  bool represents_sage_adjustments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageAdjustmentsArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  ShapeStylePropertiesArchive();
  virtual ~ShapeStylePropertiesArchive();

  ShapeStylePropertiesArchive(const ShapeStylePropertiesArchive& from);

  inline ShapeStylePropertiesArchive& operator=(const ShapeStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeStylePropertiesArchive& default_instance();

  void Swap(ShapeStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  ShapeStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeStylePropertiesArchive& from);
  void MergeFrom(const ShapeStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSD.FillArchive fill = 1;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 1;
  inline const ::TSD::FillArchive& fill() const;
  inline ::TSD::FillArchive* mutable_fill();
  inline ::TSD::FillArchive* release_fill();
  inline void set_allocated_fill(::TSD::FillArchive* fill);

  // optional .TSD.StrokeArchive stroke = 2;
  inline bool has_stroke() const;
  inline void clear_stroke();
  static const int kStrokeFieldNumber = 2;
  inline const ::TSD::StrokeArchive& stroke() const;
  inline ::TSD::StrokeArchive* mutable_stroke();
  inline ::TSD::StrokeArchive* release_stroke();
  inline void set_allocated_stroke(::TSD::StrokeArchive* stroke);

  // optional float opacity = 3;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 3;
  inline float opacity() const;
  inline void set_opacity(float value);

  // optional .TSD.ShadowArchive shadow = 4;
  inline bool has_shadow() const;
  inline void clear_shadow();
  static const int kShadowFieldNumber = 4;
  inline const ::TSD::ShadowArchive& shadow() const;
  inline ::TSD::ShadowArchive* mutable_shadow();
  inline ::TSD::ShadowArchive* release_shadow();
  inline void set_allocated_shadow(::TSD::ShadowArchive* shadow);

  // optional .TSD.ReflectionArchive reflection = 5;
  inline bool has_reflection() const;
  inline void clear_reflection();
  static const int kReflectionFieldNumber = 5;
  inline const ::TSD::ReflectionArchive& reflection() const;
  inline ::TSD::ReflectionArchive* mutable_reflection();
  inline ::TSD::ReflectionArchive* release_reflection();
  inline void set_allocated_reflection(::TSD::ReflectionArchive* reflection);

  // @@protoc_insertion_point(class_scope:TSD.ShapeStylePropertiesArchive)
 private:
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_stroke();
  inline void clear_has_stroke();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_shadow();
  inline void clear_has_shadow();
  inline void set_has_reflection();
  inline void clear_has_reflection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::FillArchive* fill_;
  ::TSD::StrokeArchive* stroke_;
  ::TSD::ShadowArchive* shadow_;
  ::TSD::ReflectionArchive* reflection_;
  float opacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeStyleArchive : public ::google::protobuf::Message {
 public:
  ShapeStyleArchive();
  virtual ~ShapeStyleArchive();

  ShapeStyleArchive(const ShapeStyleArchive& from);

  inline ShapeStyleArchive& operator=(const ShapeStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeStyleArchive& default_instance();

  void Swap(ShapeStyleArchive* other);

  // implements Message ----------------------------------------------

  ShapeStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeStyleArchive& from);
  void MergeFrom(const ShapeStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
  inline bool has_shape_properties() const;
  inline void clear_shape_properties();
  static const int kShapePropertiesFieldNumber = 11;
  inline const ::TSD::ShapeStylePropertiesArchive& shape_properties() const;
  inline ::TSD::ShapeStylePropertiesArchive* mutable_shape_properties();
  inline ::TSD::ShapeStylePropertiesArchive* release_shape_properties();
  inline void set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties);

  // @@protoc_insertion_point(class_scope:TSD.ShapeStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_shape_properties();
  inline void clear_has_shape_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TSD::ShapeStylePropertiesArchive* shape_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class MediaStylePropertiesArchive : public ::google::protobuf::Message {
 public:
  MediaStylePropertiesArchive();
  virtual ~MediaStylePropertiesArchive();

  MediaStylePropertiesArchive(const MediaStylePropertiesArchive& from);

  inline MediaStylePropertiesArchive& operator=(const MediaStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaStylePropertiesArchive& default_instance();

  void Swap(MediaStylePropertiesArchive* other);

  // implements Message ----------------------------------------------

  MediaStylePropertiesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaStylePropertiesArchive& from);
  void MergeFrom(const MediaStylePropertiesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSD.StrokeArchive stroke = 1;
  inline bool has_stroke() const;
  inline void clear_stroke();
  static const int kStrokeFieldNumber = 1;
  inline const ::TSD::StrokeArchive& stroke() const;
  inline ::TSD::StrokeArchive* mutable_stroke();
  inline ::TSD::StrokeArchive* release_stroke();
  inline void set_allocated_stroke(::TSD::StrokeArchive* stroke);

  // optional float opacity = 2;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 2;
  inline float opacity() const;
  inline void set_opacity(float value);

  // optional .TSD.ShadowArchive shadow = 3;
  inline bool has_shadow() const;
  inline void clear_shadow();
  static const int kShadowFieldNumber = 3;
  inline const ::TSD::ShadowArchive& shadow() const;
  inline ::TSD::ShadowArchive* mutable_shadow();
  inline ::TSD::ShadowArchive* release_shadow();
  inline void set_allocated_shadow(::TSD::ShadowArchive* shadow);

  // optional .TSD.ReflectionArchive reflection = 4;
  inline bool has_reflection() const;
  inline void clear_reflection();
  static const int kReflectionFieldNumber = 4;
  inline const ::TSD::ReflectionArchive& reflection() const;
  inline ::TSD::ReflectionArchive* mutable_reflection();
  inline ::TSD::ReflectionArchive* release_reflection();
  inline void set_allocated_reflection(::TSD::ReflectionArchive* reflection);

  // @@protoc_insertion_point(class_scope:TSD.MediaStylePropertiesArchive)
 private:
  inline void set_has_stroke();
  inline void clear_has_stroke();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_shadow();
  inline void clear_has_shadow();
  inline void set_has_reflection();
  inline void clear_has_reflection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::StrokeArchive* stroke_;
  ::TSD::ShadowArchive* shadow_;
  ::TSD::ReflectionArchive* reflection_;
  float opacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static MediaStylePropertiesArchive* default_instance_;
};
// -------------------------------------------------------------------

class MediaStyleArchive : public ::google::protobuf::Message {
 public:
  MediaStyleArchive();
  virtual ~MediaStyleArchive();

  MediaStyleArchive(const MediaStyleArchive& from);

  inline MediaStyleArchive& operator=(const MediaStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaStyleArchive& default_instance();

  void Swap(MediaStyleArchive* other);

  // implements Message ----------------------------------------------

  MediaStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaStyleArchive& from);
  void MergeFrom(const MediaStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  // optional uint32 override_count = 10 [default = 0];
  inline bool has_override_count() const;
  inline void clear_override_count();
  static const int kOverrideCountFieldNumber = 10;
  inline ::google::protobuf::uint32 override_count() const;
  inline void set_override_count(::google::protobuf::uint32 value);

  // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
  inline bool has_media_properties() const;
  inline void clear_media_properties();
  static const int kMediaPropertiesFieldNumber = 11;
  inline const ::TSD::MediaStylePropertiesArchive& media_properties() const;
  inline ::TSD::MediaStylePropertiesArchive* mutable_media_properties();
  inline ::TSD::MediaStylePropertiesArchive* release_media_properties();
  inline void set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties);

  // @@protoc_insertion_point(class_scope:TSD.MediaStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_override_count();
  inline void clear_has_override_count();
  inline void set_has_media_properties();
  inline void clear_has_media_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;
  ::TSD::MediaStylePropertiesArchive* media_properties_;
  ::google::protobuf::uint32 override_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static MediaStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ThemePresetsArchive : public ::google::protobuf::Message {
 public:
  ThemePresetsArchive();
  virtual ~ThemePresetsArchive();

  ThemePresetsArchive(const ThemePresetsArchive& from);

  inline ThemePresetsArchive& operator=(const ThemePresetsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThemePresetsArchive& default_instance();

  void Swap(ThemePresetsArchive* other);

  // implements Message ----------------------------------------------

  ThemePresetsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThemePresetsArchive& from);
  void MergeFrom(const ThemePresetsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  inline int gradient_fill_presets_size() const;
  inline void clear_gradient_fill_presets();
  static const int kGradientFillPresetsFieldNumber = 1;
  inline const ::TSD::FillArchive& gradient_fill_presets(int index) const;
  inline ::TSD::FillArchive* mutable_gradient_fill_presets(int index);
  inline ::TSD::FillArchive* add_gradient_fill_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >&
      gradient_fill_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >*
      mutable_gradient_fill_presets();

  // repeated .TSD.FillArchive image_fill_presets = 2;
  inline int image_fill_presets_size() const;
  inline void clear_image_fill_presets();
  static const int kImageFillPresetsFieldNumber = 2;
  inline const ::TSD::FillArchive& image_fill_presets(int index) const;
  inline ::TSD::FillArchive* mutable_image_fill_presets(int index);
  inline ::TSD::FillArchive* add_image_fill_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >&
      image_fill_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >*
      mutable_image_fill_presets();

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  inline int shadow_presets_size() const;
  inline void clear_shadow_presets();
  static const int kShadowPresetsFieldNumber = 3;
  inline const ::TSD::ShadowArchive& shadow_presets(int index) const;
  inline ::TSD::ShadowArchive* mutable_shadow_presets(int index);
  inline ::TSD::ShadowArchive* add_shadow_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::ShadowArchive >&
      shadow_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::ShadowArchive >*
      mutable_shadow_presets();

  // repeated .TSP.Reference line_style_presets = 4;
  inline int line_style_presets_size() const;
  inline void clear_line_style_presets();
  static const int kLineStylePresetsFieldNumber = 4;
  inline const ::TSP::Reference& line_style_presets(int index) const;
  inline ::TSP::Reference* mutable_line_style_presets(int index);
  inline ::TSP::Reference* add_line_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      line_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_line_style_presets();

  // repeated .TSP.Reference shape_style_presets = 5;
  inline int shape_style_presets_size() const;
  inline void clear_shape_style_presets();
  static const int kShapeStylePresetsFieldNumber = 5;
  inline const ::TSP::Reference& shape_style_presets(int index) const;
  inline ::TSP::Reference* mutable_shape_style_presets(int index);
  inline ::TSP::Reference* add_shape_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      shape_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_shape_style_presets();

  // repeated .TSP.Reference textbox_style_presets = 6;
  inline int textbox_style_presets_size() const;
  inline void clear_textbox_style_presets();
  static const int kTextboxStylePresetsFieldNumber = 6;
  inline const ::TSP::Reference& textbox_style_presets(int index) const;
  inline ::TSP::Reference* mutable_textbox_style_presets(int index);
  inline ::TSP::Reference* add_textbox_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      textbox_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_textbox_style_presets();

  // repeated .TSP.Reference image_style_presets = 7;
  inline int image_style_presets_size() const;
  inline void clear_image_style_presets();
  static const int kImageStylePresetsFieldNumber = 7;
  inline const ::TSP::Reference& image_style_presets(int index) const;
  inline ::TSP::Reference* mutable_image_style_presets(int index);
  inline ::TSP::Reference* add_image_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      image_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_image_style_presets();

  // repeated .TSP.Reference movie_style_presets = 8;
  inline int movie_style_presets_size() const;
  inline void clear_movie_style_presets();
  static const int kMovieStylePresetsFieldNumber = 8;
  inline const ::TSP::Reference& movie_style_presets(int index) const;
  inline ::TSP::Reference* mutable_movie_style_presets(int index);
  inline ::TSP::Reference* add_movie_style_presets();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      movie_style_presets() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_movie_style_presets();

  static const int kExtensionFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::TSS::ThemeArchive,
      ::google::protobuf::internal::MessageTypeTraits< ::TSD::ThemePresetsArchive >, 11, false >
    extension;
  // @@protoc_insertion_point(class_scope:TSD.ThemePresetsArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive > gradient_fill_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive > image_fill_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSD::ShadowArchive > shadow_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > line_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > shape_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > textbox_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > image_style_presets_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > movie_style_presets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ThemePresetsArchive* default_instance_;
};
// -------------------------------------------------------------------

class ThemeReplaceFillPresetCommandArchive : public ::google::protobuf::Message {
 public:
  ThemeReplaceFillPresetCommandArchive();
  virtual ~ThemeReplaceFillPresetCommandArchive();

  ThemeReplaceFillPresetCommandArchive(const ThemeReplaceFillPresetCommandArchive& from);

  inline ThemeReplaceFillPresetCommandArchive& operator=(const ThemeReplaceFillPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThemeReplaceFillPresetCommandArchive& default_instance();

  void Swap(ThemeReplaceFillPresetCommandArchive* other);

  // implements Message ----------------------------------------------

  ThemeReplaceFillPresetCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThemeReplaceFillPresetCommandArchive& from);
  void MergeFrom(const ThemeReplaceFillPresetCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // required .TSD.FillArchive fill = 3;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 3;
  inline const ::TSD::FillArchive& fill() const;
  inline ::TSD::FillArchive* mutable_fill();
  inline ::TSD::FillArchive* release_fill();
  inline void set_allocated_fill(::TSD::FillArchive* fill);

  // required .TSD.FillArchive old_fill = 4;
  inline bool has_old_fill() const;
  inline void clear_old_fill();
  static const int kOldFillFieldNumber = 4;
  inline const ::TSD::FillArchive& old_fill() const;
  inline ::TSD::FillArchive* mutable_old_fill();
  inline ::TSD::FillArchive* release_old_fill();
  inline void set_allocated_old_fill(::TSD::FillArchive* old_fill);

  // required uint32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSD.ThemeReplaceFillPresetCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_old_fill();
  inline void clear_has_old_fill();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TSD::FillArchive* fill_;
  ::TSD::FillArchive* old_fill_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ThemeReplaceFillPresetCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DrawableArchive : public ::google::protobuf::Message {
 public:
  DrawableArchive();
  virtual ~DrawableArchive();

  DrawableArchive(const DrawableArchive& from);

  inline DrawableArchive& operator=(const DrawableArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrawableArchive& default_instance();

  void Swap(DrawableArchive* other);

  // implements Message ----------------------------------------------

  DrawableArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrawableArchive& from);
  void MergeFrom(const DrawableArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSD.GeometryArchive geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::TSD::GeometryArchive& geometry() const;
  inline ::TSD::GeometryArchive* mutable_geometry();
  inline ::TSD::GeometryArchive* release_geometry();
  inline void set_allocated_geometry(::TSD::GeometryArchive* geometry);

  // optional .TSP.Reference parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline const ::TSP::Reference& parent() const;
  inline ::TSP::Reference* mutable_parent();
  inline ::TSP::Reference* release_parent();
  inline void set_allocated_parent(::TSP::Reference* parent);

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
  inline bool has_exterior_text_wrap() const;
  inline void clear_exterior_text_wrap();
  static const int kExteriorTextWrapFieldNumber = 3;
  inline const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap() const;
  inline ::TSD::ExteriorTextWrapArchive* mutable_exterior_text_wrap();
  inline ::TSD::ExteriorTextWrapArchive* release_exterior_text_wrap();
  inline void set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap);

  // optional string hyperlink_url = 4;
  inline bool has_hyperlink_url() const;
  inline void clear_hyperlink_url();
  static const int kHyperlinkUrlFieldNumber = 4;
  inline const ::std::string& hyperlink_url() const;
  inline void set_hyperlink_url(const ::std::string& value);
  inline void set_hyperlink_url(const char* value);
  inline void set_hyperlink_url(const char* value, size_t size);
  inline ::std::string* mutable_hyperlink_url();
  inline ::std::string* release_hyperlink_url();
  inline void set_allocated_hyperlink_url(::std::string* hyperlink_url);

  // optional bool locked = 5;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 5;
  inline bool locked() const;
  inline void set_locked(bool value);

  // optional .TSP.Reference comment = 6;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 6;
  inline const ::TSP::Reference& comment() const;
  inline ::TSP::Reference* mutable_comment();
  inline ::TSP::Reference* release_comment();
  inline void set_allocated_comment(::TSP::Reference* comment);

  // optional bool aspect_ratio_locked = 7;
  inline bool has_aspect_ratio_locked() const;
  inline void clear_aspect_ratio_locked();
  static const int kAspectRatioLockedFieldNumber = 7;
  inline bool aspect_ratio_locked() const;
  inline void set_aspect_ratio_locked(bool value);

  // optional string accessibility_description = 8;
  inline bool has_accessibility_description() const;
  inline void clear_accessibility_description();
  static const int kAccessibilityDescriptionFieldNumber = 8;
  inline const ::std::string& accessibility_description() const;
  inline void set_accessibility_description(const ::std::string& value);
  inline void set_accessibility_description(const char* value);
  inline void set_accessibility_description(const char* value, size_t size);
  inline ::std::string* mutable_accessibility_description();
  inline ::std::string* release_accessibility_description();
  inline void set_allocated_accessibility_description(::std::string* accessibility_description);

  // @@protoc_insertion_point(class_scope:TSD.DrawableArchive)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_exterior_text_wrap();
  inline void clear_has_exterior_text_wrap();
  inline void set_has_hyperlink_url();
  inline void clear_has_hyperlink_url();
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_aspect_ratio_locked();
  inline void clear_has_aspect_ratio_locked();
  inline void set_has_accessibility_description();
  inline void clear_has_accessibility_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::GeometryArchive* geometry_;
  ::TSP::Reference* parent_;
  ::TSD::ExteriorTextWrapArchive* exterior_text_wrap_;
  ::std::string* hyperlink_url_;
  ::TSP::Reference* comment_;
  ::std::string* accessibility_description_;
  bool locked_;
  bool aspect_ratio_locked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static DrawableArchive* default_instance_;
};
// -------------------------------------------------------------------

class ContainerArchive : public ::google::protobuf::Message {
 public:
  ContainerArchive();
  virtual ~ContainerArchive();

  ContainerArchive(const ContainerArchive& from);

  inline ContainerArchive& operator=(const ContainerArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerArchive& default_instance();

  void Swap(ContainerArchive* other);

  // implements Message ----------------------------------------------

  ContainerArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerArchive& from);
  void MergeFrom(const ContainerArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSD.GeometryArchive geometry = 1;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  inline const ::TSD::GeometryArchive& geometry() const;
  inline ::TSD::GeometryArchive* mutable_geometry();
  inline ::TSD::GeometryArchive* release_geometry();
  inline void set_allocated_geometry(::TSD::GeometryArchive* geometry);

  // optional .TSP.Reference parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline const ::TSP::Reference& parent() const;
  inline ::TSP::Reference* mutable_parent();
  inline ::TSP::Reference* release_parent();
  inline void set_allocated_parent(::TSP::Reference* parent);

  // repeated .TSP.Reference children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:TSD.ContainerArchive)
 private:
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::GeometryArchive* geometry_;
  ::TSP::Reference* parent_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ContainerArchive* default_instance_;
};
// -------------------------------------------------------------------

class GroupArchive : public ::google::protobuf::Message {
 public:
  GroupArchive();
  virtual ~GroupArchive();

  GroupArchive(const GroupArchive& from);

  inline GroupArchive& operator=(const GroupArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupArchive& default_instance();

  void Swap(GroupArchive* other);

  // implements Message ----------------------------------------------

  GroupArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupArchive& from);
  void MergeFrom(const GroupArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.DrawableArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::DrawableArchive& super() const;
  inline ::TSD::DrawableArchive* mutable_super();
  inline ::TSD::DrawableArchive* release_super();
  inline void set_allocated_super(::TSD::DrawableArchive* super);

  // repeated .TSP.Reference children = 2;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 2;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:TSD.GroupArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::DrawableArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static GroupArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeArchive : public ::google::protobuf::Message {
 public:
  ShapeArchive();
  virtual ~ShapeArchive();

  ShapeArchive(const ShapeArchive& from);

  inline ShapeArchive& operator=(const ShapeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeArchive& default_instance();

  void Swap(ShapeArchive* other);

  // implements Message ----------------------------------------------

  ShapeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeArchive& from);
  void MergeFrom(const ShapeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.DrawableArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::DrawableArchive& super() const;
  inline ::TSD::DrawableArchive* mutable_super();
  inline ::TSD::DrawableArchive* release_super();
  inline void set_allocated_super(::TSD::DrawableArchive* super);

  // optional .TSP.Reference style = 2;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 2;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // optional .TSD.PathSourceArchive pathsource = 3;
  inline bool has_pathsource() const;
  inline void clear_pathsource();
  static const int kPathsourceFieldNumber = 3;
  inline const ::TSD::PathSourceArchive& pathsource() const;
  inline ::TSD::PathSourceArchive* mutable_pathsource();
  inline ::TSD::PathSourceArchive* release_pathsource();
  inline void set_allocated_pathsource(::TSD::PathSourceArchive* pathsource);

  // optional .TSD.LineEndArchive head_line_end = 4;
  inline bool has_head_line_end() const;
  inline void clear_head_line_end();
  static const int kHeadLineEndFieldNumber = 4;
  inline const ::TSD::LineEndArchive& head_line_end() const;
  inline ::TSD::LineEndArchive* mutable_head_line_end();
  inline ::TSD::LineEndArchive* release_head_line_end();
  inline void set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end);

  // optional .TSD.LineEndArchive tail_line_end = 5;
  inline bool has_tail_line_end() const;
  inline void clear_tail_line_end();
  static const int kTailLineEndFieldNumber = 5;
  inline const ::TSD::LineEndArchive& tail_line_end() const;
  inline ::TSD::LineEndArchive* mutable_tail_line_end();
  inline ::TSD::LineEndArchive* release_tail_line_end();
  inline void set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end);

  // @@protoc_insertion_point(class_scope:TSD.ShapeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_pathsource();
  inline void clear_has_pathsource();
  inline void set_has_head_line_end();
  inline void clear_has_head_line_end();
  inline void set_has_tail_line_end();
  inline void clear_has_tail_line_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::DrawableArchive* super_;
  ::TSP::Reference* style_;
  ::TSD::PathSourceArchive* pathsource_;
  ::TSD::LineEndArchive* head_line_end_;
  ::TSD::LineEndArchive* tail_line_end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionLineArchive : public ::google::protobuf::Message {
 public:
  ConnectionLineArchive();
  virtual ~ConnectionLineArchive();

  ConnectionLineArchive(const ConnectionLineArchive& from);

  inline ConnectionLineArchive& operator=(const ConnectionLineArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionLineArchive& default_instance();

  void Swap(ConnectionLineArchive* other);

  // implements Message ----------------------------------------------

  ConnectionLineArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionLineArchive& from);
  void MergeFrom(const ConnectionLineArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.ShapeArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::ShapeArchive& super() const;
  inline ::TSD::ShapeArchive* mutable_super();
  inline ::TSD::ShapeArchive* release_super();
  inline void set_allocated_super(::TSD::ShapeArchive* super);

  // optional .TSP.Reference connected_from = 2;
  inline bool has_connected_from() const;
  inline void clear_connected_from();
  static const int kConnectedFromFieldNumber = 2;
  inline const ::TSP::Reference& connected_from() const;
  inline ::TSP::Reference* mutable_connected_from();
  inline ::TSP::Reference* release_connected_from();
  inline void set_allocated_connected_from(::TSP::Reference* connected_from);

  // optional .TSP.Reference connected_to = 3;
  inline bool has_connected_to() const;
  inline void clear_connected_to();
  static const int kConnectedToFieldNumber = 3;
  inline const ::TSP::Reference& connected_to() const;
  inline ::TSP::Reference* mutable_connected_to();
  inline ::TSP::Reference* release_connected_to();
  inline void set_allocated_connected_to(::TSP::Reference* connected_to);

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLineArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_connected_from();
  inline void clear_has_connected_from();
  inline void set_has_connected_to();
  inline void clear_has_connected_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::ShapeArchive* super_;
  ::TSP::Reference* connected_from_;
  ::TSP::Reference* connected_to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ConnectionLineArchive* default_instance_;
};
// -------------------------------------------------------------------

class ImageArchive : public ::google::protobuf::Message {
 public:
  ImageArchive();
  virtual ~ImageArchive();

  ImageArchive(const ImageArchive& from);

  inline ImageArchive& operator=(const ImageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageArchive& default_instance();

  void Swap(ImageArchive* other);

  // implements Message ----------------------------------------------

  ImageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageArchive& from);
  void MergeFrom(const ImageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.DrawableArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::DrawableArchive& super() const;
  inline ::TSD::DrawableArchive* mutable_super();
  inline ::TSD::DrawableArchive* release_super();
  inline void set_allocated_super(::TSD::DrawableArchive* super);

  // optional .TSP.DataReference data = 11;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 11;
  inline const ::TSP::DataReference& data() const;
  inline ::TSP::DataReference* mutable_data();
  inline ::TSP::DataReference* release_data();
  inline void set_allocated_data(::TSP::DataReference* data);

  // optional .TSP.Reference style = 3;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 3;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // optional .TSP.Size originalSize = 4;
  inline bool has_originalsize() const;
  inline void clear_originalsize();
  static const int kOriginalSizeFieldNumber = 4;
  inline const ::TSP::Size& originalsize() const;
  inline ::TSP::Size* mutable_originalsize();
  inline ::TSP::Size* release_originalsize();
  inline void set_allocated_originalsize(::TSP::Size* originalsize);

  // optional .TSP.Reference mask = 5;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 5;
  inline const ::TSP::Reference& mask() const;
  inline ::TSP::Reference* mutable_mask();
  inline ::TSP::Reference* release_mask();
  inline void set_allocated_mask(::TSP::Reference* mask);

  // optional .TSP.DataReference thumbnailData = 12;
  inline bool has_thumbnaildata() const;
  inline void clear_thumbnaildata();
  static const int kThumbnailDataFieldNumber = 12;
  inline const ::TSP::DataReference& thumbnaildata() const;
  inline ::TSP::DataReference* mutable_thumbnaildata();
  inline ::TSP::DataReference* release_thumbnaildata();
  inline void set_allocated_thumbnaildata(::TSP::DataReference* thumbnaildata);

  // optional uint32 flags = 7;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional .TSP.DataReference originalData = 13;
  inline bool has_originaldata() const;
  inline void clear_originaldata();
  static const int kOriginalDataFieldNumber = 13;
  inline const ::TSP::DataReference& originaldata() const;
  inline ::TSP::DataReference* mutable_originaldata();
  inline ::TSP::DataReference* release_originaldata();
  inline void set_allocated_originaldata(::TSP::DataReference* originaldata);

  // optional .TSP.Size naturalSize = 9;
  inline bool has_naturalsize() const;
  inline void clear_naturalsize();
  static const int kNaturalSizeFieldNumber = 9;
  inline const ::TSP::Size& naturalsize() const;
  inline ::TSP::Size* mutable_naturalsize();
  inline ::TSP::Size* release_naturalsize();
  inline void set_allocated_naturalsize(::TSP::Size* naturalsize);

  // optional .TSP.Path instantAlphaPath = 10;
  inline bool has_instantalphapath() const;
  inline void clear_instantalphapath();
  static const int kInstantAlphaPathFieldNumber = 10;
  inline const ::TSP::Path& instantalphapath() const;
  inline ::TSP::Path* mutable_instantalphapath();
  inline ::TSP::Path* release_instantalphapath();
  inline void set_allocated_instantalphapath(::TSP::Path* instantalphapath);

  // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
  inline bool has_imageadjustments() const;
  inline void clear_imageadjustments();
  static const int kImageAdjustmentsFieldNumber = 14;
  inline const ::TSD::ImageAdjustmentsArchive& imageadjustments() const;
  inline ::TSD::ImageAdjustmentsArchive* mutable_imageadjustments();
  inline ::TSD::ImageAdjustmentsArchive* release_imageadjustments();
  inline void set_allocated_imageadjustments(::TSD::ImageAdjustmentsArchive* imageadjustments);

  // optional .TSP.DataReference enhancedImageData = 17;
  inline bool has_enhancedimagedata() const;
  inline void clear_enhancedimagedata();
  static const int kEnhancedImageDataFieldNumber = 17;
  inline const ::TSP::DataReference& enhancedimagedata() const;
  inline ::TSP::DataReference* mutable_enhancedimagedata();
  inline ::TSP::DataReference* release_enhancedimagedata();
  inline void set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata);

  // optional .TSP.DataReference adjustedImageData = 15;
  inline bool has_adjustedimagedata() const;
  inline void clear_adjustedimagedata();
  static const int kAdjustedImageDataFieldNumber = 15;
  inline const ::TSP::DataReference& adjustedimagedata() const;
  inline ::TSP::DataReference* mutable_adjustedimagedata();
  inline ::TSP::DataReference* release_adjustedimagedata();
  inline void set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata);

  // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
  inline bool has_thumbnailadjustedimagedata() const;
  inline void clear_thumbnailadjustedimagedata();
  static const int kThumbnailAdjustedImageDataFieldNumber = 16;
  inline const ::TSP::DataReference& thumbnailadjustedimagedata() const;
  inline ::TSP::DataReference* mutable_thumbnailadjustedimagedata();
  inline ::TSP::DataReference* release_thumbnailadjustedimagedata();
  inline void set_allocated_thumbnailadjustedimagedata(::TSP::DataReference* thumbnailadjustedimagedata);

  // optional bool interpretsUntaggedImageDataAsGeneric = 18;
  inline bool has_interpretsuntaggedimagedataasgeneric() const;
  inline void clear_interpretsuntaggedimagedataasgeneric();
  static const int kInterpretsUntaggedImageDataAsGenericFieldNumber = 18;
  inline bool interpretsuntaggedimagedataasgeneric() const;
  inline void set_interpretsuntaggedimagedataasgeneric(bool value);

  // optional .TSP.Reference database_data = 2;
  inline bool has_database_data() const;
  inline void clear_database_data();
  static const int kDatabaseDataFieldNumber = 2;
  inline const ::TSP::Reference& database_data() const;
  inline ::TSP::Reference* mutable_database_data();
  inline ::TSP::Reference* release_database_data();
  inline void set_allocated_database_data(::TSP::Reference* database_data);

  // optional .TSP.Reference database_thumbnailData = 6;
  inline bool has_database_thumbnaildata() const;
  inline void clear_database_thumbnaildata();
  static const int kDatabaseThumbnailDataFieldNumber = 6;
  inline const ::TSP::Reference& database_thumbnaildata() const;
  inline ::TSP::Reference* mutable_database_thumbnaildata();
  inline ::TSP::Reference* release_database_thumbnaildata();
  inline void set_allocated_database_thumbnaildata(::TSP::Reference* database_thumbnaildata);

  // optional .TSP.Reference database_originalData = 8;
  inline bool has_database_originaldata() const;
  inline void clear_database_originaldata();
  static const int kDatabaseOriginalDataFieldNumber = 8;
  inline const ::TSP::Reference& database_originaldata() const;
  inline ::TSP::Reference* mutable_database_originaldata();
  inline ::TSP::Reference* release_database_originaldata();
  inline void set_allocated_database_originaldata(::TSP::Reference* database_originaldata);

  // @@protoc_insertion_point(class_scope:TSD.ImageArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_originalsize();
  inline void clear_has_originalsize();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_thumbnaildata();
  inline void clear_has_thumbnaildata();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_originaldata();
  inline void clear_has_originaldata();
  inline void set_has_naturalsize();
  inline void clear_has_naturalsize();
  inline void set_has_instantalphapath();
  inline void clear_has_instantalphapath();
  inline void set_has_imageadjustments();
  inline void clear_has_imageadjustments();
  inline void set_has_enhancedimagedata();
  inline void clear_has_enhancedimagedata();
  inline void set_has_adjustedimagedata();
  inline void clear_has_adjustedimagedata();
  inline void set_has_thumbnailadjustedimagedata();
  inline void clear_has_thumbnailadjustedimagedata();
  inline void set_has_interpretsuntaggedimagedataasgeneric();
  inline void clear_has_interpretsuntaggedimagedataasgeneric();
  inline void set_has_database_data();
  inline void clear_has_database_data();
  inline void set_has_database_thumbnaildata();
  inline void clear_has_database_thumbnaildata();
  inline void set_has_database_originaldata();
  inline void clear_has_database_originaldata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::DrawableArchive* super_;
  ::TSP::DataReference* data_;
  ::TSP::Reference* style_;
  ::TSP::Size* originalsize_;
  ::TSP::Reference* mask_;
  ::TSP::DataReference* thumbnaildata_;
  ::TSP::DataReference* originaldata_;
  ::TSP::Size* naturalsize_;
  ::TSP::Path* instantalphapath_;
  ::TSD::ImageAdjustmentsArchive* imageadjustments_;
  ::google::protobuf::uint32 flags_;
  bool interpretsuntaggedimagedataasgeneric_;
  ::TSP::DataReference* enhancedimagedata_;
  ::TSP::DataReference* adjustedimagedata_;
  ::TSP::DataReference* thumbnailadjustedimagedata_;
  ::TSP::Reference* database_data_;
  ::TSP::Reference* database_thumbnaildata_;
  ::TSP::Reference* database_originaldata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ImageArchive* default_instance_;
};
// -------------------------------------------------------------------

class MaskArchive : public ::google::protobuf::Message {
 public:
  MaskArchive();
  virtual ~MaskArchive();

  MaskArchive(const MaskArchive& from);

  inline MaskArchive& operator=(const MaskArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaskArchive& default_instance();

  void Swap(MaskArchive* other);

  // implements Message ----------------------------------------------

  MaskArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaskArchive& from);
  void MergeFrom(const MaskArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.DrawableArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::DrawableArchive& super() const;
  inline ::TSD::DrawableArchive* mutable_super();
  inline ::TSD::DrawableArchive* release_super();
  inline void set_allocated_super(::TSD::DrawableArchive* super);

  // optional .TSD.PathSourceArchive pathsource = 2;
  inline bool has_pathsource() const;
  inline void clear_pathsource();
  static const int kPathsourceFieldNumber = 2;
  inline const ::TSD::PathSourceArchive& pathsource() const;
  inline ::TSD::PathSourceArchive* mutable_pathsource();
  inline ::TSD::PathSourceArchive* release_pathsource();
  inline void set_allocated_pathsource(::TSD::PathSourceArchive* pathsource);

  // @@protoc_insertion_point(class_scope:TSD.MaskArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_pathsource();
  inline void clear_has_pathsource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::DrawableArchive* super_;
  ::TSD::PathSourceArchive* pathsource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static MaskArchive* default_instance_;
};
// -------------------------------------------------------------------

class MovieArchive : public ::google::protobuf::Message {
 public:
  MovieArchive();
  virtual ~MovieArchive();

  MovieArchive(const MovieArchive& from);

  inline MovieArchive& operator=(const MovieArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieArchive& default_instance();

  void Swap(MovieArchive* other);

  // implements Message ----------------------------------------------

  MovieArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MovieArchive& from);
  void MergeFrom(const MovieArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MovieArchive_MovieLoopOption MovieLoopOption;
  static const MovieLoopOption None = MovieArchive_MovieLoopOption_None;
  static const MovieLoopOption Repeat = MovieArchive_MovieLoopOption_Repeat;
  static const MovieLoopOption BackAndForth = MovieArchive_MovieLoopOption_BackAndForth;
  static inline bool MovieLoopOption_IsValid(int value) {
    return MovieArchive_MovieLoopOption_IsValid(value);
  }
  static const MovieLoopOption MovieLoopOption_MIN =
    MovieArchive_MovieLoopOption_MovieLoopOption_MIN;
  static const MovieLoopOption MovieLoopOption_MAX =
    MovieArchive_MovieLoopOption_MovieLoopOption_MAX;
  static const int MovieLoopOption_ARRAYSIZE =
    MovieArchive_MovieLoopOption_MovieLoopOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MovieLoopOption_descriptor() {
    return MovieArchive_MovieLoopOption_descriptor();
  }
  static inline const ::std::string& MovieLoopOption_Name(MovieLoopOption value) {
    return MovieArchive_MovieLoopOption_Name(value);
  }
  static inline bool MovieLoopOption_Parse(const ::std::string& name,
      MovieLoopOption* value) {
    return MovieArchive_MovieLoopOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSD.DrawableArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::DrawableArchive& super() const;
  inline ::TSD::DrawableArchive* mutable_super();
  inline ::TSD::DrawableArchive* release_super();
  inline void set_allocated_super(::TSD::DrawableArchive* super);

  // optional .TSP.DataReference movieData = 14;
  inline bool has_moviedata() const;
  inline void clear_moviedata();
  static const int kMovieDataFieldNumber = 14;
  inline const ::TSP::DataReference& moviedata() const;
  inline ::TSP::DataReference* mutable_moviedata();
  inline ::TSP::DataReference* release_moviedata();
  inline void set_allocated_moviedata(::TSP::DataReference* moviedata);

  // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
  inline bool has_importedauxiliarymoviedata() const;
  inline void clear_importedauxiliarymoviedata();
  static const int kImportedAuxiliaryMovieDataFieldNumber = 22;
  inline const ::TSP::DataReference& importedauxiliarymoviedata() const;
  inline ::TSP::DataReference* mutable_importedauxiliarymoviedata();
  inline ::TSP::DataReference* release_importedauxiliarymoviedata();
  inline void set_allocated_importedauxiliarymoviedata(::TSP::DataReference* importedauxiliarymoviedata);

  // optional string movieRemoteURL = 17;
  inline bool has_movieremoteurl() const;
  inline void clear_movieremoteurl();
  static const int kMovieRemoteURLFieldNumber = 17;
  inline const ::std::string& movieremoteurl() const;
  inline void set_movieremoteurl(const ::std::string& value);
  inline void set_movieremoteurl(const char* value);
  inline void set_movieremoteurl(const char* value, size_t size);
  inline ::std::string* mutable_movieremoteurl();
  inline ::std::string* release_movieremoteurl();
  inline void set_allocated_movieremoteurl(::std::string* movieremoteurl);

  // optional float startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline float starttime() const;
  inline void set_starttime(float value);

  // optional float endTime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 4;
  inline float endtime() const;
  inline void set_endtime(float value);

  // optional float posterTime = 5;
  inline bool has_postertime() const;
  inline void clear_postertime();
  static const int kPosterTimeFieldNumber = 5;
  inline float postertime() const;
  inline void set_postertime(float value);

  // optional uint32 loopOptionAsInteger = 6 [deprecated = true];
  inline bool has_loopoptionasinteger() const PROTOBUF_DEPRECATED;
  inline void clear_loopoptionasinteger() PROTOBUF_DEPRECATED;
  static const int kLoopOptionAsIntegerFieldNumber = 6;
  inline ::google::protobuf::uint32 loopoptionasinteger() const PROTOBUF_DEPRECATED;
  inline void set_loopoptionasinteger(::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;

  // optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
  inline bool has_loop_option() const;
  inline void clear_loop_option();
  static const int kLoopOptionFieldNumber = 24;
  inline ::TSD::MovieArchive_MovieLoopOption loop_option() const;
  inline void set_loop_option(::TSD::MovieArchive_MovieLoopOption value);

  // optional float volume = 7;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 7;
  inline float volume() const;
  inline void set_volume(float value);

  // optional bool autoPlay = 8 [deprecated = true];
  inline bool has_autoplay() const PROTOBUF_DEPRECATED;
  inline void clear_autoplay() PROTOBUF_DEPRECATED;
  static const int kAutoPlayFieldNumber = 8;
  inline bool autoplay() const PROTOBUF_DEPRECATED;
  inline void set_autoplay(bool value) PROTOBUF_DEPRECATED;

  // optional bool audioOnly = 9;
  inline bool has_audioonly() const;
  inline void clear_audioonly();
  static const int kAudioOnlyFieldNumber = 9;
  inline bool audioonly() const;
  inline void set_audioonly(bool value);

  // optional bool streaming = 18;
  inline bool has_streaming() const;
  inline void clear_streaming();
  static const int kStreamingFieldNumber = 18;
  inline bool streaming() const;
  inline void set_streaming(bool value);

  // optional .TSP.DataReference posterImageData = 15;
  inline bool has_posterimagedata() const;
  inline void clear_posterimagedata();
  static const int kPosterImageDataFieldNumber = 15;
  inline const ::TSP::DataReference& posterimagedata() const;
  inline ::TSP::DataReference* mutable_posterimagedata();
  inline ::TSP::DataReference* release_posterimagedata();
  inline void set_allocated_posterimagedata(::TSP::DataReference* posterimagedata);

  // optional .TSP.DataReference audioOnlyImageData = 16;
  inline bool has_audioonlyimagedata() const;
  inline void clear_audioonlyimagedata();
  static const int kAudioOnlyImageDataFieldNumber = 16;
  inline const ::TSP::DataReference& audioonlyimagedata() const;
  inline ::TSP::DataReference* mutable_audioonlyimagedata();
  inline ::TSP::DataReference* release_audioonlyimagedata();
  inline void set_allocated_audioonlyimagedata(::TSP::DataReference* audioonlyimagedata);

  // optional bool poster_image_generated_with_alpha_support = 23;
  inline bool has_poster_image_generated_with_alpha_support() const;
  inline void clear_poster_image_generated_with_alpha_support();
  static const int kPosterImageGeneratedWithAlphaSupportFieldNumber = 23;
  inline bool poster_image_generated_with_alpha_support() const;
  inline void set_poster_image_generated_with_alpha_support(bool value);

  // optional uint32 playableState = 12;
  inline bool has_playablestate() const;
  inline void clear_playablestate();
  static const int kPlayableStateFieldNumber = 12;
  inline ::google::protobuf::uint32 playablestate() const;
  inline void set_playablestate(::google::protobuf::uint32 value);

  // optional uint32 flags = 13;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 13;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional .TSP.Reference database_movieData = 2;
  inline bool has_database_moviedata() const;
  inline void clear_database_moviedata();
  static const int kDatabaseMovieDataFieldNumber = 2;
  inline const ::TSP::Reference& database_moviedata() const;
  inline ::TSP::Reference* mutable_database_moviedata();
  inline ::TSP::Reference* release_database_moviedata();
  inline void set_allocated_database_moviedata(::TSP::Reference* database_moviedata);

  // optional .TSP.Reference database_posterImageData = 10;
  inline bool has_database_posterimagedata() const;
  inline void clear_database_posterimagedata();
  static const int kDatabasePosterImageDataFieldNumber = 10;
  inline const ::TSP::Reference& database_posterimagedata() const;
  inline ::TSP::Reference* mutable_database_posterimagedata();
  inline ::TSP::Reference* release_database_posterimagedata();
  inline void set_allocated_database_posterimagedata(::TSP::Reference* database_posterimagedata);

  // optional .TSP.Reference database_audioOnlyImageData = 11;
  inline bool has_database_audioonlyimagedata() const;
  inline void clear_database_audioonlyimagedata();
  static const int kDatabaseAudioOnlyImageDataFieldNumber = 11;
  inline const ::TSP::Reference& database_audioonlyimagedata() const;
  inline ::TSP::Reference* mutable_database_audioonlyimagedata();
  inline ::TSP::Reference* release_database_audioonlyimagedata();
  inline void set_allocated_database_audioonlyimagedata(::TSP::Reference* database_audioonlyimagedata);

  // optional .TSP.Reference style = 19;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 19;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // optional .TSP.Size originalSize = 20;
  inline bool has_originalsize() const;
  inline void clear_originalsize();
  static const int kOriginalSizeFieldNumber = 20;
  inline const ::TSP::Size& originalsize() const;
  inline ::TSP::Size* mutable_originalsize();
  inline ::TSP::Size* release_originalsize();
  inline void set_allocated_originalsize(::TSP::Size* originalsize);

  // optional .TSP.Size naturalSize = 21;
  inline bool has_naturalsize() const;
  inline void clear_naturalsize();
  static const int kNaturalSizeFieldNumber = 21;
  inline const ::TSP::Size& naturalsize() const;
  inline ::TSP::Size* mutable_naturalsize();
  inline ::TSP::Size* release_naturalsize();
  inline void set_allocated_naturalsize(::TSP::Size* naturalsize);

  // @@protoc_insertion_point(class_scope:TSD.MovieArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_moviedata();
  inline void clear_has_moviedata();
  inline void set_has_importedauxiliarymoviedata();
  inline void clear_has_importedauxiliarymoviedata();
  inline void set_has_movieremoteurl();
  inline void clear_has_movieremoteurl();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_postertime();
  inline void clear_has_postertime();
  inline void set_has_loopoptionasinteger();
  inline void clear_has_loopoptionasinteger();
  inline void set_has_loop_option();
  inline void clear_has_loop_option();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_autoplay();
  inline void clear_has_autoplay();
  inline void set_has_audioonly();
  inline void clear_has_audioonly();
  inline void set_has_streaming();
  inline void clear_has_streaming();
  inline void set_has_posterimagedata();
  inline void clear_has_posterimagedata();
  inline void set_has_audioonlyimagedata();
  inline void clear_has_audioonlyimagedata();
  inline void set_has_poster_image_generated_with_alpha_support();
  inline void clear_has_poster_image_generated_with_alpha_support();
  inline void set_has_playablestate();
  inline void clear_has_playablestate();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_database_moviedata();
  inline void clear_has_database_moviedata();
  inline void set_has_database_posterimagedata();
  inline void clear_has_database_posterimagedata();
  inline void set_has_database_audioonlyimagedata();
  inline void clear_has_database_audioonlyimagedata();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_originalsize();
  inline void clear_has_originalsize();
  inline void set_has_naturalsize();
  inline void clear_has_naturalsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::DrawableArchive* super_;
  ::TSP::DataReference* moviedata_;
  ::TSP::DataReference* importedauxiliarymoviedata_;
  ::std::string* movieremoteurl_;
  float starttime_;
  float endtime_;
  float postertime_;
  ::google::protobuf::uint32 loopoptionasinteger_;
  int loop_option_;
  float volume_;
  bool autoplay_;
  bool audioonly_;
  bool streaming_;
  bool poster_image_generated_with_alpha_support_;
  ::google::protobuf::uint32 playablestate_;
  ::TSP::DataReference* posterimagedata_;
  ::TSP::DataReference* audioonlyimagedata_;
  ::TSP::Reference* database_moviedata_;
  ::TSP::Reference* database_posterimagedata_;
  ::TSP::Reference* database_audioonlyimagedata_;
  ::TSP::Reference* style_;
  ::TSP::Size* originalsize_;
  ::TSP::Size* naturalsize_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static MovieArchive* default_instance_;
};
// -------------------------------------------------------------------

class ExteriorTextWrapArchive : public ::google::protobuf::Message {
 public:
  ExteriorTextWrapArchive();
  virtual ~ExteriorTextWrapArchive();

  ExteriorTextWrapArchive(const ExteriorTextWrapArchive& from);

  inline ExteriorTextWrapArchive& operator=(const ExteriorTextWrapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExteriorTextWrapArchive& default_instance();

  void Swap(ExteriorTextWrapArchive* other);

  // implements Message ----------------------------------------------

  ExteriorTextWrapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExteriorTextWrapArchive& from);
  void MergeFrom(const ExteriorTextWrapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::google::protobuf::uint32 direction() const;
  inline void set_direction(::google::protobuf::uint32 value);

  // optional uint32 fit_type = 3;
  inline bool has_fit_type() const;
  inline void clear_fit_type();
  static const int kFitTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 fit_type() const;
  inline void set_fit_type(::google::protobuf::uint32 value);

  // optional float margin = 4;
  inline bool has_margin() const;
  inline void clear_margin();
  static const int kMarginFieldNumber = 4;
  inline float margin() const;
  inline void set_margin(float value);

  // optional float alpha_threshold = 5;
  inline bool has_alpha_threshold() const;
  inline void clear_alpha_threshold();
  static const int kAlphaThresholdFieldNumber = 5;
  inline float alpha_threshold() const;
  inline void set_alpha_threshold(float value);

  // optional bool is_html_wrap = 6;
  inline bool has_is_html_wrap() const;
  inline void clear_is_html_wrap();
  static const int kIsHtmlWrapFieldNumber = 6;
  inline bool is_html_wrap() const;
  inline void set_is_html_wrap(bool value);

  // @@protoc_insertion_point(class_scope:TSD.ExteriorTextWrapArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_fit_type();
  inline void clear_has_fit_type();
  inline void set_has_margin();
  inline void clear_has_margin();
  inline void set_has_alpha_threshold();
  inline void clear_has_alpha_threshold();
  inline void set_has_is_html_wrap();
  inline void clear_has_is_html_wrap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::uint32 fit_type_;
  float margin_;
  float alpha_threshold_;
  bool is_html_wrap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static ExteriorTextWrapArchive* default_instance_;
};
// -------------------------------------------------------------------

class GuideArchive : public ::google::protobuf::Message {
 public:
  GuideArchive();
  virtual ~GuideArchive();

  GuideArchive(const GuideArchive& from);

  inline GuideArchive& operator=(const GuideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideArchive& default_instance();

  void Swap(GuideArchive* other);

  // implements Message ----------------------------------------------

  GuideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideArchive& from);
  void MergeFrom(const GuideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GuideArchive_GuideType GuideType;
  static const GuideType Horizontal = GuideArchive_GuideType_Horizontal;
  static const GuideType Vertical = GuideArchive_GuideType_Vertical;
  static inline bool GuideType_IsValid(int value) {
    return GuideArchive_GuideType_IsValid(value);
  }
  static const GuideType GuideType_MIN =
    GuideArchive_GuideType_GuideType_MIN;
  static const GuideType GuideType_MAX =
    GuideArchive_GuideType_GuideType_MAX;
  static const int GuideType_ARRAYSIZE =
    GuideArchive_GuideType_GuideType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GuideType_descriptor() {
    return GuideArchive_GuideType_descriptor();
  }
  static inline const ::std::string& GuideType_Name(GuideType value) {
    return GuideArchive_GuideType_Name(value);
  }
  static inline bool GuideType_Parse(const ::std::string& name,
      GuideType* value) {
    return GuideArchive_GuideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSD.GuideArchive.GuideType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSD::GuideArchive_GuideType type() const;
  inline void set_type(::TSD::GuideArchive_GuideType value);

  // optional float offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline float offset() const;
  inline void set_offset(float value);

  // optional float start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline float start() const;
  inline void set_start(float value);

  // optional float end = 4;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 4;
  inline float end() const;
  inline void set_end(float value);

  // optional bool dynamic = 5;
  inline bool has_dynamic() const;
  inline void clear_dynamic();
  static const int kDynamicFieldNumber = 5;
  inline bool dynamic() const;
  inline void set_dynamic(bool value);

  // optional bool infinite = 6;
  inline bool has_infinite() const;
  inline void clear_infinite();
  static const int kInfiniteFieldNumber = 6;
  inline bool infinite() const;
  inline void set_infinite(bool value);

  // @@protoc_insertion_point(class_scope:TSD.GuideArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_dynamic();
  inline void clear_has_dynamic();
  inline void set_has_infinite();
  inline void clear_has_infinite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float offset_;
  float start_;
  float end_;
  bool dynamic_;
  bool infinite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static GuideArchive* default_instance_;
};
// -------------------------------------------------------------------

class UserDefinedGuideArchive : public ::google::protobuf::Message {
 public:
  UserDefinedGuideArchive();
  virtual ~UserDefinedGuideArchive();

  UserDefinedGuideArchive(const UserDefinedGuideArchive& from);

  inline UserDefinedGuideArchive& operator=(const UserDefinedGuideArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDefinedGuideArchive& default_instance();

  void Swap(UserDefinedGuideArchive* other);

  // implements Message ----------------------------------------------

  UserDefinedGuideArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserDefinedGuideArchive& from);
  void MergeFrom(const UserDefinedGuideArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserDefinedGuideArchive_GuideType GuideType;
  static const GuideType Horizontal = UserDefinedGuideArchive_GuideType_Horizontal;
  static const GuideType Vertical = UserDefinedGuideArchive_GuideType_Vertical;
  static inline bool GuideType_IsValid(int value) {
    return UserDefinedGuideArchive_GuideType_IsValid(value);
  }
  static const GuideType GuideType_MIN =
    UserDefinedGuideArchive_GuideType_GuideType_MIN;
  static const GuideType GuideType_MAX =
    UserDefinedGuideArchive_GuideType_GuideType_MAX;
  static const int GuideType_ARRAYSIZE =
    UserDefinedGuideArchive_GuideType_GuideType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GuideType_descriptor() {
    return UserDefinedGuideArchive_GuideType_descriptor();
  }
  static inline const ::std::string& GuideType_Name(GuideType value) {
    return UserDefinedGuideArchive_GuideType_Name(value);
  }
  static inline bool GuideType_Parse(const ::std::string& name,
      GuideType* value) {
    return UserDefinedGuideArchive_GuideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::TSD::UserDefinedGuideArchive_GuideType type() const;
  inline void set_type(::TSD::UserDefinedGuideArchive_GuideType value);

  // optional float position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline float position() const;
  inline void set_position(float value);

  // @@protoc_insertion_point(class_scope:TSD.UserDefinedGuideArchive)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static UserDefinedGuideArchive* default_instance_;
};
// -------------------------------------------------------------------

class GuideStorageArchive : public ::google::protobuf::Message {
 public:
  GuideStorageArchive();
  virtual ~GuideStorageArchive();

  GuideStorageArchive(const GuideStorageArchive& from);

  inline GuideStorageArchive& operator=(const GuideStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideStorageArchive& default_instance();

  void Swap(GuideStorageArchive* other);

  // implements Message ----------------------------------------------

  GuideStorageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideStorageArchive& from);
  void MergeFrom(const GuideStorageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  inline int userdefinedguides_size() const;
  inline void clear_userdefinedguides();
  static const int kUserDefinedGuidesFieldNumber = 1;
  inline const ::TSD::UserDefinedGuideArchive& userdefinedguides(int index) const;
  inline ::TSD::UserDefinedGuideArchive* mutable_userdefinedguides(int index);
  inline ::TSD::UserDefinedGuideArchive* add_userdefinedguides();
  inline const ::google::protobuf::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >&
      userdefinedguides() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >*
      mutable_userdefinedguides();

  // @@protoc_insertion_point(class_scope:TSD.GuideStorageArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSD::UserDefinedGuideArchive > userdefinedguides_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static GuideStorageArchive* default_instance_;
};
// -------------------------------------------------------------------

class CanvasSelectionArchive : public ::google::protobuf::Message {
 public:
  CanvasSelectionArchive();
  virtual ~CanvasSelectionArchive();

  CanvasSelectionArchive(const CanvasSelectionArchive& from);

  inline CanvasSelectionArchive& operator=(const CanvasSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CanvasSelectionArchive& default_instance();

  void Swap(CanvasSelectionArchive* other);

  // implements Message ----------------------------------------------

  CanvasSelectionArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CanvasSelectionArchive& from);
  void MergeFrom(const CanvasSelectionArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::TSP::Reference& infos(int index) const;
  inline ::TSP::Reference* mutable_infos(int index);
  inline ::TSP::Reference* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();

  // optional .TSP.Reference container = 2;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 2;
  inline const ::TSP::Reference& container() const;
  inline ::TSP::Reference* mutable_container();
  inline ::TSP::Reference* release_container();
  inline void set_allocated_container(::TSP::Reference* container);

  // @@protoc_insertion_point(class_scope:TSD.CanvasSelectionArchive)
 private:
  inline void set_has_container();
  inline void clear_has_container();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > infos_;
  ::TSP::Reference* container_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static CanvasSelectionArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommentStorageArchive : public ::google::protobuf::Message {
 public:
  CommentStorageArchive();
  virtual ~CommentStorageArchive();

  CommentStorageArchive(const CommentStorageArchive& from);

  inline CommentStorageArchive& operator=(const CommentStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentStorageArchive& default_instance();

  void Swap(CommentStorageArchive* other);

  // implements Message ----------------------------------------------

  CommentStorageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentStorageArchive& from);
  void MergeFrom(const CommentStorageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .TSP.Date creation_date = 2;
  inline bool has_creation_date() const;
  inline void clear_creation_date();
  static const int kCreationDateFieldNumber = 2;
  inline const ::TSP::Date& creation_date() const;
  inline ::TSP::Date* mutable_creation_date();
  inline ::TSP::Date* release_creation_date();
  inline void set_allocated_creation_date(::TSP::Date* creation_date);

  // optional .TSP.Reference author = 3;
  inline bool has_author() const;
  inline void clear_author();
  static const int kAuthorFieldNumber = 3;
  inline const ::TSP::Reference& author() const;
  inline ::TSP::Reference* mutable_author();
  inline ::TSP::Reference* release_author();
  inline void set_allocated_author(::TSP::Reference* author);

  // @@protoc_insertion_point(class_scope:TSD.CommentStorageArchive)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_creation_date();
  inline void clear_has_creation_date();
  inline void set_has_author();
  inline void clear_has_author();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::TSP::Date* creation_date_;
  ::TSP::Reference* author_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSDArchives_2eproto();
  friend void protobuf_AssignDesc_TSDArchives_2eproto();
  friend void protobuf_ShutdownFile_TSDArchives_2eproto();

  void InitAsDefaultInstance();
  static CommentStorageArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// EdgeInsetsArchive

// required float top = 1;
inline bool EdgeInsetsArchive::has_top() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeInsetsArchive::set_has_top() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeInsetsArchive::clear_has_top() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeInsetsArchive::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline float EdgeInsetsArchive::top() const {
  return top_;
}
inline void EdgeInsetsArchive::set_top(float value) {
  set_has_top();
  top_ = value;
}

// required float left = 2;
inline bool EdgeInsetsArchive::has_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgeInsetsArchive::set_has_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgeInsetsArchive::clear_has_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgeInsetsArchive::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline float EdgeInsetsArchive::left() const {
  return left_;
}
inline void EdgeInsetsArchive::set_left(float value) {
  set_has_left();
  left_ = value;
}

// required float bottom = 3;
inline bool EdgeInsetsArchive::has_bottom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EdgeInsetsArchive::set_has_bottom() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EdgeInsetsArchive::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EdgeInsetsArchive::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline float EdgeInsetsArchive::bottom() const {
  return bottom_;
}
inline void EdgeInsetsArchive::set_bottom(float value) {
  set_has_bottom();
  bottom_ = value;
}

// required float right = 4;
inline bool EdgeInsetsArchive::has_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EdgeInsetsArchive::set_has_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EdgeInsetsArchive::clear_has_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EdgeInsetsArchive::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline float EdgeInsetsArchive::right() const {
  return right_;
}
inline void EdgeInsetsArchive::set_right(float value) {
  set_has_right();
  right_ = value;
}

// -------------------------------------------------------------------

// GeometryArchive

// optional .TSP.Point position = 1;
inline bool GeometryArchive::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeometryArchive::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeometryArchive::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeometryArchive::clear_position() {
  if (position_ != NULL) position_->::TSP::Point::Clear();
  clear_has_position();
}
inline const ::TSP::Point& GeometryArchive::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::TSP::Point* GeometryArchive::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::TSP::Point;
  return position_;
}
inline ::TSP::Point* GeometryArchive::release_position() {
  clear_has_position();
  ::TSP::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void GeometryArchive::set_allocated_position(::TSP::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional .TSP.Size size = 2;
inline bool GeometryArchive::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeometryArchive::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeometryArchive::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeometryArchive::clear_size() {
  if (size_ != NULL) size_->::TSP::Size::Clear();
  clear_has_size();
}
inline const ::TSP::Size& GeometryArchive::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::TSP::Size* GeometryArchive::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::TSP::Size;
  return size_;
}
inline ::TSP::Size* GeometryArchive::release_size() {
  clear_has_size();
  ::TSP::Size* temp = size_;
  size_ = NULL;
  return temp;
}
inline void GeometryArchive::set_allocated_size(::TSP::Size* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// optional uint32 flags = 3;
inline bool GeometryArchive::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeometryArchive::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeometryArchive::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeometryArchive::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 GeometryArchive::flags() const {
  return flags_;
}
inline void GeometryArchive::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional float angle = 4;
inline bool GeometryArchive::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeometryArchive::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeometryArchive::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeometryArchive::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float GeometryArchive::angle() const {
  return angle_;
}
inline void GeometryArchive::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// PointPathSourceArchive

// optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
inline bool PointPathSourceArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointPathSourceArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointPathSourceArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointPathSourceArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::type() const {
  return static_cast< ::TSD::PointPathSourceArchive_PointPathSourceType >(type_);
}
inline void PointPathSourceArchive::set_type(::TSD::PointPathSourceArchive_PointPathSourceType value) {
  assert(::TSD::PointPathSourceArchive_PointPathSourceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TSP.Point point = 2;
inline bool PointPathSourceArchive::has_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointPathSourceArchive::set_has_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointPathSourceArchive::clear_has_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointPathSourceArchive::clear_point() {
  if (point_ != NULL) point_->::TSP::Point::Clear();
  clear_has_point();
}
inline const ::TSP::Point& PointPathSourceArchive::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::TSP::Point* PointPathSourceArchive::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::TSP::Point;
  return point_;
}
inline ::TSP::Point* PointPathSourceArchive::release_point() {
  clear_has_point();
  ::TSP::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline void PointPathSourceArchive::set_allocated_point(::TSP::Point* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// optional .TSP.Size naturalSize = 3;
inline bool PointPathSourceArchive::has_naturalsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointPathSourceArchive::set_has_naturalsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointPathSourceArchive::clear_has_naturalsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointPathSourceArchive::clear_naturalsize() {
  if (naturalsize_ != NULL) naturalsize_->::TSP::Size::Clear();
  clear_has_naturalsize();
}
inline const ::TSP::Size& PointPathSourceArchive::naturalsize() const {
  return naturalsize_ != NULL ? *naturalsize_ : *default_instance_->naturalsize_;
}
inline ::TSP::Size* PointPathSourceArchive::mutable_naturalsize() {
  set_has_naturalsize();
  if (naturalsize_ == NULL) naturalsize_ = new ::TSP::Size;
  return naturalsize_;
}
inline ::TSP::Size* PointPathSourceArchive::release_naturalsize() {
  clear_has_naturalsize();
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = NULL;
  return temp;
}
inline void PointPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  delete naturalsize_;
  naturalsize_ = naturalsize;
  if (naturalsize) {
    set_has_naturalsize();
  } else {
    clear_has_naturalsize();
  }
}

// -------------------------------------------------------------------

// ScalarPathSourceArchive

// optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
inline bool ScalarPathSourceArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScalarPathSourceArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScalarPathSourceArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScalarPathSourceArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::type() const {
  return static_cast< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType >(type_);
}
inline void ScalarPathSourceArchive::set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value) {
  assert(::TSD::ScalarPathSourceArchive_ScalarPathSourceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float scalar = 2;
inline bool ScalarPathSourceArchive::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScalarPathSourceArchive::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScalarPathSourceArchive::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScalarPathSourceArchive::clear_scalar() {
  scalar_ = 0;
  clear_has_scalar();
}
inline float ScalarPathSourceArchive::scalar() const {
  return scalar_;
}
inline void ScalarPathSourceArchive::set_scalar(float value) {
  set_has_scalar();
  scalar_ = value;
}

// optional .TSP.Size naturalSize = 3;
inline bool ScalarPathSourceArchive::has_naturalsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScalarPathSourceArchive::set_has_naturalsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScalarPathSourceArchive::clear_has_naturalsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScalarPathSourceArchive::clear_naturalsize() {
  if (naturalsize_ != NULL) naturalsize_->::TSP::Size::Clear();
  clear_has_naturalsize();
}
inline const ::TSP::Size& ScalarPathSourceArchive::naturalsize() const {
  return naturalsize_ != NULL ? *naturalsize_ : *default_instance_->naturalsize_;
}
inline ::TSP::Size* ScalarPathSourceArchive::mutable_naturalsize() {
  set_has_naturalsize();
  if (naturalsize_ == NULL) naturalsize_ = new ::TSP::Size;
  return naturalsize_;
}
inline ::TSP::Size* ScalarPathSourceArchive::release_naturalsize() {
  clear_has_naturalsize();
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = NULL;
  return temp;
}
inline void ScalarPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  delete naturalsize_;
  naturalsize_ = naturalsize;
  if (naturalsize) {
    set_has_naturalsize();
  } else {
    clear_has_naturalsize();
  }
}

// -------------------------------------------------------------------

// BezierPathSourceArchive

// optional string path_string = 1 [deprecated = true];
inline bool BezierPathSourceArchive::has_path_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BezierPathSourceArchive::set_has_path_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BezierPathSourceArchive::clear_has_path_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BezierPathSourceArchive::clear_path_string() {
  if (path_string_ != &::google::protobuf::internal::kEmptyString) {
    path_string_->clear();
  }
  clear_has_path_string();
}
inline const ::std::string& BezierPathSourceArchive::path_string() const {
  return *path_string_;
}
inline void BezierPathSourceArchive::set_path_string(const ::std::string& value) {
  set_has_path_string();
  if (path_string_ == &::google::protobuf::internal::kEmptyString) {
    path_string_ = new ::std::string;
  }
  path_string_->assign(value);
}
inline void BezierPathSourceArchive::set_path_string(const char* value) {
  set_has_path_string();
  if (path_string_ == &::google::protobuf::internal::kEmptyString) {
    path_string_ = new ::std::string;
  }
  path_string_->assign(value);
}
inline void BezierPathSourceArchive::set_path_string(const char* value, size_t size) {
  set_has_path_string();
  if (path_string_ == &::google::protobuf::internal::kEmptyString) {
    path_string_ = new ::std::string;
  }
  path_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BezierPathSourceArchive::mutable_path_string() {
  set_has_path_string();
  if (path_string_ == &::google::protobuf::internal::kEmptyString) {
    path_string_ = new ::std::string;
  }
  return path_string_;
}
inline ::std::string* BezierPathSourceArchive::release_path_string() {
  clear_has_path_string();
  if (path_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_string_;
    path_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BezierPathSourceArchive::set_allocated_path_string(::std::string* path_string) {
  if (path_string_ != &::google::protobuf::internal::kEmptyString) {
    delete path_string_;
  }
  if (path_string) {
    set_has_path_string();
    path_string_ = path_string;
  } else {
    clear_has_path_string();
    path_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Size naturalSize = 2;
inline bool BezierPathSourceArchive::has_naturalsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BezierPathSourceArchive::set_has_naturalsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BezierPathSourceArchive::clear_has_naturalsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BezierPathSourceArchive::clear_naturalsize() {
  if (naturalsize_ != NULL) naturalsize_->::TSP::Size::Clear();
  clear_has_naturalsize();
}
inline const ::TSP::Size& BezierPathSourceArchive::naturalsize() const {
  return naturalsize_ != NULL ? *naturalsize_ : *default_instance_->naturalsize_;
}
inline ::TSP::Size* BezierPathSourceArchive::mutable_naturalsize() {
  set_has_naturalsize();
  if (naturalsize_ == NULL) naturalsize_ = new ::TSP::Size;
  return naturalsize_;
}
inline ::TSP::Size* BezierPathSourceArchive::release_naturalsize() {
  clear_has_naturalsize();
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = NULL;
  return temp;
}
inline void BezierPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  delete naturalsize_;
  naturalsize_ = naturalsize;
  if (naturalsize) {
    set_has_naturalsize();
  } else {
    clear_has_naturalsize();
  }
}

// optional .TSP.Path path = 3;
inline bool BezierPathSourceArchive::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BezierPathSourceArchive::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BezierPathSourceArchive::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BezierPathSourceArchive::clear_path() {
  if (path_ != NULL) path_->::TSP::Path::Clear();
  clear_has_path();
}
inline const ::TSP::Path& BezierPathSourceArchive::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::TSP::Path* BezierPathSourceArchive::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::TSP::Path;
  return path_;
}
inline ::TSP::Path* BezierPathSourceArchive::release_path() {
  clear_has_path();
  ::TSP::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void BezierPathSourceArchive::set_allocated_path(::TSP::Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
}

// -------------------------------------------------------------------

// CalloutPathSourceArchive

// optional .TSP.Size natural_size = 1;
inline bool CalloutPathSourceArchive::has_natural_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalloutPathSourceArchive::set_has_natural_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalloutPathSourceArchive::clear_has_natural_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalloutPathSourceArchive::clear_natural_size() {
  if (natural_size_ != NULL) natural_size_->::TSP::Size::Clear();
  clear_has_natural_size();
}
inline const ::TSP::Size& CalloutPathSourceArchive::natural_size() const {
  return natural_size_ != NULL ? *natural_size_ : *default_instance_->natural_size_;
}
inline ::TSP::Size* CalloutPathSourceArchive::mutable_natural_size() {
  set_has_natural_size();
  if (natural_size_ == NULL) natural_size_ = new ::TSP::Size;
  return natural_size_;
}
inline ::TSP::Size* CalloutPathSourceArchive::release_natural_size() {
  clear_has_natural_size();
  ::TSP::Size* temp = natural_size_;
  natural_size_ = NULL;
  return temp;
}
inline void CalloutPathSourceArchive::set_allocated_natural_size(::TSP::Size* natural_size) {
  delete natural_size_;
  natural_size_ = natural_size;
  if (natural_size) {
    set_has_natural_size();
  } else {
    clear_has_natural_size();
  }
}

// optional .TSP.Point tail_position = 2;
inline bool CalloutPathSourceArchive::has_tail_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalloutPathSourceArchive::set_has_tail_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalloutPathSourceArchive::clear_has_tail_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalloutPathSourceArchive::clear_tail_position() {
  if (tail_position_ != NULL) tail_position_->::TSP::Point::Clear();
  clear_has_tail_position();
}
inline const ::TSP::Point& CalloutPathSourceArchive::tail_position() const {
  return tail_position_ != NULL ? *tail_position_ : *default_instance_->tail_position_;
}
inline ::TSP::Point* CalloutPathSourceArchive::mutable_tail_position() {
  set_has_tail_position();
  if (tail_position_ == NULL) tail_position_ = new ::TSP::Point;
  return tail_position_;
}
inline ::TSP::Point* CalloutPathSourceArchive::release_tail_position() {
  clear_has_tail_position();
  ::TSP::Point* temp = tail_position_;
  tail_position_ = NULL;
  return temp;
}
inline void CalloutPathSourceArchive::set_allocated_tail_position(::TSP::Point* tail_position) {
  delete tail_position_;
  tail_position_ = tail_position;
  if (tail_position) {
    set_has_tail_position();
  } else {
    clear_has_tail_position();
  }
}

// optional float tail_size = 3;
inline bool CalloutPathSourceArchive::has_tail_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CalloutPathSourceArchive::set_has_tail_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CalloutPathSourceArchive::clear_has_tail_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CalloutPathSourceArchive::clear_tail_size() {
  tail_size_ = 0;
  clear_has_tail_size();
}
inline float CalloutPathSourceArchive::tail_size() const {
  return tail_size_;
}
inline void CalloutPathSourceArchive::set_tail_size(float value) {
  set_has_tail_size();
  tail_size_ = value;
}

// optional float corner_radius = 4;
inline bool CalloutPathSourceArchive::has_corner_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CalloutPathSourceArchive::set_has_corner_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CalloutPathSourceArchive::clear_has_corner_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CalloutPathSourceArchive::clear_corner_radius() {
  corner_radius_ = 0;
  clear_has_corner_radius();
}
inline float CalloutPathSourceArchive::corner_radius() const {
  return corner_radius_;
}
inline void CalloutPathSourceArchive::set_corner_radius(float value) {
  set_has_corner_radius();
  corner_radius_ = value;
}

// optional bool center_tail = 5;
inline bool CalloutPathSourceArchive::has_center_tail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CalloutPathSourceArchive::set_has_center_tail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CalloutPathSourceArchive::clear_has_center_tail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CalloutPathSourceArchive::clear_center_tail() {
  center_tail_ = false;
  clear_has_center_tail();
}
inline bool CalloutPathSourceArchive::center_tail() const {
  return center_tail_;
}
inline void CalloutPathSourceArchive::set_center_tail(bool value) {
  set_has_center_tail();
  center_tail_ = value;
}

// -------------------------------------------------------------------

// ConnectionLinePathSourceArchive

// required .TSD.BezierPathSourceArchive super = 1;
inline bool ConnectionLinePathSourceArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionLinePathSourceArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionLinePathSourceArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionLinePathSourceArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::BezierPathSourceArchive::Clear();
  clear_has_super();
}
inline const ::TSD::BezierPathSourceArchive& ConnectionLinePathSourceArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::BezierPathSourceArchive;
  return super_;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::release_super() {
  clear_has_super();
  ::TSD::BezierPathSourceArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ConnectionLinePathSourceArchive::set_allocated_super(::TSD::BezierPathSourceArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
inline bool ConnectionLinePathSourceArchive::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionLinePathSourceArchive::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionLinePathSourceArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionLinePathSourceArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::type() const {
  return static_cast< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType >(type_);
}
inline void ConnectionLinePathSourceArchive::set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value) {
  assert(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float outset_from = 3;
inline bool ConnectionLinePathSourceArchive::has_outset_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectionLinePathSourceArchive::set_has_outset_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectionLinePathSourceArchive::clear_has_outset_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectionLinePathSourceArchive::clear_outset_from() {
  outset_from_ = 0;
  clear_has_outset_from();
}
inline float ConnectionLinePathSourceArchive::outset_from() const {
  return outset_from_;
}
inline void ConnectionLinePathSourceArchive::set_outset_from(float value) {
  set_has_outset_from();
  outset_from_ = value;
}

// optional float outset_to = 4;
inline bool ConnectionLinePathSourceArchive::has_outset_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectionLinePathSourceArchive::set_has_outset_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectionLinePathSourceArchive::clear_has_outset_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectionLinePathSourceArchive::clear_outset_to() {
  outset_to_ = 0;
  clear_has_outset_to();
}
inline float ConnectionLinePathSourceArchive::outset_to() const {
  return outset_to_;
}
inline void ConnectionLinePathSourceArchive::set_outset_to(float value) {
  set_has_outset_to();
  outset_to_ = value;
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive_Node

// required .TSP.Point inControlPoint = 1;
inline bool EditableBezierPathSourceArchive_Node::has_incontrolpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EditableBezierPathSourceArchive_Node::set_has_incontrolpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EditableBezierPathSourceArchive_Node::clear_has_incontrolpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EditableBezierPathSourceArchive_Node::clear_incontrolpoint() {
  if (incontrolpoint_ != NULL) incontrolpoint_->::TSP::Point::Clear();
  clear_has_incontrolpoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::incontrolpoint() const {
  return incontrolpoint_ != NULL ? *incontrolpoint_ : *default_instance_->incontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_incontrolpoint() {
  set_has_incontrolpoint();
  if (incontrolpoint_ == NULL) incontrolpoint_ = new ::TSP::Point;
  return incontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_incontrolpoint() {
  clear_has_incontrolpoint();
  ::TSP::Point* temp = incontrolpoint_;
  incontrolpoint_ = NULL;
  return temp;
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_incontrolpoint(::TSP::Point* incontrolpoint) {
  delete incontrolpoint_;
  incontrolpoint_ = incontrolpoint;
  if (incontrolpoint) {
    set_has_incontrolpoint();
  } else {
    clear_has_incontrolpoint();
  }
}

// required .TSP.Point nodePoint = 2;
inline bool EditableBezierPathSourceArchive_Node::has_nodepoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditableBezierPathSourceArchive_Node::set_has_nodepoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditableBezierPathSourceArchive_Node::clear_has_nodepoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditableBezierPathSourceArchive_Node::clear_nodepoint() {
  if (nodepoint_ != NULL) nodepoint_->::TSP::Point::Clear();
  clear_has_nodepoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::nodepoint() const {
  return nodepoint_ != NULL ? *nodepoint_ : *default_instance_->nodepoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_nodepoint() {
  set_has_nodepoint();
  if (nodepoint_ == NULL) nodepoint_ = new ::TSP::Point;
  return nodepoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_nodepoint() {
  clear_has_nodepoint();
  ::TSP::Point* temp = nodepoint_;
  nodepoint_ = NULL;
  return temp;
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_nodepoint(::TSP::Point* nodepoint) {
  delete nodepoint_;
  nodepoint_ = nodepoint;
  if (nodepoint) {
    set_has_nodepoint();
  } else {
    clear_has_nodepoint();
  }
}

// required .TSP.Point outControlPoint = 3;
inline bool EditableBezierPathSourceArchive_Node::has_outcontrolpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EditableBezierPathSourceArchive_Node::set_has_outcontrolpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EditableBezierPathSourceArchive_Node::clear_has_outcontrolpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EditableBezierPathSourceArchive_Node::clear_outcontrolpoint() {
  if (outcontrolpoint_ != NULL) outcontrolpoint_->::TSP::Point::Clear();
  clear_has_outcontrolpoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::outcontrolpoint() const {
  return outcontrolpoint_ != NULL ? *outcontrolpoint_ : *default_instance_->outcontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_outcontrolpoint() {
  set_has_outcontrolpoint();
  if (outcontrolpoint_ == NULL) outcontrolpoint_ = new ::TSP::Point;
  return outcontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_outcontrolpoint() {
  clear_has_outcontrolpoint();
  ::TSP::Point* temp = outcontrolpoint_;
  outcontrolpoint_ = NULL;
  return temp;
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_outcontrolpoint(::TSP::Point* outcontrolpoint) {
  delete outcontrolpoint_;
  outcontrolpoint_ = outcontrolpoint;
  if (outcontrolpoint) {
    set_has_outcontrolpoint();
  } else {
    clear_has_outcontrolpoint();
  }
}

// required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
inline bool EditableBezierPathSourceArchive_Node::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EditableBezierPathSourceArchive_Node::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EditableBezierPathSourceArchive_Node::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EditableBezierPathSourceArchive_Node::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::TSD::EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_Node::type() const {
  return static_cast< ::TSD::EditableBezierPathSourceArchive_NodeType >(type_);
}
inline void EditableBezierPathSourceArchive_Node::set_type(::TSD::EditableBezierPathSourceArchive_NodeType value) {
  assert(::TSD::EditableBezierPathSourceArchive_NodeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive_Subpath

// repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
inline int EditableBezierPathSourceArchive_Subpath::nodes_size() const {
  return nodes_.size();
}
inline void EditableBezierPathSourceArchive_Subpath::clear_nodes() {
  nodes_.Clear();
}
inline const ::TSD::EditableBezierPathSourceArchive_Node& EditableBezierPathSourceArchive_Subpath::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >&
EditableBezierPathSourceArchive_Subpath::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >*
EditableBezierPathSourceArchive_Subpath::mutable_nodes() {
  return &nodes_;
}

// required bool closed = 2;
inline bool EditableBezierPathSourceArchive_Subpath::has_closed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditableBezierPathSourceArchive_Subpath::set_has_closed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditableBezierPathSourceArchive_Subpath::clear_has_closed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditableBezierPathSourceArchive_Subpath::clear_closed() {
  closed_ = false;
  clear_has_closed();
}
inline bool EditableBezierPathSourceArchive_Subpath::closed() const {
  return closed_;
}
inline void EditableBezierPathSourceArchive_Subpath::set_closed(bool value) {
  set_has_closed();
  closed_ = value;
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive

// repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
inline int EditableBezierPathSourceArchive::subpaths_size() const {
  return subpaths_.size();
}
inline void EditableBezierPathSourceArchive::clear_subpaths() {
  subpaths_.Clear();
}
inline const ::TSD::EditableBezierPathSourceArchive_Subpath& EditableBezierPathSourceArchive::subpaths(int index) const {
  return subpaths_.Get(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::mutable_subpaths(int index) {
  return subpaths_.Mutable(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::add_subpaths() {
  return subpaths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >&
EditableBezierPathSourceArchive::subpaths() const {
  return subpaths_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >*
EditableBezierPathSourceArchive::mutable_subpaths() {
  return &subpaths_;
}

// optional .TSP.Size naturalSize = 2;
inline bool EditableBezierPathSourceArchive::has_naturalsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EditableBezierPathSourceArchive::set_has_naturalsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EditableBezierPathSourceArchive::clear_has_naturalsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EditableBezierPathSourceArchive::clear_naturalsize() {
  if (naturalsize_ != NULL) naturalsize_->::TSP::Size::Clear();
  clear_has_naturalsize();
}
inline const ::TSP::Size& EditableBezierPathSourceArchive::naturalsize() const {
  return naturalsize_ != NULL ? *naturalsize_ : *default_instance_->naturalsize_;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::mutable_naturalsize() {
  set_has_naturalsize();
  if (naturalsize_ == NULL) naturalsize_ = new ::TSP::Size;
  return naturalsize_;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::release_naturalsize() {
  clear_has_naturalsize();
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = NULL;
  return temp;
}
inline void EditableBezierPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  delete naturalsize_;
  naturalsize_ = naturalsize;
  if (naturalsize) {
    set_has_naturalsize();
  } else {
    clear_has_naturalsize();
  }
}

// -------------------------------------------------------------------

// PathSourceArchive

// optional bool horizontalFlip = 1;
inline bool PathSourceArchive::has_horizontalflip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathSourceArchive::set_has_horizontalflip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathSourceArchive::clear_has_horizontalflip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathSourceArchive::clear_horizontalflip() {
  horizontalflip_ = false;
  clear_has_horizontalflip();
}
inline bool PathSourceArchive::horizontalflip() const {
  return horizontalflip_;
}
inline void PathSourceArchive::set_horizontalflip(bool value) {
  set_has_horizontalflip();
  horizontalflip_ = value;
}

// optional bool verticalFlip = 2;
inline bool PathSourceArchive::has_verticalflip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathSourceArchive::set_has_verticalflip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathSourceArchive::clear_has_verticalflip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathSourceArchive::clear_verticalflip() {
  verticalflip_ = false;
  clear_has_verticalflip();
}
inline bool PathSourceArchive::verticalflip() const {
  return verticalflip_;
}
inline void PathSourceArchive::set_verticalflip(bool value) {
  set_has_verticalflip();
  verticalflip_ = value;
}

// optional .TSD.PointPathSourceArchive point_path_source = 3;
inline bool PathSourceArchive::has_point_path_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathSourceArchive::set_has_point_path_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathSourceArchive::clear_has_point_path_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathSourceArchive::clear_point_path_source() {
  if (point_path_source_ != NULL) point_path_source_->::TSD::PointPathSourceArchive::Clear();
  clear_has_point_path_source();
}
inline const ::TSD::PointPathSourceArchive& PathSourceArchive::point_path_source() const {
  return point_path_source_ != NULL ? *point_path_source_ : *default_instance_->point_path_source_;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::mutable_point_path_source() {
  set_has_point_path_source();
  if (point_path_source_ == NULL) point_path_source_ = new ::TSD::PointPathSourceArchive;
  return point_path_source_;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::release_point_path_source() {
  clear_has_point_path_source();
  ::TSD::PointPathSourceArchive* temp = point_path_source_;
  point_path_source_ = NULL;
  return temp;
}
inline void PathSourceArchive::set_allocated_point_path_source(::TSD::PointPathSourceArchive* point_path_source) {
  delete point_path_source_;
  point_path_source_ = point_path_source;
  if (point_path_source) {
    set_has_point_path_source();
  } else {
    clear_has_point_path_source();
  }
}

// optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
inline bool PathSourceArchive::has_scalar_path_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PathSourceArchive::set_has_scalar_path_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PathSourceArchive::clear_has_scalar_path_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PathSourceArchive::clear_scalar_path_source() {
  if (scalar_path_source_ != NULL) scalar_path_source_->::TSD::ScalarPathSourceArchive::Clear();
  clear_has_scalar_path_source();
}
inline const ::TSD::ScalarPathSourceArchive& PathSourceArchive::scalar_path_source() const {
  return scalar_path_source_ != NULL ? *scalar_path_source_ : *default_instance_->scalar_path_source_;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::mutable_scalar_path_source() {
  set_has_scalar_path_source();
  if (scalar_path_source_ == NULL) scalar_path_source_ = new ::TSD::ScalarPathSourceArchive;
  return scalar_path_source_;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::release_scalar_path_source() {
  clear_has_scalar_path_source();
  ::TSD::ScalarPathSourceArchive* temp = scalar_path_source_;
  scalar_path_source_ = NULL;
  return temp;
}
inline void PathSourceArchive::set_allocated_scalar_path_source(::TSD::ScalarPathSourceArchive* scalar_path_source) {
  delete scalar_path_source_;
  scalar_path_source_ = scalar_path_source;
  if (scalar_path_source) {
    set_has_scalar_path_source();
  } else {
    clear_has_scalar_path_source();
  }
}

// optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
inline bool PathSourceArchive::has_bezier_path_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PathSourceArchive::set_has_bezier_path_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PathSourceArchive::clear_has_bezier_path_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PathSourceArchive::clear_bezier_path_source() {
  if (bezier_path_source_ != NULL) bezier_path_source_->::TSD::BezierPathSourceArchive::Clear();
  clear_has_bezier_path_source();
}
inline const ::TSD::BezierPathSourceArchive& PathSourceArchive::bezier_path_source() const {
  return bezier_path_source_ != NULL ? *bezier_path_source_ : *default_instance_->bezier_path_source_;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::mutable_bezier_path_source() {
  set_has_bezier_path_source();
  if (bezier_path_source_ == NULL) bezier_path_source_ = new ::TSD::BezierPathSourceArchive;
  return bezier_path_source_;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::release_bezier_path_source() {
  clear_has_bezier_path_source();
  ::TSD::BezierPathSourceArchive* temp = bezier_path_source_;
  bezier_path_source_ = NULL;
  return temp;
}
inline void PathSourceArchive::set_allocated_bezier_path_source(::TSD::BezierPathSourceArchive* bezier_path_source) {
  delete bezier_path_source_;
  bezier_path_source_ = bezier_path_source;
  if (bezier_path_source) {
    set_has_bezier_path_source();
  } else {
    clear_has_bezier_path_source();
  }
}

// optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
inline bool PathSourceArchive::has_callout_path_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PathSourceArchive::set_has_callout_path_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PathSourceArchive::clear_has_callout_path_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PathSourceArchive::clear_callout_path_source() {
  if (callout_path_source_ != NULL) callout_path_source_->::TSD::CalloutPathSourceArchive::Clear();
  clear_has_callout_path_source();
}
inline const ::TSD::CalloutPathSourceArchive& PathSourceArchive::callout_path_source() const {
  return callout_path_source_ != NULL ? *callout_path_source_ : *default_instance_->callout_path_source_;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::mutable_callout_path_source() {
  set_has_callout_path_source();
  if (callout_path_source_ == NULL) callout_path_source_ = new ::TSD::CalloutPathSourceArchive;
  return callout_path_source_;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::release_callout_path_source() {
  clear_has_callout_path_source();
  ::TSD::CalloutPathSourceArchive* temp = callout_path_source_;
  callout_path_source_ = NULL;
  return temp;
}
inline void PathSourceArchive::set_allocated_callout_path_source(::TSD::CalloutPathSourceArchive* callout_path_source) {
  delete callout_path_source_;
  callout_path_source_ = callout_path_source;
  if (callout_path_source) {
    set_has_callout_path_source();
  } else {
    clear_has_callout_path_source();
  }
}

// optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
inline bool PathSourceArchive::has_connection_line_path_source() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PathSourceArchive::set_has_connection_line_path_source() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PathSourceArchive::clear_has_connection_line_path_source() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PathSourceArchive::clear_connection_line_path_source() {
  if (connection_line_path_source_ != NULL) connection_line_path_source_->::TSD::ConnectionLinePathSourceArchive::Clear();
  clear_has_connection_line_path_source();
}
inline const ::TSD::ConnectionLinePathSourceArchive& PathSourceArchive::connection_line_path_source() const {
  return connection_line_path_source_ != NULL ? *connection_line_path_source_ : *default_instance_->connection_line_path_source_;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::mutable_connection_line_path_source() {
  set_has_connection_line_path_source();
  if (connection_line_path_source_ == NULL) connection_line_path_source_ = new ::TSD::ConnectionLinePathSourceArchive;
  return connection_line_path_source_;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::release_connection_line_path_source() {
  clear_has_connection_line_path_source();
  ::TSD::ConnectionLinePathSourceArchive* temp = connection_line_path_source_;
  connection_line_path_source_ = NULL;
  return temp;
}
inline void PathSourceArchive::set_allocated_connection_line_path_source(::TSD::ConnectionLinePathSourceArchive* connection_line_path_source) {
  delete connection_line_path_source_;
  connection_line_path_source_ = connection_line_path_source;
  if (connection_line_path_source) {
    set_has_connection_line_path_source();
  } else {
    clear_has_connection_line_path_source();
  }
}

// optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
inline bool PathSourceArchive::has_editable_bezier_path_source() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PathSourceArchive::set_has_editable_bezier_path_source() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PathSourceArchive::clear_has_editable_bezier_path_source() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PathSourceArchive::clear_editable_bezier_path_source() {
  if (editable_bezier_path_source_ != NULL) editable_bezier_path_source_->::TSD::EditableBezierPathSourceArchive::Clear();
  clear_has_editable_bezier_path_source();
}
inline const ::TSD::EditableBezierPathSourceArchive& PathSourceArchive::editable_bezier_path_source() const {
  return editable_bezier_path_source_ != NULL ? *editable_bezier_path_source_ : *default_instance_->editable_bezier_path_source_;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::mutable_editable_bezier_path_source() {
  set_has_editable_bezier_path_source();
  if (editable_bezier_path_source_ == NULL) editable_bezier_path_source_ = new ::TSD::EditableBezierPathSourceArchive;
  return editable_bezier_path_source_;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::release_editable_bezier_path_source() {
  clear_has_editable_bezier_path_source();
  ::TSD::EditableBezierPathSourceArchive* temp = editable_bezier_path_source_;
  editable_bezier_path_source_ = NULL;
  return temp;
}
inline void PathSourceArchive::set_allocated_editable_bezier_path_source(::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source) {
  delete editable_bezier_path_source_;
  editable_bezier_path_source_ = editable_bezier_path_source;
  if (editable_bezier_path_source) {
    set_has_editable_bezier_path_source();
  } else {
    clear_has_editable_bezier_path_source();
  }
}

// -------------------------------------------------------------------

// AngleGradientArchive

// optional float gradientangle = 2;
inline bool AngleGradientArchive::has_gradientangle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AngleGradientArchive::set_has_gradientangle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AngleGradientArchive::clear_has_gradientangle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AngleGradientArchive::clear_gradientangle() {
  gradientangle_ = 0;
  clear_has_gradientangle();
}
inline float AngleGradientArchive::gradientangle() const {
  return gradientangle_;
}
inline void AngleGradientArchive::set_gradientangle(float value) {
  set_has_gradientangle();
  gradientangle_ = value;
}

// -------------------------------------------------------------------

// TransformGradientArchive

// optional .TSP.Point start = 1;
inline bool TransformGradientArchive::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformGradientArchive::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformGradientArchive::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformGradientArchive::clear_start() {
  if (start_ != NULL) start_->::TSP::Point::Clear();
  clear_has_start();
}
inline const ::TSP::Point& TransformGradientArchive::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::TSP::Point* TransformGradientArchive::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::TSP::Point;
  return start_;
}
inline ::TSP::Point* TransformGradientArchive::release_start() {
  clear_has_start();
  ::TSP::Point* temp = start_;
  start_ = NULL;
  return temp;
}
inline void TransformGradientArchive::set_allocated_start(::TSP::Point* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// optional .TSP.Point end = 2;
inline bool TransformGradientArchive::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformGradientArchive::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransformGradientArchive::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransformGradientArchive::clear_end() {
  if (end_ != NULL) end_->::TSP::Point::Clear();
  clear_has_end();
}
inline const ::TSP::Point& TransformGradientArchive::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::TSP::Point* TransformGradientArchive::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::TSP::Point;
  return end_;
}
inline ::TSP::Point* TransformGradientArchive::release_end() {
  clear_has_end();
  ::TSP::Point* temp = end_;
  end_ = NULL;
  return temp;
}
inline void TransformGradientArchive::set_allocated_end(::TSP::Point* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
}

// optional .TSP.Size baseNaturalSize = 3;
inline bool TransformGradientArchive::has_basenaturalsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformGradientArchive::set_has_basenaturalsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransformGradientArchive::clear_has_basenaturalsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransformGradientArchive::clear_basenaturalsize() {
  if (basenaturalsize_ != NULL) basenaturalsize_->::TSP::Size::Clear();
  clear_has_basenaturalsize();
}
inline const ::TSP::Size& TransformGradientArchive::basenaturalsize() const {
  return basenaturalsize_ != NULL ? *basenaturalsize_ : *default_instance_->basenaturalsize_;
}
inline ::TSP::Size* TransformGradientArchive::mutable_basenaturalsize() {
  set_has_basenaturalsize();
  if (basenaturalsize_ == NULL) basenaturalsize_ = new ::TSP::Size;
  return basenaturalsize_;
}
inline ::TSP::Size* TransformGradientArchive::release_basenaturalsize() {
  clear_has_basenaturalsize();
  ::TSP::Size* temp = basenaturalsize_;
  basenaturalsize_ = NULL;
  return temp;
}
inline void TransformGradientArchive::set_allocated_basenaturalsize(::TSP::Size* basenaturalsize) {
  delete basenaturalsize_;
  basenaturalsize_ = basenaturalsize;
  if (basenaturalsize) {
    set_has_basenaturalsize();
  } else {
    clear_has_basenaturalsize();
  }
}

// -------------------------------------------------------------------

// GradientArchive_GradientStop

// optional .TSP.Color color = 1;
inline bool GradientArchive_GradientStop::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GradientArchive_GradientStop::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GradientArchive_GradientStop::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GradientArchive_GradientStop::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& GradientArchive_GradientStop::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* GradientArchive_GradientStop::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* GradientArchive_GradientStop::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void GradientArchive_GradientStop::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional float fraction = 2;
inline bool GradientArchive_GradientStop::has_fraction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GradientArchive_GradientStop::set_has_fraction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GradientArchive_GradientStop::clear_has_fraction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GradientArchive_GradientStop::clear_fraction() {
  fraction_ = 0;
  clear_has_fraction();
}
inline float GradientArchive_GradientStop::fraction() const {
  return fraction_;
}
inline void GradientArchive_GradientStop::set_fraction(float value) {
  set_has_fraction();
  fraction_ = value;
}

// optional float inflection = 3;
inline bool GradientArchive_GradientStop::has_inflection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GradientArchive_GradientStop::set_has_inflection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GradientArchive_GradientStop::clear_has_inflection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GradientArchive_GradientStop::clear_inflection() {
  inflection_ = 0;
  clear_has_inflection();
}
inline float GradientArchive_GradientStop::inflection() const {
  return inflection_;
}
inline void GradientArchive_GradientStop::set_inflection(float value) {
  set_has_inflection();
  inflection_ = value;
}

// -------------------------------------------------------------------

// GradientArchive

// optional .TSD.GradientArchive.GradientType type = 1;
inline bool GradientArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GradientArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GradientArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GradientArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::GradientArchive_GradientType GradientArchive::type() const {
  return static_cast< ::TSD::GradientArchive_GradientType >(type_);
}
inline void GradientArchive::set_type(::TSD::GradientArchive_GradientType value) {
  assert(::TSD::GradientArchive_GradientType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .TSD.GradientArchive.GradientStop stops = 2;
inline int GradientArchive::stops_size() const {
  return stops_.size();
}
inline void GradientArchive::clear_stops() {
  stops_.Clear();
}
inline const ::TSD::GradientArchive_GradientStop& GradientArchive::stops(int index) const {
  return stops_.Get(index);
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::mutable_stops(int index) {
  return stops_.Mutable(index);
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::add_stops() {
  return stops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >&
GradientArchive::stops() const {
  return stops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >*
GradientArchive::mutable_stops() {
  return &stops_;
}

// optional float opacity = 3;
inline bool GradientArchive::has_opacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GradientArchive::set_has_opacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GradientArchive::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GradientArchive::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline float GradientArchive::opacity() const {
  return opacity_;
}
inline void GradientArchive::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// optional bool advancedGradient = 4;
inline bool GradientArchive::has_advancedgradient() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GradientArchive::set_has_advancedgradient() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GradientArchive::clear_has_advancedgradient() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GradientArchive::clear_advancedgradient() {
  advancedgradient_ = false;
  clear_has_advancedgradient();
}
inline bool GradientArchive::advancedgradient() const {
  return advancedgradient_;
}
inline void GradientArchive::set_advancedgradient(bool value) {
  set_has_advancedgradient();
  advancedgradient_ = value;
}

// optional .TSD.AngleGradientArchive anglegradient = 5;
inline bool GradientArchive::has_anglegradient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GradientArchive::set_has_anglegradient() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GradientArchive::clear_has_anglegradient() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GradientArchive::clear_anglegradient() {
  if (anglegradient_ != NULL) anglegradient_->::TSD::AngleGradientArchive::Clear();
  clear_has_anglegradient();
}
inline const ::TSD::AngleGradientArchive& GradientArchive::anglegradient() const {
  return anglegradient_ != NULL ? *anglegradient_ : *default_instance_->anglegradient_;
}
inline ::TSD::AngleGradientArchive* GradientArchive::mutable_anglegradient() {
  set_has_anglegradient();
  if (anglegradient_ == NULL) anglegradient_ = new ::TSD::AngleGradientArchive;
  return anglegradient_;
}
inline ::TSD::AngleGradientArchive* GradientArchive::release_anglegradient() {
  clear_has_anglegradient();
  ::TSD::AngleGradientArchive* temp = anglegradient_;
  anglegradient_ = NULL;
  return temp;
}
inline void GradientArchive::set_allocated_anglegradient(::TSD::AngleGradientArchive* anglegradient) {
  delete anglegradient_;
  anglegradient_ = anglegradient;
  if (anglegradient) {
    set_has_anglegradient();
  } else {
    clear_has_anglegradient();
  }
}

// optional .TSD.TransformGradientArchive transformgradient = 6;
inline bool GradientArchive::has_transformgradient() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GradientArchive::set_has_transformgradient() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GradientArchive::clear_has_transformgradient() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GradientArchive::clear_transformgradient() {
  if (transformgradient_ != NULL) transformgradient_->::TSD::TransformGradientArchive::Clear();
  clear_has_transformgradient();
}
inline const ::TSD::TransformGradientArchive& GradientArchive::transformgradient() const {
  return transformgradient_ != NULL ? *transformgradient_ : *default_instance_->transformgradient_;
}
inline ::TSD::TransformGradientArchive* GradientArchive::mutable_transformgradient() {
  set_has_transformgradient();
  if (transformgradient_ == NULL) transformgradient_ = new ::TSD::TransformGradientArchive;
  return transformgradient_;
}
inline ::TSD::TransformGradientArchive* GradientArchive::release_transformgradient() {
  clear_has_transformgradient();
  ::TSD::TransformGradientArchive* temp = transformgradient_;
  transformgradient_ = NULL;
  return temp;
}
inline void GradientArchive::set_allocated_transformgradient(::TSD::TransformGradientArchive* transformgradient) {
  delete transformgradient_;
  transformgradient_ = transformgradient;
  if (transformgradient) {
    set_has_transformgradient();
  } else {
    clear_has_transformgradient();
  }
}

// -------------------------------------------------------------------

// ImageFillArchive

// optional .TSP.DataReference imagedata = 6;
inline bool ImageFillArchive::has_imagedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageFillArchive::set_has_imagedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageFillArchive::clear_has_imagedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageFillArchive::clear_imagedata() {
  if (imagedata_ != NULL) imagedata_->::TSP::DataReference::Clear();
  clear_has_imagedata();
}
inline const ::TSP::DataReference& ImageFillArchive::imagedata() const {
  return imagedata_ != NULL ? *imagedata_ : *default_instance_->imagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::mutable_imagedata() {
  set_has_imagedata();
  if (imagedata_ == NULL) imagedata_ = new ::TSP::DataReference;
  return imagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::release_imagedata() {
  clear_has_imagedata();
  ::TSP::DataReference* temp = imagedata_;
  imagedata_ = NULL;
  return temp;
}
inline void ImageFillArchive::set_allocated_imagedata(::TSP::DataReference* imagedata) {
  delete imagedata_;
  imagedata_ = imagedata;
  if (imagedata) {
    set_has_imagedata();
  } else {
    clear_has_imagedata();
  }
}

// optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
inline bool ImageFillArchive::has_technique() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageFillArchive::set_has_technique() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageFillArchive::clear_has_technique() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageFillArchive::clear_technique() {
  technique_ = 0;
  clear_has_technique();
}
inline ::TSD::ImageFillArchive_ImageFillTechnique ImageFillArchive::technique() const {
  return static_cast< ::TSD::ImageFillArchive_ImageFillTechnique >(technique_);
}
inline void ImageFillArchive::set_technique(::TSD::ImageFillArchive_ImageFillTechnique value) {
  assert(::TSD::ImageFillArchive_ImageFillTechnique_IsValid(value));
  set_has_technique();
  technique_ = value;
}

// optional .TSP.Color tint = 3;
inline bool ImageFillArchive::has_tint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageFillArchive::set_has_tint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageFillArchive::clear_has_tint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageFillArchive::clear_tint() {
  if (tint_ != NULL) tint_->::TSP::Color::Clear();
  clear_has_tint();
}
inline const ::TSP::Color& ImageFillArchive::tint() const {
  return tint_ != NULL ? *tint_ : *default_instance_->tint_;
}
inline ::TSP::Color* ImageFillArchive::mutable_tint() {
  set_has_tint();
  if (tint_ == NULL) tint_ = new ::TSP::Color;
  return tint_;
}
inline ::TSP::Color* ImageFillArchive::release_tint() {
  clear_has_tint();
  ::TSP::Color* temp = tint_;
  tint_ = NULL;
  return temp;
}
inline void ImageFillArchive::set_allocated_tint(::TSP::Color* tint) {
  delete tint_;
  tint_ = tint;
  if (tint) {
    set_has_tint();
  } else {
    clear_has_tint();
  }
}

// optional .TSP.Size fillsize = 4;
inline bool ImageFillArchive::has_fillsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageFillArchive::set_has_fillsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageFillArchive::clear_has_fillsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageFillArchive::clear_fillsize() {
  if (fillsize_ != NULL) fillsize_->::TSP::Size::Clear();
  clear_has_fillsize();
}
inline const ::TSP::Size& ImageFillArchive::fillsize() const {
  return fillsize_ != NULL ? *fillsize_ : *default_instance_->fillsize_;
}
inline ::TSP::Size* ImageFillArchive::mutable_fillsize() {
  set_has_fillsize();
  if (fillsize_ == NULL) fillsize_ = new ::TSP::Size;
  return fillsize_;
}
inline ::TSP::Size* ImageFillArchive::release_fillsize() {
  clear_has_fillsize();
  ::TSP::Size* temp = fillsize_;
  fillsize_ = NULL;
  return temp;
}
inline void ImageFillArchive::set_allocated_fillsize(::TSP::Size* fillsize) {
  delete fillsize_;
  fillsize_ = fillsize;
  if (fillsize) {
    set_has_fillsize();
  } else {
    clear_has_fillsize();
  }
}

// optional .TSP.DataReference originalimagedata = 7;
inline bool ImageFillArchive::has_originalimagedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageFillArchive::set_has_originalimagedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageFillArchive::clear_has_originalimagedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageFillArchive::clear_originalimagedata() {
  if (originalimagedata_ != NULL) originalimagedata_->::TSP::DataReference::Clear();
  clear_has_originalimagedata();
}
inline const ::TSP::DataReference& ImageFillArchive::originalimagedata() const {
  return originalimagedata_ != NULL ? *originalimagedata_ : *default_instance_->originalimagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::mutable_originalimagedata() {
  set_has_originalimagedata();
  if (originalimagedata_ == NULL) originalimagedata_ = new ::TSP::DataReference;
  return originalimagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::release_originalimagedata() {
  clear_has_originalimagedata();
  ::TSP::DataReference* temp = originalimagedata_;
  originalimagedata_ = NULL;
  return temp;
}
inline void ImageFillArchive::set_allocated_originalimagedata(::TSP::DataReference* originalimagedata) {
  delete originalimagedata_;
  originalimagedata_ = originalimagedata;
  if (originalimagedata) {
    set_has_originalimagedata();
  } else {
    clear_has_originalimagedata();
  }
}

// optional bool interpretsUntaggedImageDataAsGeneric = 8;
inline bool ImageFillArchive::has_interpretsuntaggedimagedataasgeneric() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageFillArchive::set_has_interpretsuntaggedimagedataasgeneric() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageFillArchive::clear_has_interpretsuntaggedimagedataasgeneric() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageFillArchive::clear_interpretsuntaggedimagedataasgeneric() {
  interpretsuntaggedimagedataasgeneric_ = false;
  clear_has_interpretsuntaggedimagedataasgeneric();
}
inline bool ImageFillArchive::interpretsuntaggedimagedataasgeneric() const {
  return interpretsuntaggedimagedataasgeneric_;
}
inline void ImageFillArchive::set_interpretsuntaggedimagedataasgeneric(bool value) {
  set_has_interpretsuntaggedimagedataasgeneric();
  interpretsuntaggedimagedataasgeneric_ = value;
}

// optional .TSP.Reference database_imagedata = 1;
inline bool ImageFillArchive::has_database_imagedata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageFillArchive::set_has_database_imagedata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageFillArchive::clear_has_database_imagedata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageFillArchive::clear_database_imagedata() {
  if (database_imagedata_ != NULL) database_imagedata_->::TSP::Reference::Clear();
  clear_has_database_imagedata();
}
inline const ::TSP::Reference& ImageFillArchive::database_imagedata() const {
  return database_imagedata_ != NULL ? *database_imagedata_ : *default_instance_->database_imagedata_;
}
inline ::TSP::Reference* ImageFillArchive::mutable_database_imagedata() {
  set_has_database_imagedata();
  if (database_imagedata_ == NULL) database_imagedata_ = new ::TSP::Reference;
  return database_imagedata_;
}
inline ::TSP::Reference* ImageFillArchive::release_database_imagedata() {
  clear_has_database_imagedata();
  ::TSP::Reference* temp = database_imagedata_;
  database_imagedata_ = NULL;
  return temp;
}
inline void ImageFillArchive::set_allocated_database_imagedata(::TSP::Reference* database_imagedata) {
  delete database_imagedata_;
  database_imagedata_ = database_imagedata;
  if (database_imagedata) {
    set_has_database_imagedata();
  } else {
    clear_has_database_imagedata();
  }
}

// optional .TSP.Reference database_originalimagedata = 5;
inline bool ImageFillArchive::has_database_originalimagedata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageFillArchive::set_has_database_originalimagedata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageFillArchive::clear_has_database_originalimagedata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageFillArchive::clear_database_originalimagedata() {
  if (database_originalimagedata_ != NULL) database_originalimagedata_->::TSP::Reference::Clear();
  clear_has_database_originalimagedata();
}
inline const ::TSP::Reference& ImageFillArchive::database_originalimagedata() const {
  return database_originalimagedata_ != NULL ? *database_originalimagedata_ : *default_instance_->database_originalimagedata_;
}
inline ::TSP::Reference* ImageFillArchive::mutable_database_originalimagedata() {
  set_has_database_originalimagedata();
  if (database_originalimagedata_ == NULL) database_originalimagedata_ = new ::TSP::Reference;
  return database_originalimagedata_;
}
inline ::TSP::Reference* ImageFillArchive::release_database_originalimagedata() {
  clear_has_database_originalimagedata();
  ::TSP::Reference* temp = database_originalimagedata_;
  database_originalimagedata_ = NULL;
  return temp;
}
inline void ImageFillArchive::set_allocated_database_originalimagedata(::TSP::Reference* database_originalimagedata) {
  delete database_originalimagedata_;
  database_originalimagedata_ = database_originalimagedata;
  if (database_originalimagedata) {
    set_has_database_originalimagedata();
  } else {
    clear_has_database_originalimagedata();
  }
}

// -------------------------------------------------------------------

// FillArchive

// optional .TSP.Color color = 1;
inline bool FillArchive::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillArchive::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillArchive::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillArchive::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& FillArchive::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* FillArchive::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* FillArchive::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void FillArchive::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional .TSD.GradientArchive gradient = 2;
inline bool FillArchive::has_gradient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FillArchive::set_has_gradient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FillArchive::clear_has_gradient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FillArchive::clear_gradient() {
  if (gradient_ != NULL) gradient_->::TSD::GradientArchive::Clear();
  clear_has_gradient();
}
inline const ::TSD::GradientArchive& FillArchive::gradient() const {
  return gradient_ != NULL ? *gradient_ : *default_instance_->gradient_;
}
inline ::TSD::GradientArchive* FillArchive::mutable_gradient() {
  set_has_gradient();
  if (gradient_ == NULL) gradient_ = new ::TSD::GradientArchive;
  return gradient_;
}
inline ::TSD::GradientArchive* FillArchive::release_gradient() {
  clear_has_gradient();
  ::TSD::GradientArchive* temp = gradient_;
  gradient_ = NULL;
  return temp;
}
inline void FillArchive::set_allocated_gradient(::TSD::GradientArchive* gradient) {
  delete gradient_;
  gradient_ = gradient;
  if (gradient) {
    set_has_gradient();
  } else {
    clear_has_gradient();
  }
}

// optional .TSD.ImageFillArchive image = 3;
inline bool FillArchive::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FillArchive::set_has_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FillArchive::clear_has_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FillArchive::clear_image() {
  if (image_ != NULL) image_->::TSD::ImageFillArchive::Clear();
  clear_has_image();
}
inline const ::TSD::ImageFillArchive& FillArchive::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::TSD::ImageFillArchive* FillArchive::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::TSD::ImageFillArchive;
  return image_;
}
inline ::TSD::ImageFillArchive* FillArchive::release_image() {
  clear_has_image();
  ::TSD::ImageFillArchive* temp = image_;
  image_ = NULL;
  return temp;
}
inline void FillArchive::set_allocated_image(::TSD::ImageFillArchive* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// -------------------------------------------------------------------

// StrokePatternArchive

// optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
inline bool StrokePatternArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrokePatternArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrokePatternArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrokePatternArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::StrokePatternArchive_StrokePatternType StrokePatternArchive::type() const {
  return static_cast< ::TSD::StrokePatternArchive_StrokePatternType >(type_);
}
inline void StrokePatternArchive::set_type(::TSD::StrokePatternArchive_StrokePatternType value) {
  assert(::TSD::StrokePatternArchive_StrokePatternType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float phase = 2;
inline bool StrokePatternArchive::has_phase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrokePatternArchive::set_has_phase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrokePatternArchive::clear_has_phase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrokePatternArchive::clear_phase() {
  phase_ = 0;
  clear_has_phase();
}
inline float StrokePatternArchive::phase() const {
  return phase_;
}
inline void StrokePatternArchive::set_phase(float value) {
  set_has_phase();
  phase_ = value;
}

// optional uint32 count = 3;
inline bool StrokePatternArchive::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrokePatternArchive::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrokePatternArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrokePatternArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 StrokePatternArchive::count() const {
  return count_;
}
inline void StrokePatternArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated float pattern = 4;
inline int StrokePatternArchive::pattern_size() const {
  return pattern_.size();
}
inline void StrokePatternArchive::clear_pattern() {
  pattern_.Clear();
}
inline float StrokePatternArchive::pattern(int index) const {
  return pattern_.Get(index);
}
inline void StrokePatternArchive::set_pattern(int index, float value) {
  pattern_.Set(index, value);
}
inline void StrokePatternArchive::add_pattern(float value) {
  pattern_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StrokePatternArchive::pattern() const {
  return pattern_;
}
inline ::google::protobuf::RepeatedField< float >*
StrokePatternArchive::mutable_pattern() {
  return &pattern_;
}

// -------------------------------------------------------------------

// StrokeArchive

// optional .TSP.Color color = 1;
inline bool StrokeArchive::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrokeArchive::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrokeArchive::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrokeArchive::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& StrokeArchive::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* StrokeArchive::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* StrokeArchive::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void StrokeArchive::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional float width = 2;
inline bool StrokeArchive::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrokeArchive::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrokeArchive::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrokeArchive::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float StrokeArchive::width() const {
  return width_;
}
inline void StrokeArchive::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional .TSD.StrokeArchive.LineCap cap = 3;
inline bool StrokeArchive::has_cap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrokeArchive::set_has_cap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrokeArchive::clear_has_cap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrokeArchive::clear_cap() {
  cap_ = 0;
  clear_has_cap();
}
inline ::TSD::StrokeArchive_LineCap StrokeArchive::cap() const {
  return static_cast< ::TSD::StrokeArchive_LineCap >(cap_);
}
inline void StrokeArchive::set_cap(::TSD::StrokeArchive_LineCap value) {
  assert(::TSD::StrokeArchive_LineCap_IsValid(value));
  set_has_cap();
  cap_ = value;
}

// optional .TSD.LineJoin join = 4;
inline bool StrokeArchive::has_join() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StrokeArchive::set_has_join() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StrokeArchive::clear_has_join() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StrokeArchive::clear_join() {
  join_ = 0;
  clear_has_join();
}
inline ::TSD::LineJoin StrokeArchive::join() const {
  return static_cast< ::TSD::LineJoin >(join_);
}
inline void StrokeArchive::set_join(::TSD::LineJoin value) {
  assert(::TSD::LineJoin_IsValid(value));
  set_has_join();
  join_ = value;
}

// optional float miterLimit = 5;
inline bool StrokeArchive::has_miterlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StrokeArchive::set_has_miterlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StrokeArchive::clear_has_miterlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StrokeArchive::clear_miterlimit() {
  miterlimit_ = 0;
  clear_has_miterlimit();
}
inline float StrokeArchive::miterlimit() const {
  return miterlimit_;
}
inline void StrokeArchive::set_miterlimit(float value) {
  set_has_miterlimit();
  miterlimit_ = value;
}

// optional .TSD.StrokePatternArchive pattern = 6;
inline bool StrokeArchive::has_pattern() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StrokeArchive::set_has_pattern() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StrokeArchive::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StrokeArchive::clear_pattern() {
  if (pattern_ != NULL) pattern_->::TSD::StrokePatternArchive::Clear();
  clear_has_pattern();
}
inline const ::TSD::StrokePatternArchive& StrokeArchive::pattern() const {
  return pattern_ != NULL ? *pattern_ : *default_instance_->pattern_;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == NULL) pattern_ = new ::TSD::StrokePatternArchive;
  return pattern_;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::release_pattern() {
  clear_has_pattern();
  ::TSD::StrokePatternArchive* temp = pattern_;
  pattern_ = NULL;
  return temp;
}
inline void StrokeArchive::set_allocated_pattern(::TSD::StrokePatternArchive* pattern) {
  delete pattern_;
  pattern_ = pattern;
  if (pattern) {
    set_has_pattern();
  } else {
    clear_has_pattern();
  }
}

// optional .TSD.SmartStrokeArchive smartStroke = 7;
inline bool StrokeArchive::has_smartstroke() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StrokeArchive::set_has_smartstroke() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StrokeArchive::clear_has_smartstroke() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StrokeArchive::clear_smartstroke() {
  if (smartstroke_ != NULL) smartstroke_->::TSD::SmartStrokeArchive::Clear();
  clear_has_smartstroke();
}
inline const ::TSD::SmartStrokeArchive& StrokeArchive::smartstroke() const {
  return smartstroke_ != NULL ? *smartstroke_ : *default_instance_->smartstroke_;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::mutable_smartstroke() {
  set_has_smartstroke();
  if (smartstroke_ == NULL) smartstroke_ = new ::TSD::SmartStrokeArchive;
  return smartstroke_;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::release_smartstroke() {
  clear_has_smartstroke();
  ::TSD::SmartStrokeArchive* temp = smartstroke_;
  smartstroke_ = NULL;
  return temp;
}
inline void StrokeArchive::set_allocated_smartstroke(::TSD::SmartStrokeArchive* smartstroke) {
  delete smartstroke_;
  smartstroke_ = smartstroke;
  if (smartstroke) {
    set_has_smartstroke();
  } else {
    clear_has_smartstroke();
  }
}

// optional .TSD.FrameArchive frame = 8;
inline bool StrokeArchive::has_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StrokeArchive::set_has_frame() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StrokeArchive::clear_has_frame() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StrokeArchive::clear_frame() {
  if (frame_ != NULL) frame_->::TSD::FrameArchive::Clear();
  clear_has_frame();
}
inline const ::TSD::FrameArchive& StrokeArchive::frame() const {
  return frame_ != NULL ? *frame_ : *default_instance_->frame_;
}
inline ::TSD::FrameArchive* StrokeArchive::mutable_frame() {
  set_has_frame();
  if (frame_ == NULL) frame_ = new ::TSD::FrameArchive;
  return frame_;
}
inline ::TSD::FrameArchive* StrokeArchive::release_frame() {
  clear_has_frame();
  ::TSD::FrameArchive* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline void StrokeArchive::set_allocated_frame(::TSD::FrameArchive* frame) {
  delete frame_;
  frame_ = frame;
  if (frame) {
    set_has_frame();
  } else {
    clear_has_frame();
  }
}

// optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
inline bool StrokeArchive::has_patterned_stroke() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StrokeArchive::set_has_patterned_stroke() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StrokeArchive::clear_has_patterned_stroke() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StrokeArchive::clear_patterned_stroke() {
  if (patterned_stroke_ != NULL) patterned_stroke_->::TSD::PatternedStrokeArchive::Clear();
  clear_has_patterned_stroke();
}
inline const ::TSD::PatternedStrokeArchive& StrokeArchive::patterned_stroke() const {
  return patterned_stroke_ != NULL ? *patterned_stroke_ : *default_instance_->patterned_stroke_;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::mutable_patterned_stroke() {
  set_has_patterned_stroke();
  if (patterned_stroke_ == NULL) patterned_stroke_ = new ::TSD::PatternedStrokeArchive;
  return patterned_stroke_;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::release_patterned_stroke() {
  clear_has_patterned_stroke();
  ::TSD::PatternedStrokeArchive* temp = patterned_stroke_;
  patterned_stroke_ = NULL;
  return temp;
}
inline void StrokeArchive::set_allocated_patterned_stroke(::TSD::PatternedStrokeArchive* patterned_stroke) {
  delete patterned_stroke_;
  patterned_stroke_ = patterned_stroke;
  if (patterned_stroke) {
    set_has_patterned_stroke();
  } else {
    clear_has_patterned_stroke();
  }
}

// -------------------------------------------------------------------

// SmartStrokeArchive

// optional string strokeName = 2;
inline bool SmartStrokeArchive::has_strokename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmartStrokeArchive::set_has_strokename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmartStrokeArchive::clear_has_strokename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmartStrokeArchive::clear_strokename() {
  if (strokename_ != &::google::protobuf::internal::kEmptyString) {
    strokename_->clear();
  }
  clear_has_strokename();
}
inline const ::std::string& SmartStrokeArchive::strokename() const {
  return *strokename_;
}
inline void SmartStrokeArchive::set_strokename(const ::std::string& value) {
  set_has_strokename();
  if (strokename_ == &::google::protobuf::internal::kEmptyString) {
    strokename_ = new ::std::string;
  }
  strokename_->assign(value);
}
inline void SmartStrokeArchive::set_strokename(const char* value) {
  set_has_strokename();
  if (strokename_ == &::google::protobuf::internal::kEmptyString) {
    strokename_ = new ::std::string;
  }
  strokename_->assign(value);
}
inline void SmartStrokeArchive::set_strokename(const char* value, size_t size) {
  set_has_strokename();
  if (strokename_ == &::google::protobuf::internal::kEmptyString) {
    strokename_ = new ::std::string;
  }
  strokename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmartStrokeArchive::mutable_strokename() {
  set_has_strokename();
  if (strokename_ == &::google::protobuf::internal::kEmptyString) {
    strokename_ = new ::std::string;
  }
  return strokename_;
}
inline ::std::string* SmartStrokeArchive::release_strokename() {
  clear_has_strokename();
  if (strokename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strokename_;
    strokename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SmartStrokeArchive::set_allocated_strokename(::std::string* strokename) {
  if (strokename_ != &::google::protobuf::internal::kEmptyString) {
    delete strokename_;
  }
  if (strokename) {
    set_has_strokename();
    strokename_ = strokename;
  } else {
    clear_has_strokename();
    strokename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 randomSeed = 3;
inline bool SmartStrokeArchive::has_randomseed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmartStrokeArchive::set_has_randomseed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmartStrokeArchive::clear_has_randomseed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmartStrokeArchive::clear_randomseed() {
  randomseed_ = 0;
  clear_has_randomseed();
}
inline ::google::protobuf::int32 SmartStrokeArchive::randomseed() const {
  return randomseed_;
}
inline void SmartStrokeArchive::set_randomseed(::google::protobuf::int32 value) {
  set_has_randomseed();
  randomseed_ = value;
}

// optional .TSP.ReferenceDictionary parameterValues = 4;
inline bool SmartStrokeArchive::has_parametervalues() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmartStrokeArchive::set_has_parametervalues() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmartStrokeArchive::clear_has_parametervalues() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmartStrokeArchive::clear_parametervalues() {
  if (parametervalues_ != NULL) parametervalues_->::TSP::ReferenceDictionary::Clear();
  clear_has_parametervalues();
}
inline const ::TSP::ReferenceDictionary& SmartStrokeArchive::parametervalues() const {
  return parametervalues_ != NULL ? *parametervalues_ : *default_instance_->parametervalues_;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::mutable_parametervalues() {
  set_has_parametervalues();
  if (parametervalues_ == NULL) parametervalues_ = new ::TSP::ReferenceDictionary;
  return parametervalues_;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::release_parametervalues() {
  clear_has_parametervalues();
  ::TSP::ReferenceDictionary* temp = parametervalues_;
  parametervalues_ = NULL;
  return temp;
}
inline void SmartStrokeArchive::set_allocated_parametervalues(::TSP::ReferenceDictionary* parametervalues) {
  delete parametervalues_;
  parametervalues_ = parametervalues;
  if (parametervalues) {
    set_has_parametervalues();
  } else {
    clear_has_parametervalues();
  }
}

// -------------------------------------------------------------------

// FrameArchive

// optional string frameName = 2;
inline bool FrameArchive::has_framename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameArchive::set_has_framename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameArchive::clear_has_framename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameArchive::clear_framename() {
  if (framename_ != &::google::protobuf::internal::kEmptyString) {
    framename_->clear();
  }
  clear_has_framename();
}
inline const ::std::string& FrameArchive::framename() const {
  return *framename_;
}
inline void FrameArchive::set_framename(const ::std::string& value) {
  set_has_framename();
  if (framename_ == &::google::protobuf::internal::kEmptyString) {
    framename_ = new ::std::string;
  }
  framename_->assign(value);
}
inline void FrameArchive::set_framename(const char* value) {
  set_has_framename();
  if (framename_ == &::google::protobuf::internal::kEmptyString) {
    framename_ = new ::std::string;
  }
  framename_->assign(value);
}
inline void FrameArchive::set_framename(const char* value, size_t size) {
  set_has_framename();
  if (framename_ == &::google::protobuf::internal::kEmptyString) {
    framename_ = new ::std::string;
  }
  framename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameArchive::mutable_framename() {
  set_has_framename();
  if (framename_ == &::google::protobuf::internal::kEmptyString) {
    framename_ = new ::std::string;
  }
  return framename_;
}
inline ::std::string* FrameArchive::release_framename() {
  clear_has_framename();
  if (framename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = framename_;
    framename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameArchive::set_allocated_framename(::std::string* framename) {
  if (framename_ != &::google::protobuf::internal::kEmptyString) {
    delete framename_;
  }
  if (framename) {
    set_has_framename();
    framename_ = framename;
  } else {
    clear_has_framename();
    framename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float assetScale = 3;
inline bool FrameArchive::has_assetscale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameArchive::set_has_assetscale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameArchive::clear_has_assetscale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameArchive::clear_assetscale() {
  assetscale_ = 0;
  clear_has_assetscale();
}
inline float FrameArchive::assetscale() const {
  return assetscale_;
}
inline void FrameArchive::set_assetscale(float value) {
  set_has_assetscale();
  assetscale_ = value;
}

// -------------------------------------------------------------------

// PatternedStrokeArchive

// optional string pattern_name = 2;
inline bool PatternedStrokeArchive::has_pattern_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatternedStrokeArchive::set_has_pattern_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatternedStrokeArchive::clear_has_pattern_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatternedStrokeArchive::clear_pattern_name() {
  if (pattern_name_ != &::google::protobuf::internal::kEmptyString) {
    pattern_name_->clear();
  }
  clear_has_pattern_name();
}
inline const ::std::string& PatternedStrokeArchive::pattern_name() const {
  return *pattern_name_;
}
inline void PatternedStrokeArchive::set_pattern_name(const ::std::string& value) {
  set_has_pattern_name();
  if (pattern_name_ == &::google::protobuf::internal::kEmptyString) {
    pattern_name_ = new ::std::string;
  }
  pattern_name_->assign(value);
}
inline void PatternedStrokeArchive::set_pattern_name(const char* value) {
  set_has_pattern_name();
  if (pattern_name_ == &::google::protobuf::internal::kEmptyString) {
    pattern_name_ = new ::std::string;
  }
  pattern_name_->assign(value);
}
inline void PatternedStrokeArchive::set_pattern_name(const char* value, size_t size) {
  set_has_pattern_name();
  if (pattern_name_ == &::google::protobuf::internal::kEmptyString) {
    pattern_name_ = new ::std::string;
  }
  pattern_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PatternedStrokeArchive::mutable_pattern_name() {
  set_has_pattern_name();
  if (pattern_name_ == &::google::protobuf::internal::kEmptyString) {
    pattern_name_ = new ::std::string;
  }
  return pattern_name_;
}
inline ::std::string* PatternedStrokeArchive::release_pattern_name() {
  clear_has_pattern_name();
  if (pattern_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pattern_name_;
    pattern_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PatternedStrokeArchive::set_allocated_pattern_name(::std::string* pattern_name) {
  if (pattern_name_ != &::google::protobuf::internal::kEmptyString) {
    delete pattern_name_;
  }
  if (pattern_name) {
    set_has_pattern_name();
    pattern_name_ = pattern_name;
  } else {
    clear_has_pattern_name();
    pattern_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LineEndArchive

// optional .TSP.Path path = 1;
inline bool LineEndArchive::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineEndArchive::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineEndArchive::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineEndArchive::clear_path() {
  if (path_ != NULL) path_->::TSP::Path::Clear();
  clear_has_path();
}
inline const ::TSP::Path& LineEndArchive::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::TSP::Path* LineEndArchive::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::TSP::Path;
  return path_;
}
inline ::TSP::Path* LineEndArchive::release_path() {
  clear_has_path();
  ::TSP::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void LineEndArchive::set_allocated_path(::TSP::Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
}

// optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
inline bool LineEndArchive::has_line_join() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineEndArchive::set_has_line_join() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineEndArchive::clear_has_line_join() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineEndArchive::clear_line_join() {
  line_join_ = 0;
  clear_has_line_join();
}
inline ::TSD::LineJoin LineEndArchive::line_join() const {
  return static_cast< ::TSD::LineJoin >(line_join_);
}
inline void LineEndArchive::set_line_join(::TSD::LineJoin value) {
  assert(::TSD::LineJoin_IsValid(value));
  set_has_line_join();
  line_join_ = value;
}

// optional .TSP.Point end_point = 3;
inline bool LineEndArchive::has_end_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineEndArchive::set_has_end_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineEndArchive::clear_has_end_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineEndArchive::clear_end_point() {
  if (end_point_ != NULL) end_point_->::TSP::Point::Clear();
  clear_has_end_point();
}
inline const ::TSP::Point& LineEndArchive::end_point() const {
  return end_point_ != NULL ? *end_point_ : *default_instance_->end_point_;
}
inline ::TSP::Point* LineEndArchive::mutable_end_point() {
  set_has_end_point();
  if (end_point_ == NULL) end_point_ = new ::TSP::Point;
  return end_point_;
}
inline ::TSP::Point* LineEndArchive::release_end_point() {
  clear_has_end_point();
  ::TSP::Point* temp = end_point_;
  end_point_ = NULL;
  return temp;
}
inline void LineEndArchive::set_allocated_end_point(::TSP::Point* end_point) {
  delete end_point_;
  end_point_ = end_point;
  if (end_point) {
    set_has_end_point();
  } else {
    clear_has_end_point();
  }
}

// optional bool is_filled = 4;
inline bool LineEndArchive::has_is_filled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineEndArchive::set_has_is_filled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineEndArchive::clear_has_is_filled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineEndArchive::clear_is_filled() {
  is_filled_ = false;
  clear_has_is_filled();
}
inline bool LineEndArchive::is_filled() const {
  return is_filled_;
}
inline void LineEndArchive::set_is_filled(bool value) {
  set_has_is_filled();
  is_filled_ = value;
}

// optional string identifier = 5;
inline bool LineEndArchive::has_identifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LineEndArchive::set_has_identifier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LineEndArchive::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LineEndArchive::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& LineEndArchive::identifier() const {
  return *identifier_;
}
inline void LineEndArchive::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void LineEndArchive::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void LineEndArchive::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineEndArchive::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* LineEndArchive::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LineEndArchive::set_allocated_identifier(::std::string* identifier) {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_;
  }
  if (identifier) {
    set_has_identifier();
    identifier_ = identifier;
  } else {
    clear_has_identifier();
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ShadowArchive

// optional .TSP.Color color = 1;
inline bool ShadowArchive::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShadowArchive::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShadowArchive::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShadowArchive::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& ShadowArchive::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* ShadowArchive::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* ShadowArchive::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void ShadowArchive::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional float angle = 2 [default = 315];
inline bool ShadowArchive::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShadowArchive::set_has_angle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShadowArchive::clear_has_angle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShadowArchive::clear_angle() {
  angle_ = 315;
  clear_has_angle();
}
inline float ShadowArchive::angle() const {
  return angle_;
}
inline void ShadowArchive::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional float offset = 3 [default = 5];
inline bool ShadowArchive::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShadowArchive::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShadowArchive::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShadowArchive::clear_offset() {
  offset_ = 5;
  clear_has_offset();
}
inline float ShadowArchive::offset() const {
  return offset_;
}
inline void ShadowArchive::set_offset(float value) {
  set_has_offset();
  offset_ = value;
}

// optional int32 radius = 4 [default = 1];
inline bool ShadowArchive::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShadowArchive::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShadowArchive::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShadowArchive::clear_radius() {
  radius_ = 1;
  clear_has_radius();
}
inline ::google::protobuf::int32 ShadowArchive::radius() const {
  return radius_;
}
inline void ShadowArchive::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
}

// optional float opacity = 5 [default = 1];
inline bool ShadowArchive::has_opacity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShadowArchive::set_has_opacity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShadowArchive::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShadowArchive::clear_opacity() {
  opacity_ = 1;
  clear_has_opacity();
}
inline float ShadowArchive::opacity() const {
  return opacity_;
}
inline void ShadowArchive::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// optional bool is_enabled = 6 [default = true];
inline bool ShadowArchive::has_is_enabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShadowArchive::set_has_is_enabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShadowArchive::clear_has_is_enabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShadowArchive::clear_is_enabled() {
  is_enabled_ = true;
  clear_has_is_enabled();
}
inline bool ShadowArchive::is_enabled() const {
  return is_enabled_;
}
inline void ShadowArchive::set_is_enabled(bool value) {
  set_has_is_enabled();
  is_enabled_ = value;
}

// optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
inline bool ShadowArchive::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShadowArchive::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShadowArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShadowArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::ShadowArchive_ShadowType ShadowArchive::type() const {
  return static_cast< ::TSD::ShadowArchive_ShadowType >(type_);
}
inline void ShadowArchive::set_type(::TSD::ShadowArchive_ShadowType value) {
  assert(::TSD::ShadowArchive_ShadowType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TSD.DropShadowArchive dropShadow = 8;
inline bool ShadowArchive::has_dropshadow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShadowArchive::set_has_dropshadow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShadowArchive::clear_has_dropshadow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShadowArchive::clear_dropshadow() {
  if (dropshadow_ != NULL) dropshadow_->::TSD::DropShadowArchive::Clear();
  clear_has_dropshadow();
}
inline const ::TSD::DropShadowArchive& ShadowArchive::dropshadow() const {
  return dropshadow_ != NULL ? *dropshadow_ : *default_instance_->dropshadow_;
}
inline ::TSD::DropShadowArchive* ShadowArchive::mutable_dropshadow() {
  set_has_dropshadow();
  if (dropshadow_ == NULL) dropshadow_ = new ::TSD::DropShadowArchive;
  return dropshadow_;
}
inline ::TSD::DropShadowArchive* ShadowArchive::release_dropshadow() {
  clear_has_dropshadow();
  ::TSD::DropShadowArchive* temp = dropshadow_;
  dropshadow_ = NULL;
  return temp;
}
inline void ShadowArchive::set_allocated_dropshadow(::TSD::DropShadowArchive* dropshadow) {
  delete dropshadow_;
  dropshadow_ = dropshadow;
  if (dropshadow) {
    set_has_dropshadow();
  } else {
    clear_has_dropshadow();
  }
}

// optional .TSD.ContactShadowArchive contactShadow = 9;
inline bool ShadowArchive::has_contactshadow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ShadowArchive::set_has_contactshadow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ShadowArchive::clear_has_contactshadow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ShadowArchive::clear_contactshadow() {
  if (contactshadow_ != NULL) contactshadow_->::TSD::ContactShadowArchive::Clear();
  clear_has_contactshadow();
}
inline const ::TSD::ContactShadowArchive& ShadowArchive::contactshadow() const {
  return contactshadow_ != NULL ? *contactshadow_ : *default_instance_->contactshadow_;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::mutable_contactshadow() {
  set_has_contactshadow();
  if (contactshadow_ == NULL) contactshadow_ = new ::TSD::ContactShadowArchive;
  return contactshadow_;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::release_contactshadow() {
  clear_has_contactshadow();
  ::TSD::ContactShadowArchive* temp = contactshadow_;
  contactshadow_ = NULL;
  return temp;
}
inline void ShadowArchive::set_allocated_contactshadow(::TSD::ContactShadowArchive* contactshadow) {
  delete contactshadow_;
  contactshadow_ = contactshadow;
  if (contactshadow) {
    set_has_contactshadow();
  } else {
    clear_has_contactshadow();
  }
}

// optional .TSD.CurvedShadowArchive curvedShadow = 10;
inline bool ShadowArchive::has_curvedshadow() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ShadowArchive::set_has_curvedshadow() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ShadowArchive::clear_has_curvedshadow() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ShadowArchive::clear_curvedshadow() {
  if (curvedshadow_ != NULL) curvedshadow_->::TSD::CurvedShadowArchive::Clear();
  clear_has_curvedshadow();
}
inline const ::TSD::CurvedShadowArchive& ShadowArchive::curvedshadow() const {
  return curvedshadow_ != NULL ? *curvedshadow_ : *default_instance_->curvedshadow_;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::mutable_curvedshadow() {
  set_has_curvedshadow();
  if (curvedshadow_ == NULL) curvedshadow_ = new ::TSD::CurvedShadowArchive;
  return curvedshadow_;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::release_curvedshadow() {
  clear_has_curvedshadow();
  ::TSD::CurvedShadowArchive* temp = curvedshadow_;
  curvedshadow_ = NULL;
  return temp;
}
inline void ShadowArchive::set_allocated_curvedshadow(::TSD::CurvedShadowArchive* curvedshadow) {
  delete curvedshadow_;
  curvedshadow_ = curvedshadow;
  if (curvedshadow) {
    set_has_curvedshadow();
  } else {
    clear_has_curvedshadow();
  }
}

// -------------------------------------------------------------------

// DropShadowArchive

// -------------------------------------------------------------------

// ContactShadowArchive

// optional float height = 2 [default = 0.2];
inline bool ContactShadowArchive::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactShadowArchive::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactShadowArchive::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactShadowArchive::clear_height() {
  height_ = 0.2f;
  clear_has_height();
}
inline float ContactShadowArchive::height() const {
  return height_;
}
inline void ContactShadowArchive::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional float offset = 4 [default = 0];
inline bool ContactShadowArchive::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactShadowArchive::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactShadowArchive::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactShadowArchive::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float ContactShadowArchive::offset() const {
  return offset_;
}
inline void ContactShadowArchive::set_offset(float value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// CurvedShadowArchive

// optional float curve = 1 [default = 0.6];
inline bool CurvedShadowArchive::has_curve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurvedShadowArchive::set_has_curve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurvedShadowArchive::clear_has_curve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurvedShadowArchive::clear_curve() {
  curve_ = 0.6f;
  clear_has_curve();
}
inline float CurvedShadowArchive::curve() const {
  return curve_;
}
inline void CurvedShadowArchive::set_curve(float value) {
  set_has_curve();
  curve_ = value;
}

// -------------------------------------------------------------------

// ReflectionArchive

// optional float opacity = 1 [default = 0.5];
inline bool ReflectionArchive::has_opacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReflectionArchive::set_has_opacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReflectionArchive::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReflectionArchive::clear_opacity() {
  opacity_ = 0.5f;
  clear_has_opacity();
}
inline float ReflectionArchive::opacity() const {
  return opacity_;
}
inline void ReflectionArchive::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// -------------------------------------------------------------------

// ImageAdjustmentsArchive

// optional float exposure = 1;
inline bool ImageAdjustmentsArchive::has_exposure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_exposure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageAdjustmentsArchive::clear_has_exposure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageAdjustmentsArchive::clear_exposure() {
  exposure_ = 0;
  clear_has_exposure();
}
inline float ImageAdjustmentsArchive::exposure() const {
  return exposure_;
}
inline void ImageAdjustmentsArchive::set_exposure(float value) {
  set_has_exposure();
  exposure_ = value;
}

// optional float saturation = 2;
inline bool ImageAdjustmentsArchive::has_saturation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_saturation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageAdjustmentsArchive::clear_has_saturation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageAdjustmentsArchive::clear_saturation() {
  saturation_ = 0;
  clear_has_saturation();
}
inline float ImageAdjustmentsArchive::saturation() const {
  return saturation_;
}
inline void ImageAdjustmentsArchive::set_saturation(float value) {
  set_has_saturation();
  saturation_ = value;
}

// optional float contrast = 3;
inline bool ImageAdjustmentsArchive::has_contrast() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_contrast() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageAdjustmentsArchive::clear_has_contrast() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageAdjustmentsArchive::clear_contrast() {
  contrast_ = 0;
  clear_has_contrast();
}
inline float ImageAdjustmentsArchive::contrast() const {
  return contrast_;
}
inline void ImageAdjustmentsArchive::set_contrast(float value) {
  set_has_contrast();
  contrast_ = value;
}

// optional float highlights = 4;
inline bool ImageAdjustmentsArchive::has_highlights() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_highlights() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageAdjustmentsArchive::clear_has_highlights() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageAdjustmentsArchive::clear_highlights() {
  highlights_ = 0;
  clear_has_highlights();
}
inline float ImageAdjustmentsArchive::highlights() const {
  return highlights_;
}
inline void ImageAdjustmentsArchive::set_highlights(float value) {
  set_has_highlights();
  highlights_ = value;
}

// optional float shadows = 5;
inline bool ImageAdjustmentsArchive::has_shadows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_shadows() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageAdjustmentsArchive::clear_has_shadows() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageAdjustmentsArchive::clear_shadows() {
  shadows_ = 0;
  clear_has_shadows();
}
inline float ImageAdjustmentsArchive::shadows() const {
  return shadows_;
}
inline void ImageAdjustmentsArchive::set_shadows(float value) {
  set_has_shadows();
  shadows_ = value;
}

// optional float sharpness = 6;
inline bool ImageAdjustmentsArchive::has_sharpness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_sharpness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageAdjustmentsArchive::clear_has_sharpness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageAdjustmentsArchive::clear_sharpness() {
  sharpness_ = 0;
  clear_has_sharpness();
}
inline float ImageAdjustmentsArchive::sharpness() const {
  return sharpness_;
}
inline void ImageAdjustmentsArchive::set_sharpness(float value) {
  set_has_sharpness();
  sharpness_ = value;
}

// optional float denoise = 7;
inline bool ImageAdjustmentsArchive::has_denoise() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_denoise() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageAdjustmentsArchive::clear_has_denoise() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageAdjustmentsArchive::clear_denoise() {
  denoise_ = 0;
  clear_has_denoise();
}
inline float ImageAdjustmentsArchive::denoise() const {
  return denoise_;
}
inline void ImageAdjustmentsArchive::set_denoise(float value) {
  set_has_denoise();
  denoise_ = value;
}

// optional float temperature = 8;
inline bool ImageAdjustmentsArchive::has_temperature() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_temperature() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageAdjustmentsArchive::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageAdjustmentsArchive::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float ImageAdjustmentsArchive::temperature() const {
  return temperature_;
}
inline void ImageAdjustmentsArchive::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// optional float tint = 9;
inline bool ImageAdjustmentsArchive::has_tint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_tint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageAdjustmentsArchive::clear_has_tint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageAdjustmentsArchive::clear_tint() {
  tint_ = 0;
  clear_has_tint();
}
inline float ImageAdjustmentsArchive::tint() const {
  return tint_;
}
inline void ImageAdjustmentsArchive::set_tint(float value) {
  set_has_tint();
  tint_ = value;
}

// optional float bottom_level = 10;
inline bool ImageAdjustmentsArchive::has_bottom_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_bottom_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageAdjustmentsArchive::clear_has_bottom_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageAdjustmentsArchive::clear_bottom_level() {
  bottom_level_ = 0;
  clear_has_bottom_level();
}
inline float ImageAdjustmentsArchive::bottom_level() const {
  return bottom_level_;
}
inline void ImageAdjustmentsArchive::set_bottom_level(float value) {
  set_has_bottom_level();
  bottom_level_ = value;
}

// optional float top_level = 11 [default = 1];
inline bool ImageAdjustmentsArchive::has_top_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_top_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageAdjustmentsArchive::clear_has_top_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageAdjustmentsArchive::clear_top_level() {
  top_level_ = 1;
  clear_has_top_level();
}
inline float ImageAdjustmentsArchive::top_level() const {
  return top_level_;
}
inline void ImageAdjustmentsArchive::set_top_level(float value) {
  set_has_top_level();
  top_level_ = value;
}

// optional float gamma = 12;
inline bool ImageAdjustmentsArchive::has_gamma() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_gamma() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageAdjustmentsArchive::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageAdjustmentsArchive::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline float ImageAdjustmentsArchive::gamma() const {
  return gamma_;
}
inline void ImageAdjustmentsArchive::set_gamma(float value) {
  set_has_gamma();
  gamma_ = value;
}

// optional bool enhance = 13 [default = false];
inline bool ImageAdjustmentsArchive::has_enhance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_enhance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImageAdjustmentsArchive::clear_has_enhance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImageAdjustmentsArchive::clear_enhance() {
  enhance_ = false;
  clear_has_enhance();
}
inline bool ImageAdjustmentsArchive::enhance() const {
  return enhance_;
}
inline void ImageAdjustmentsArchive::set_enhance(bool value) {
  set_has_enhance();
  enhance_ = value;
}

// optional bool represents_sage_adjustments = 14 [default = false];
inline bool ImageAdjustmentsArchive::has_represents_sage_adjustments() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ImageAdjustmentsArchive::set_has_represents_sage_adjustments() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ImageAdjustmentsArchive::clear_has_represents_sage_adjustments() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ImageAdjustmentsArchive::clear_represents_sage_adjustments() {
  represents_sage_adjustments_ = false;
  clear_has_represents_sage_adjustments();
}
inline bool ImageAdjustmentsArchive::represents_sage_adjustments() const {
  return represents_sage_adjustments_;
}
inline void ImageAdjustmentsArchive::set_represents_sage_adjustments(bool value) {
  set_has_represents_sage_adjustments();
  represents_sage_adjustments_ = value;
}

// -------------------------------------------------------------------

// ShapeStylePropertiesArchive

// optional .TSD.FillArchive fill = 1;
inline bool ShapeStylePropertiesArchive::has_fill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_fill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeStylePropertiesArchive::clear_has_fill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeStylePropertiesArchive::clear_fill() {
  if (fill_ != NULL) fill_->::TSD::FillArchive::Clear();
  clear_has_fill();
}
inline const ::TSD::FillArchive& ShapeStylePropertiesArchive::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSD::FillArchive;
  return fill_;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::release_fill() {
  clear_has_fill();
  ::TSD::FillArchive* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// optional .TSD.StrokeArchive stroke = 2;
inline bool ShapeStylePropertiesArchive::has_stroke() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_stroke() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeStylePropertiesArchive::clear_has_stroke() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeStylePropertiesArchive::clear_stroke() {
  if (stroke_ != NULL) stroke_->::TSD::StrokeArchive::Clear();
  clear_has_stroke();
}
inline const ::TSD::StrokeArchive& ShapeStylePropertiesArchive::stroke() const {
  return stroke_ != NULL ? *stroke_ : *default_instance_->stroke_;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::mutable_stroke() {
  set_has_stroke();
  if (stroke_ == NULL) stroke_ = new ::TSD::StrokeArchive;
  return stroke_;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::release_stroke() {
  clear_has_stroke();
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  delete stroke_;
  stroke_ = stroke;
  if (stroke) {
    set_has_stroke();
  } else {
    clear_has_stroke();
  }
}

// optional float opacity = 3;
inline bool ShapeStylePropertiesArchive::has_opacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_opacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeStylePropertiesArchive::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeStylePropertiesArchive::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline float ShapeStylePropertiesArchive::opacity() const {
  return opacity_;
}
inline void ShapeStylePropertiesArchive::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// optional .TSD.ShadowArchive shadow = 4;
inline bool ShapeStylePropertiesArchive::has_shadow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_shadow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapeStylePropertiesArchive::clear_has_shadow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapeStylePropertiesArchive::clear_shadow() {
  if (shadow_ != NULL) shadow_->::TSD::ShadowArchive::Clear();
  clear_has_shadow();
}
inline const ::TSD::ShadowArchive& ShapeStylePropertiesArchive::shadow() const {
  return shadow_ != NULL ? *shadow_ : *default_instance_->shadow_;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::mutable_shadow() {
  set_has_shadow();
  if (shadow_ == NULL) shadow_ = new ::TSD::ShadowArchive;
  return shadow_;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::release_shadow() {
  clear_has_shadow();
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  delete shadow_;
  shadow_ = shadow;
  if (shadow) {
    set_has_shadow();
  } else {
    clear_has_shadow();
  }
}

// optional .TSD.ReflectionArchive reflection = 5;
inline bool ShapeStylePropertiesArchive::has_reflection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShapeStylePropertiesArchive::set_has_reflection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShapeStylePropertiesArchive::clear_has_reflection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShapeStylePropertiesArchive::clear_reflection() {
  if (reflection_ != NULL) reflection_->::TSD::ReflectionArchive::Clear();
  clear_has_reflection();
}
inline const ::TSD::ReflectionArchive& ShapeStylePropertiesArchive::reflection() const {
  return reflection_ != NULL ? *reflection_ : *default_instance_->reflection_;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::mutable_reflection() {
  set_has_reflection();
  if (reflection_ == NULL) reflection_ = new ::TSD::ReflectionArchive;
  return reflection_;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::release_reflection() {
  clear_has_reflection();
  ::TSD::ReflectionArchive* temp = reflection_;
  reflection_ = NULL;
  return temp;
}
inline void ShapeStylePropertiesArchive::set_allocated_reflection(::TSD::ReflectionArchive* reflection) {
  delete reflection_;
  reflection_ = reflection;
  if (reflection) {
    set_has_reflection();
  } else {
    clear_has_reflection();
  }
}

// -------------------------------------------------------------------

// ShapeStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool ShapeStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ShapeStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool ShapeStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 ShapeStyleArchive::override_count() const {
  return override_count_;
}
inline void ShapeStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
inline bool ShapeStyleArchive::has_shape_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeStyleArchive::set_has_shape_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeStyleArchive::clear_has_shape_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeStyleArchive::clear_shape_properties() {
  if (shape_properties_ != NULL) shape_properties_->::TSD::ShapeStylePropertiesArchive::Clear();
  clear_has_shape_properties();
}
inline const ::TSD::ShapeStylePropertiesArchive& ShapeStyleArchive::shape_properties() const {
  return shape_properties_ != NULL ? *shape_properties_ : *default_instance_->shape_properties_;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::mutable_shape_properties() {
  set_has_shape_properties();
  if (shape_properties_ == NULL) shape_properties_ = new ::TSD::ShapeStylePropertiesArchive;
  return shape_properties_;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::release_shape_properties() {
  clear_has_shape_properties();
  ::TSD::ShapeStylePropertiesArchive* temp = shape_properties_;
  shape_properties_ = NULL;
  return temp;
}
inline void ShapeStyleArchive::set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties) {
  delete shape_properties_;
  shape_properties_ = shape_properties;
  if (shape_properties) {
    set_has_shape_properties();
  } else {
    clear_has_shape_properties();
  }
}

// -------------------------------------------------------------------

// MediaStylePropertiesArchive

// optional .TSD.StrokeArchive stroke = 1;
inline bool MediaStylePropertiesArchive::has_stroke() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaStylePropertiesArchive::set_has_stroke() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaStylePropertiesArchive::clear_has_stroke() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaStylePropertiesArchive::clear_stroke() {
  if (stroke_ != NULL) stroke_->::TSD::StrokeArchive::Clear();
  clear_has_stroke();
}
inline const ::TSD::StrokeArchive& MediaStylePropertiesArchive::stroke() const {
  return stroke_ != NULL ? *stroke_ : *default_instance_->stroke_;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::mutable_stroke() {
  set_has_stroke();
  if (stroke_ == NULL) stroke_ = new ::TSD::StrokeArchive;
  return stroke_;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::release_stroke() {
  clear_has_stroke();
  ::TSD::StrokeArchive* temp = stroke_;
  stroke_ = NULL;
  return temp;
}
inline void MediaStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  delete stroke_;
  stroke_ = stroke;
  if (stroke) {
    set_has_stroke();
  } else {
    clear_has_stroke();
  }
}

// optional float opacity = 2;
inline bool MediaStylePropertiesArchive::has_opacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaStylePropertiesArchive::set_has_opacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaStylePropertiesArchive::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaStylePropertiesArchive::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline float MediaStylePropertiesArchive::opacity() const {
  return opacity_;
}
inline void MediaStylePropertiesArchive::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// optional .TSD.ShadowArchive shadow = 3;
inline bool MediaStylePropertiesArchive::has_shadow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaStylePropertiesArchive::set_has_shadow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaStylePropertiesArchive::clear_has_shadow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaStylePropertiesArchive::clear_shadow() {
  if (shadow_ != NULL) shadow_->::TSD::ShadowArchive::Clear();
  clear_has_shadow();
}
inline const ::TSD::ShadowArchive& MediaStylePropertiesArchive::shadow() const {
  return shadow_ != NULL ? *shadow_ : *default_instance_->shadow_;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::mutable_shadow() {
  set_has_shadow();
  if (shadow_ == NULL) shadow_ = new ::TSD::ShadowArchive;
  return shadow_;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::release_shadow() {
  clear_has_shadow();
  ::TSD::ShadowArchive* temp = shadow_;
  shadow_ = NULL;
  return temp;
}
inline void MediaStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  delete shadow_;
  shadow_ = shadow;
  if (shadow) {
    set_has_shadow();
  } else {
    clear_has_shadow();
  }
}

// optional .TSD.ReflectionArchive reflection = 4;
inline bool MediaStylePropertiesArchive::has_reflection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MediaStylePropertiesArchive::set_has_reflection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MediaStylePropertiesArchive::clear_has_reflection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MediaStylePropertiesArchive::clear_reflection() {
  if (reflection_ != NULL) reflection_->::TSD::ReflectionArchive::Clear();
  clear_has_reflection();
}
inline const ::TSD::ReflectionArchive& MediaStylePropertiesArchive::reflection() const {
  return reflection_ != NULL ? *reflection_ : *default_instance_->reflection_;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::mutable_reflection() {
  set_has_reflection();
  if (reflection_ == NULL) reflection_ = new ::TSD::ReflectionArchive;
  return reflection_;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::release_reflection() {
  clear_has_reflection();
  ::TSD::ReflectionArchive* temp = reflection_;
  reflection_ = NULL;
  return temp;
}
inline void MediaStylePropertiesArchive::set_allocated_reflection(::TSD::ReflectionArchive* reflection) {
  delete reflection_;
  reflection_ = reflection;
  if (reflection) {
    set_has_reflection();
  } else {
    clear_has_reflection();
  }
}

// -------------------------------------------------------------------

// MediaStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool MediaStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& MediaStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* MediaStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* MediaStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MediaStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 override_count = 10 [default = 0];
inline bool MediaStyleArchive::has_override_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaStyleArchive::set_has_override_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaStyleArchive::clear_has_override_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaStyleArchive::clear_override_count() {
  override_count_ = 0u;
  clear_has_override_count();
}
inline ::google::protobuf::uint32 MediaStyleArchive::override_count() const {
  return override_count_;
}
inline void MediaStyleArchive::set_override_count(::google::protobuf::uint32 value) {
  set_has_override_count();
  override_count_ = value;
}

// optional .TSD.MediaStylePropertiesArchive media_properties = 11;
inline bool MediaStyleArchive::has_media_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaStyleArchive::set_has_media_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaStyleArchive::clear_has_media_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaStyleArchive::clear_media_properties() {
  if (media_properties_ != NULL) media_properties_->::TSD::MediaStylePropertiesArchive::Clear();
  clear_has_media_properties();
}
inline const ::TSD::MediaStylePropertiesArchive& MediaStyleArchive::media_properties() const {
  return media_properties_ != NULL ? *media_properties_ : *default_instance_->media_properties_;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::mutable_media_properties() {
  set_has_media_properties();
  if (media_properties_ == NULL) media_properties_ = new ::TSD::MediaStylePropertiesArchive;
  return media_properties_;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::release_media_properties() {
  clear_has_media_properties();
  ::TSD::MediaStylePropertiesArchive* temp = media_properties_;
  media_properties_ = NULL;
  return temp;
}
inline void MediaStyleArchive::set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties) {
  delete media_properties_;
  media_properties_ = media_properties;
  if (media_properties) {
    set_has_media_properties();
  } else {
    clear_has_media_properties();
  }
}

// -------------------------------------------------------------------

// ThemePresetsArchive

// repeated .TSD.FillArchive gradient_fill_presets = 1;
inline int ThemePresetsArchive::gradient_fill_presets_size() const {
  return gradient_fill_presets_.size();
}
inline void ThemePresetsArchive::clear_gradient_fill_presets() {
  gradient_fill_presets_.Clear();
}
inline const ::TSD::FillArchive& ThemePresetsArchive::gradient_fill_presets(int index) const {
  return gradient_fill_presets_.Get(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::mutable_gradient_fill_presets(int index) {
  return gradient_fill_presets_.Mutable(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::add_gradient_fill_presets() {
  return gradient_fill_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >&
ThemePresetsArchive::gradient_fill_presets() const {
  return gradient_fill_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >*
ThemePresetsArchive::mutable_gradient_fill_presets() {
  return &gradient_fill_presets_;
}

// repeated .TSD.FillArchive image_fill_presets = 2;
inline int ThemePresetsArchive::image_fill_presets_size() const {
  return image_fill_presets_.size();
}
inline void ThemePresetsArchive::clear_image_fill_presets() {
  image_fill_presets_.Clear();
}
inline const ::TSD::FillArchive& ThemePresetsArchive::image_fill_presets(int index) const {
  return image_fill_presets_.Get(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::mutable_image_fill_presets(int index) {
  return image_fill_presets_.Mutable(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::add_image_fill_presets() {
  return image_fill_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >&
ThemePresetsArchive::image_fill_presets() const {
  return image_fill_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::FillArchive >*
ThemePresetsArchive::mutable_image_fill_presets() {
  return &image_fill_presets_;
}

// repeated .TSD.ShadowArchive shadow_presets = 3;
inline int ThemePresetsArchive::shadow_presets_size() const {
  return shadow_presets_.size();
}
inline void ThemePresetsArchive::clear_shadow_presets() {
  shadow_presets_.Clear();
}
inline const ::TSD::ShadowArchive& ThemePresetsArchive::shadow_presets(int index) const {
  return shadow_presets_.Get(index);
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::mutable_shadow_presets(int index) {
  return shadow_presets_.Mutable(index);
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::add_shadow_presets() {
  return shadow_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::ShadowArchive >&
ThemePresetsArchive::shadow_presets() const {
  return shadow_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::ShadowArchive >*
ThemePresetsArchive::mutable_shadow_presets() {
  return &shadow_presets_;
}

// repeated .TSP.Reference line_style_presets = 4;
inline int ThemePresetsArchive::line_style_presets_size() const {
  return line_style_presets_.size();
}
inline void ThemePresetsArchive::clear_line_style_presets() {
  line_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::line_style_presets(int index) const {
  return line_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_line_style_presets(int index) {
  return line_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_line_style_presets() {
  return line_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::line_style_presets() const {
  return line_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_line_style_presets() {
  return &line_style_presets_;
}

// repeated .TSP.Reference shape_style_presets = 5;
inline int ThemePresetsArchive::shape_style_presets_size() const {
  return shape_style_presets_.size();
}
inline void ThemePresetsArchive::clear_shape_style_presets() {
  shape_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::shape_style_presets(int index) const {
  return shape_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_shape_style_presets(int index) {
  return shape_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_shape_style_presets() {
  return shape_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::shape_style_presets() const {
  return shape_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_shape_style_presets() {
  return &shape_style_presets_;
}

// repeated .TSP.Reference textbox_style_presets = 6;
inline int ThemePresetsArchive::textbox_style_presets_size() const {
  return textbox_style_presets_.size();
}
inline void ThemePresetsArchive::clear_textbox_style_presets() {
  textbox_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::textbox_style_presets(int index) const {
  return textbox_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_textbox_style_presets(int index) {
  return textbox_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_textbox_style_presets() {
  return textbox_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::textbox_style_presets() const {
  return textbox_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_textbox_style_presets() {
  return &textbox_style_presets_;
}

// repeated .TSP.Reference image_style_presets = 7;
inline int ThemePresetsArchive::image_style_presets_size() const {
  return image_style_presets_.size();
}
inline void ThemePresetsArchive::clear_image_style_presets() {
  image_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::image_style_presets(int index) const {
  return image_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_image_style_presets(int index) {
  return image_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_image_style_presets() {
  return image_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::image_style_presets() const {
  return image_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_image_style_presets() {
  return &image_style_presets_;
}

// repeated .TSP.Reference movie_style_presets = 8;
inline int ThemePresetsArchive::movie_style_presets_size() const {
  return movie_style_presets_.size();
}
inline void ThemePresetsArchive::clear_movie_style_presets() {
  movie_style_presets_.Clear();
}
inline const ::TSP::Reference& ThemePresetsArchive::movie_style_presets(int index) const {
  return movie_style_presets_.Get(index);
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_movie_style_presets(int index) {
  return movie_style_presets_.Mutable(index);
}
inline ::TSP::Reference* ThemePresetsArchive::add_movie_style_presets() {
  return movie_style_presets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::movie_style_presets() const {
  return movie_style_presets_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_movie_style_presets() {
  return &movie_style_presets_;
}

// -------------------------------------------------------------------

// ThemeReplaceFillPresetCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ThemeReplaceFillPresetCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThemeReplaceFillPresetCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ThemeReplaceFillPresetCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference theme = 2;
inline bool ThemeReplaceFillPresetCommandArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThemeReplaceFillPresetCommandArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& ThemeReplaceFillPresetCommandArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// required .TSD.FillArchive fill = 3;
inline bool ThemeReplaceFillPresetCommandArchive::has_fill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThemeReplaceFillPresetCommandArchive::set_has_fill() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_has_fill() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_fill() {
  if (fill_ != NULL) fill_->::TSD::FillArchive::Clear();
  clear_has_fill();
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSD::FillArchive;
  return fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::release_fill() {
  clear_has_fill();
  ::TSD::FillArchive* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// required .TSD.FillArchive old_fill = 4;
inline bool ThemeReplaceFillPresetCommandArchive::has_old_fill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThemeReplaceFillPresetCommandArchive::set_has_old_fill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_has_old_fill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_old_fill() {
  if (old_fill_ != NULL) old_fill_->::TSD::FillArchive::Clear();
  clear_has_old_fill();
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::old_fill() const {
  return old_fill_ != NULL ? *old_fill_ : *default_instance_->old_fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::mutable_old_fill() {
  set_has_old_fill();
  if (old_fill_ == NULL) old_fill_ = new ::TSD::FillArchive;
  return old_fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::release_old_fill() {
  clear_has_old_fill();
  ::TSD::FillArchive* temp = old_fill_;
  old_fill_ = NULL;
  return temp;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_old_fill(::TSD::FillArchive* old_fill) {
  delete old_fill_;
  old_fill_ = old_fill;
  if (old_fill) {
    set_has_old_fill();
  } else {
    clear_has_old_fill();
  }
}

// required uint32 index = 5;
inline bool ThemeReplaceFillPresetCommandArchive::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThemeReplaceFillPresetCommandArchive::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThemeReplaceFillPresetCommandArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ThemeReplaceFillPresetCommandArchive::index() const {
  return index_;
}
inline void ThemeReplaceFillPresetCommandArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// DrawableArchive

// optional .TSD.GeometryArchive geometry = 1;
inline bool DrawableArchive::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawableArchive::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawableArchive::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawableArchive::clear_geometry() {
  if (geometry_ != NULL) geometry_->::TSD::GeometryArchive::Clear();
  clear_has_geometry();
}
inline const ::TSD::GeometryArchive& DrawableArchive::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::TSD::GeometryArchive* DrawableArchive::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::TSD::GeometryArchive;
  return geometry_;
}
inline ::TSD::GeometryArchive* DrawableArchive::release_geometry() {
  clear_has_geometry();
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void DrawableArchive::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .TSP.Reference parent = 2;
inline bool DrawableArchive::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DrawableArchive::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DrawableArchive::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DrawableArchive::clear_parent() {
  if (parent_ != NULL) parent_->::TSP::Reference::Clear();
  clear_has_parent();
}
inline const ::TSP::Reference& DrawableArchive::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::TSP::Reference* DrawableArchive::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::TSP::Reference;
  return parent_;
}
inline ::TSP::Reference* DrawableArchive::release_parent() {
  clear_has_parent();
  ::TSP::Reference* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void DrawableArchive::set_allocated_parent(::TSP::Reference* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
}

// optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
inline bool DrawableArchive::has_exterior_text_wrap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DrawableArchive::set_has_exterior_text_wrap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DrawableArchive::clear_has_exterior_text_wrap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DrawableArchive::clear_exterior_text_wrap() {
  if (exterior_text_wrap_ != NULL) exterior_text_wrap_->::TSD::ExteriorTextWrapArchive::Clear();
  clear_has_exterior_text_wrap();
}
inline const ::TSD::ExteriorTextWrapArchive& DrawableArchive::exterior_text_wrap() const {
  return exterior_text_wrap_ != NULL ? *exterior_text_wrap_ : *default_instance_->exterior_text_wrap_;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::mutable_exterior_text_wrap() {
  set_has_exterior_text_wrap();
  if (exterior_text_wrap_ == NULL) exterior_text_wrap_ = new ::TSD::ExteriorTextWrapArchive;
  return exterior_text_wrap_;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::release_exterior_text_wrap() {
  clear_has_exterior_text_wrap();
  ::TSD::ExteriorTextWrapArchive* temp = exterior_text_wrap_;
  exterior_text_wrap_ = NULL;
  return temp;
}
inline void DrawableArchive::set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap) {
  delete exterior_text_wrap_;
  exterior_text_wrap_ = exterior_text_wrap;
  if (exterior_text_wrap) {
    set_has_exterior_text_wrap();
  } else {
    clear_has_exterior_text_wrap();
  }
}

// optional string hyperlink_url = 4;
inline bool DrawableArchive::has_hyperlink_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DrawableArchive::set_has_hyperlink_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DrawableArchive::clear_has_hyperlink_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DrawableArchive::clear_hyperlink_url() {
  if (hyperlink_url_ != &::google::protobuf::internal::kEmptyString) {
    hyperlink_url_->clear();
  }
  clear_has_hyperlink_url();
}
inline const ::std::string& DrawableArchive::hyperlink_url() const {
  return *hyperlink_url_;
}
inline void DrawableArchive::set_hyperlink_url(const ::std::string& value) {
  set_has_hyperlink_url();
  if (hyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    hyperlink_url_ = new ::std::string;
  }
  hyperlink_url_->assign(value);
}
inline void DrawableArchive::set_hyperlink_url(const char* value) {
  set_has_hyperlink_url();
  if (hyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    hyperlink_url_ = new ::std::string;
  }
  hyperlink_url_->assign(value);
}
inline void DrawableArchive::set_hyperlink_url(const char* value, size_t size) {
  set_has_hyperlink_url();
  if (hyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    hyperlink_url_ = new ::std::string;
  }
  hyperlink_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawableArchive::mutable_hyperlink_url() {
  set_has_hyperlink_url();
  if (hyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    hyperlink_url_ = new ::std::string;
  }
  return hyperlink_url_;
}
inline ::std::string* DrawableArchive::release_hyperlink_url() {
  clear_has_hyperlink_url();
  if (hyperlink_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hyperlink_url_;
    hyperlink_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrawableArchive::set_allocated_hyperlink_url(::std::string* hyperlink_url) {
  if (hyperlink_url_ != &::google::protobuf::internal::kEmptyString) {
    delete hyperlink_url_;
  }
  if (hyperlink_url) {
    set_has_hyperlink_url();
    hyperlink_url_ = hyperlink_url;
  } else {
    clear_has_hyperlink_url();
    hyperlink_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool locked = 5;
inline bool DrawableArchive::has_locked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DrawableArchive::set_has_locked() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DrawableArchive::clear_has_locked() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DrawableArchive::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool DrawableArchive::locked() const {
  return locked_;
}
inline void DrawableArchive::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
}

// optional .TSP.Reference comment = 6;
inline bool DrawableArchive::has_comment() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DrawableArchive::set_has_comment() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DrawableArchive::clear_has_comment() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DrawableArchive::clear_comment() {
  if (comment_ != NULL) comment_->::TSP::Reference::Clear();
  clear_has_comment();
}
inline const ::TSP::Reference& DrawableArchive::comment() const {
  return comment_ != NULL ? *comment_ : *default_instance_->comment_;
}
inline ::TSP::Reference* DrawableArchive::mutable_comment() {
  set_has_comment();
  if (comment_ == NULL) comment_ = new ::TSP::Reference;
  return comment_;
}
inline ::TSP::Reference* DrawableArchive::release_comment() {
  clear_has_comment();
  ::TSP::Reference* temp = comment_;
  comment_ = NULL;
  return temp;
}
inline void DrawableArchive::set_allocated_comment(::TSP::Reference* comment) {
  delete comment_;
  comment_ = comment;
  if (comment) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
}

// optional bool aspect_ratio_locked = 7;
inline bool DrawableArchive::has_aspect_ratio_locked() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DrawableArchive::set_has_aspect_ratio_locked() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DrawableArchive::clear_has_aspect_ratio_locked() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DrawableArchive::clear_aspect_ratio_locked() {
  aspect_ratio_locked_ = false;
  clear_has_aspect_ratio_locked();
}
inline bool DrawableArchive::aspect_ratio_locked() const {
  return aspect_ratio_locked_;
}
inline void DrawableArchive::set_aspect_ratio_locked(bool value) {
  set_has_aspect_ratio_locked();
  aspect_ratio_locked_ = value;
}

// optional string accessibility_description = 8;
inline bool DrawableArchive::has_accessibility_description() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DrawableArchive::set_has_accessibility_description() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DrawableArchive::clear_has_accessibility_description() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DrawableArchive::clear_accessibility_description() {
  if (accessibility_description_ != &::google::protobuf::internal::kEmptyString) {
    accessibility_description_->clear();
  }
  clear_has_accessibility_description();
}
inline const ::std::string& DrawableArchive::accessibility_description() const {
  return *accessibility_description_;
}
inline void DrawableArchive::set_accessibility_description(const ::std::string& value) {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  accessibility_description_->assign(value);
}
inline void DrawableArchive::set_accessibility_description(const char* value) {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  accessibility_description_->assign(value);
}
inline void DrawableArchive::set_accessibility_description(const char* value, size_t size) {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  accessibility_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawableArchive::mutable_accessibility_description() {
  set_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    accessibility_description_ = new ::std::string;
  }
  return accessibility_description_;
}
inline ::std::string* DrawableArchive::release_accessibility_description() {
  clear_has_accessibility_description();
  if (accessibility_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessibility_description_;
    accessibility_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DrawableArchive::set_allocated_accessibility_description(::std::string* accessibility_description) {
  if (accessibility_description_ != &::google::protobuf::internal::kEmptyString) {
    delete accessibility_description_;
  }
  if (accessibility_description) {
    set_has_accessibility_description();
    accessibility_description_ = accessibility_description;
  } else {
    clear_has_accessibility_description();
    accessibility_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContainerArchive

// optional .TSD.GeometryArchive geometry = 1;
inline bool ContainerArchive::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerArchive::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerArchive::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerArchive::clear_geometry() {
  if (geometry_ != NULL) geometry_->::TSD::GeometryArchive::Clear();
  clear_has_geometry();
}
inline const ::TSD::GeometryArchive& ContainerArchive::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::TSD::GeometryArchive* ContainerArchive::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::TSD::GeometryArchive;
  return geometry_;
}
inline ::TSD::GeometryArchive* ContainerArchive::release_geometry() {
  clear_has_geometry();
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void ContainerArchive::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .TSP.Reference parent = 2;
inline bool ContainerArchive::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerArchive::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerArchive::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerArchive::clear_parent() {
  if (parent_ != NULL) parent_->::TSP::Reference::Clear();
  clear_has_parent();
}
inline const ::TSP::Reference& ContainerArchive::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::TSP::Reference* ContainerArchive::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::TSP::Reference;
  return parent_;
}
inline ::TSP::Reference* ContainerArchive::release_parent() {
  clear_has_parent();
  ::TSP::Reference* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void ContainerArchive::set_allocated_parent(::TSP::Reference* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
}

// repeated .TSP.Reference children = 3;
inline int ContainerArchive::children_size() const {
  return children_.size();
}
inline void ContainerArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& ContainerArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* ContainerArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* ContainerArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ContainerArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ContainerArchive::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// GroupArchive

// required .TSD.DrawableArchive super = 1;
inline bool GroupArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::DrawableArchive::Clear();
  clear_has_super();
}
inline const ::TSD::DrawableArchive& GroupArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::DrawableArchive* GroupArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::DrawableArchive;
  return super_;
}
inline ::TSD::DrawableArchive* GroupArchive::release_super() {
  clear_has_super();
  ::TSD::DrawableArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void GroupArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference children = 2;
inline int GroupArchive::children_size() const {
  return children_.size();
}
inline void GroupArchive::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& GroupArchive::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* GroupArchive::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* GroupArchive::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
GroupArchive::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
GroupArchive::mutable_children() {
  return &children_;
}

// -------------------------------------------------------------------

// ShapeArchive

// required .TSD.DrawableArchive super = 1;
inline bool ShapeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::DrawableArchive::Clear();
  clear_has_super();
}
inline const ::TSD::DrawableArchive& ShapeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::DrawableArchive* ShapeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::DrawableArchive;
  return super_;
}
inline ::TSD::DrawableArchive* ShapeArchive::release_super() {
  clear_has_super();
  ::TSD::DrawableArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference style = 2;
inline bool ShapeArchive::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeArchive::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& ShapeArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* ShapeArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* ShapeArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void ShapeArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// optional .TSD.PathSourceArchive pathsource = 3;
inline bool ShapeArchive::has_pathsource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapeArchive::set_has_pathsource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapeArchive::clear_has_pathsource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapeArchive::clear_pathsource() {
  if (pathsource_ != NULL) pathsource_->::TSD::PathSourceArchive::Clear();
  clear_has_pathsource();
}
inline const ::TSD::PathSourceArchive& ShapeArchive::pathsource() const {
  return pathsource_ != NULL ? *pathsource_ : *default_instance_->pathsource_;
}
inline ::TSD::PathSourceArchive* ShapeArchive::mutable_pathsource() {
  set_has_pathsource();
  if (pathsource_ == NULL) pathsource_ = new ::TSD::PathSourceArchive;
  return pathsource_;
}
inline ::TSD::PathSourceArchive* ShapeArchive::release_pathsource() {
  clear_has_pathsource();
  ::TSD::PathSourceArchive* temp = pathsource_;
  pathsource_ = NULL;
  return temp;
}
inline void ShapeArchive::set_allocated_pathsource(::TSD::PathSourceArchive* pathsource) {
  delete pathsource_;
  pathsource_ = pathsource;
  if (pathsource) {
    set_has_pathsource();
  } else {
    clear_has_pathsource();
  }
}

// optional .TSD.LineEndArchive head_line_end = 4;
inline bool ShapeArchive::has_head_line_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapeArchive::set_has_head_line_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapeArchive::clear_has_head_line_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapeArchive::clear_head_line_end() {
  if (head_line_end_ != NULL) head_line_end_->::TSD::LineEndArchive::Clear();
  clear_has_head_line_end();
}
inline const ::TSD::LineEndArchive& ShapeArchive::head_line_end() const {
  return head_line_end_ != NULL ? *head_line_end_ : *default_instance_->head_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::mutable_head_line_end() {
  set_has_head_line_end();
  if (head_line_end_ == NULL) head_line_end_ = new ::TSD::LineEndArchive;
  return head_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::release_head_line_end() {
  clear_has_head_line_end();
  ::TSD::LineEndArchive* temp = head_line_end_;
  head_line_end_ = NULL;
  return temp;
}
inline void ShapeArchive::set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end) {
  delete head_line_end_;
  head_line_end_ = head_line_end;
  if (head_line_end) {
    set_has_head_line_end();
  } else {
    clear_has_head_line_end();
  }
}

// optional .TSD.LineEndArchive tail_line_end = 5;
inline bool ShapeArchive::has_tail_line_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShapeArchive::set_has_tail_line_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShapeArchive::clear_has_tail_line_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShapeArchive::clear_tail_line_end() {
  if (tail_line_end_ != NULL) tail_line_end_->::TSD::LineEndArchive::Clear();
  clear_has_tail_line_end();
}
inline const ::TSD::LineEndArchive& ShapeArchive::tail_line_end() const {
  return tail_line_end_ != NULL ? *tail_line_end_ : *default_instance_->tail_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::mutable_tail_line_end() {
  set_has_tail_line_end();
  if (tail_line_end_ == NULL) tail_line_end_ = new ::TSD::LineEndArchive;
  return tail_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::release_tail_line_end() {
  clear_has_tail_line_end();
  ::TSD::LineEndArchive* temp = tail_line_end_;
  tail_line_end_ = NULL;
  return temp;
}
inline void ShapeArchive::set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end) {
  delete tail_line_end_;
  tail_line_end_ = tail_line_end;
  if (tail_line_end) {
    set_has_tail_line_end();
  } else {
    clear_has_tail_line_end();
  }
}

// -------------------------------------------------------------------

// ConnectionLineArchive

// required .TSD.ShapeArchive super = 1;
inline bool ConnectionLineArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionLineArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionLineArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionLineArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::ShapeArchive::Clear();
  clear_has_super();
}
inline const ::TSD::ShapeArchive& ConnectionLineArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::ShapeArchive;
  return super_;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::release_super() {
  clear_has_super();
  ::TSD::ShapeArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ConnectionLineArchive::set_allocated_super(::TSD::ShapeArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference connected_from = 2;
inline bool ConnectionLineArchive::has_connected_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionLineArchive::set_has_connected_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionLineArchive::clear_has_connected_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionLineArchive::clear_connected_from() {
  if (connected_from_ != NULL) connected_from_->::TSP::Reference::Clear();
  clear_has_connected_from();
}
inline const ::TSP::Reference& ConnectionLineArchive::connected_from() const {
  return connected_from_ != NULL ? *connected_from_ : *default_instance_->connected_from_;
}
inline ::TSP::Reference* ConnectionLineArchive::mutable_connected_from() {
  set_has_connected_from();
  if (connected_from_ == NULL) connected_from_ = new ::TSP::Reference;
  return connected_from_;
}
inline ::TSP::Reference* ConnectionLineArchive::release_connected_from() {
  clear_has_connected_from();
  ::TSP::Reference* temp = connected_from_;
  connected_from_ = NULL;
  return temp;
}
inline void ConnectionLineArchive::set_allocated_connected_from(::TSP::Reference* connected_from) {
  delete connected_from_;
  connected_from_ = connected_from;
  if (connected_from) {
    set_has_connected_from();
  } else {
    clear_has_connected_from();
  }
}

// optional .TSP.Reference connected_to = 3;
inline bool ConnectionLineArchive::has_connected_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectionLineArchive::set_has_connected_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectionLineArchive::clear_has_connected_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectionLineArchive::clear_connected_to() {
  if (connected_to_ != NULL) connected_to_->::TSP::Reference::Clear();
  clear_has_connected_to();
}
inline const ::TSP::Reference& ConnectionLineArchive::connected_to() const {
  return connected_to_ != NULL ? *connected_to_ : *default_instance_->connected_to_;
}
inline ::TSP::Reference* ConnectionLineArchive::mutable_connected_to() {
  set_has_connected_to();
  if (connected_to_ == NULL) connected_to_ = new ::TSP::Reference;
  return connected_to_;
}
inline ::TSP::Reference* ConnectionLineArchive::release_connected_to() {
  clear_has_connected_to();
  ::TSP::Reference* temp = connected_to_;
  connected_to_ = NULL;
  return temp;
}
inline void ConnectionLineArchive::set_allocated_connected_to(::TSP::Reference* connected_to) {
  delete connected_to_;
  connected_to_ = connected_to;
  if (connected_to) {
    set_has_connected_to();
  } else {
    clear_has_connected_to();
  }
}

// -------------------------------------------------------------------

// ImageArchive

// required .TSD.DrawableArchive super = 1;
inline bool ImageArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::DrawableArchive::Clear();
  clear_has_super();
}
inline const ::TSD::DrawableArchive& ImageArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::DrawableArchive* ImageArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::DrawableArchive;
  return super_;
}
inline ::TSD::DrawableArchive* ImageArchive::release_super() {
  clear_has_super();
  ::TSD::DrawableArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.DataReference data = 11;
inline bool ImageArchive::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageArchive::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageArchive::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageArchive::clear_data() {
  if (data_ != NULL) data_->::TSP::DataReference::Clear();
  clear_has_data();
}
inline const ::TSP::DataReference& ImageArchive::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::TSP::DataReference* ImageArchive::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::TSP::DataReference;
  return data_;
}
inline ::TSP::DataReference* ImageArchive::release_data() {
  clear_has_data();
  ::TSP::DataReference* temp = data_;
  data_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_data(::TSP::DataReference* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional .TSP.Reference style = 3;
inline bool ImageArchive::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageArchive::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& ImageArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* ImageArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* ImageArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// optional .TSP.Size originalSize = 4;
inline bool ImageArchive::has_originalsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageArchive::set_has_originalsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageArchive::clear_has_originalsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageArchive::clear_originalsize() {
  if (originalsize_ != NULL) originalsize_->::TSP::Size::Clear();
  clear_has_originalsize();
}
inline const ::TSP::Size& ImageArchive::originalsize() const {
  return originalsize_ != NULL ? *originalsize_ : *default_instance_->originalsize_;
}
inline ::TSP::Size* ImageArchive::mutable_originalsize() {
  set_has_originalsize();
  if (originalsize_ == NULL) originalsize_ = new ::TSP::Size;
  return originalsize_;
}
inline ::TSP::Size* ImageArchive::release_originalsize() {
  clear_has_originalsize();
  ::TSP::Size* temp = originalsize_;
  originalsize_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_originalsize(::TSP::Size* originalsize) {
  delete originalsize_;
  originalsize_ = originalsize;
  if (originalsize) {
    set_has_originalsize();
  } else {
    clear_has_originalsize();
  }
}

// optional .TSP.Reference mask = 5;
inline bool ImageArchive::has_mask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageArchive::set_has_mask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageArchive::clear_has_mask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageArchive::clear_mask() {
  if (mask_ != NULL) mask_->::TSP::Reference::Clear();
  clear_has_mask();
}
inline const ::TSP::Reference& ImageArchive::mask() const {
  return mask_ != NULL ? *mask_ : *default_instance_->mask_;
}
inline ::TSP::Reference* ImageArchive::mutable_mask() {
  set_has_mask();
  if (mask_ == NULL) mask_ = new ::TSP::Reference;
  return mask_;
}
inline ::TSP::Reference* ImageArchive::release_mask() {
  clear_has_mask();
  ::TSP::Reference* temp = mask_;
  mask_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_mask(::TSP::Reference* mask) {
  delete mask_;
  mask_ = mask;
  if (mask) {
    set_has_mask();
  } else {
    clear_has_mask();
  }
}

// optional .TSP.DataReference thumbnailData = 12;
inline bool ImageArchive::has_thumbnaildata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageArchive::set_has_thumbnaildata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageArchive::clear_has_thumbnaildata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageArchive::clear_thumbnaildata() {
  if (thumbnaildata_ != NULL) thumbnaildata_->::TSP::DataReference::Clear();
  clear_has_thumbnaildata();
}
inline const ::TSP::DataReference& ImageArchive::thumbnaildata() const {
  return thumbnaildata_ != NULL ? *thumbnaildata_ : *default_instance_->thumbnaildata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_thumbnaildata() {
  set_has_thumbnaildata();
  if (thumbnaildata_ == NULL) thumbnaildata_ = new ::TSP::DataReference;
  return thumbnaildata_;
}
inline ::TSP::DataReference* ImageArchive::release_thumbnaildata() {
  clear_has_thumbnaildata();
  ::TSP::DataReference* temp = thumbnaildata_;
  thumbnaildata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_thumbnaildata(::TSP::DataReference* thumbnaildata) {
  delete thumbnaildata_;
  thumbnaildata_ = thumbnaildata;
  if (thumbnaildata) {
    set_has_thumbnaildata();
  } else {
    clear_has_thumbnaildata();
  }
}

// optional uint32 flags = 7;
inline bool ImageArchive::has_flags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageArchive::set_has_flags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageArchive::clear_has_flags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageArchive::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 ImageArchive::flags() const {
  return flags_;
}
inline void ImageArchive::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional .TSP.DataReference originalData = 13;
inline bool ImageArchive::has_originaldata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageArchive::set_has_originaldata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageArchive::clear_has_originaldata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageArchive::clear_originaldata() {
  if (originaldata_ != NULL) originaldata_->::TSP::DataReference::Clear();
  clear_has_originaldata();
}
inline const ::TSP::DataReference& ImageArchive::originaldata() const {
  return originaldata_ != NULL ? *originaldata_ : *default_instance_->originaldata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_originaldata() {
  set_has_originaldata();
  if (originaldata_ == NULL) originaldata_ = new ::TSP::DataReference;
  return originaldata_;
}
inline ::TSP::DataReference* ImageArchive::release_originaldata() {
  clear_has_originaldata();
  ::TSP::DataReference* temp = originaldata_;
  originaldata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_originaldata(::TSP::DataReference* originaldata) {
  delete originaldata_;
  originaldata_ = originaldata;
  if (originaldata) {
    set_has_originaldata();
  } else {
    clear_has_originaldata();
  }
}

// optional .TSP.Size naturalSize = 9;
inline bool ImageArchive::has_naturalsize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageArchive::set_has_naturalsize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageArchive::clear_has_naturalsize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageArchive::clear_naturalsize() {
  if (naturalsize_ != NULL) naturalsize_->::TSP::Size::Clear();
  clear_has_naturalsize();
}
inline const ::TSP::Size& ImageArchive::naturalsize() const {
  return naturalsize_ != NULL ? *naturalsize_ : *default_instance_->naturalsize_;
}
inline ::TSP::Size* ImageArchive::mutable_naturalsize() {
  set_has_naturalsize();
  if (naturalsize_ == NULL) naturalsize_ = new ::TSP::Size;
  return naturalsize_;
}
inline ::TSP::Size* ImageArchive::release_naturalsize() {
  clear_has_naturalsize();
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  delete naturalsize_;
  naturalsize_ = naturalsize;
  if (naturalsize) {
    set_has_naturalsize();
  } else {
    clear_has_naturalsize();
  }
}

// optional .TSP.Path instantAlphaPath = 10;
inline bool ImageArchive::has_instantalphapath() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageArchive::set_has_instantalphapath() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageArchive::clear_has_instantalphapath() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageArchive::clear_instantalphapath() {
  if (instantalphapath_ != NULL) instantalphapath_->::TSP::Path::Clear();
  clear_has_instantalphapath();
}
inline const ::TSP::Path& ImageArchive::instantalphapath() const {
  return instantalphapath_ != NULL ? *instantalphapath_ : *default_instance_->instantalphapath_;
}
inline ::TSP::Path* ImageArchive::mutable_instantalphapath() {
  set_has_instantalphapath();
  if (instantalphapath_ == NULL) instantalphapath_ = new ::TSP::Path;
  return instantalphapath_;
}
inline ::TSP::Path* ImageArchive::release_instantalphapath() {
  clear_has_instantalphapath();
  ::TSP::Path* temp = instantalphapath_;
  instantalphapath_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_instantalphapath(::TSP::Path* instantalphapath) {
  delete instantalphapath_;
  instantalphapath_ = instantalphapath;
  if (instantalphapath) {
    set_has_instantalphapath();
  } else {
    clear_has_instantalphapath();
  }
}

// optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
inline bool ImageArchive::has_imageadjustments() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageArchive::set_has_imageadjustments() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageArchive::clear_has_imageadjustments() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageArchive::clear_imageadjustments() {
  if (imageadjustments_ != NULL) imageadjustments_->::TSD::ImageAdjustmentsArchive::Clear();
  clear_has_imageadjustments();
}
inline const ::TSD::ImageAdjustmentsArchive& ImageArchive::imageadjustments() const {
  return imageadjustments_ != NULL ? *imageadjustments_ : *default_instance_->imageadjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::mutable_imageadjustments() {
  set_has_imageadjustments();
  if (imageadjustments_ == NULL) imageadjustments_ = new ::TSD::ImageAdjustmentsArchive;
  return imageadjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::release_imageadjustments() {
  clear_has_imageadjustments();
  ::TSD::ImageAdjustmentsArchive* temp = imageadjustments_;
  imageadjustments_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_imageadjustments(::TSD::ImageAdjustmentsArchive* imageadjustments) {
  delete imageadjustments_;
  imageadjustments_ = imageadjustments;
  if (imageadjustments) {
    set_has_imageadjustments();
  } else {
    clear_has_imageadjustments();
  }
}

// optional .TSP.DataReference enhancedImageData = 17;
inline bool ImageArchive::has_enhancedimagedata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageArchive::set_has_enhancedimagedata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageArchive::clear_has_enhancedimagedata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageArchive::clear_enhancedimagedata() {
  if (enhancedimagedata_ != NULL) enhancedimagedata_->::TSP::DataReference::Clear();
  clear_has_enhancedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::enhancedimagedata() const {
  return enhancedimagedata_ != NULL ? *enhancedimagedata_ : *default_instance_->enhancedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_enhancedimagedata() {
  set_has_enhancedimagedata();
  if (enhancedimagedata_ == NULL) enhancedimagedata_ = new ::TSP::DataReference;
  return enhancedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::release_enhancedimagedata() {
  clear_has_enhancedimagedata();
  ::TSP::DataReference* temp = enhancedimagedata_;
  enhancedimagedata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata) {
  delete enhancedimagedata_;
  enhancedimagedata_ = enhancedimagedata;
  if (enhancedimagedata) {
    set_has_enhancedimagedata();
  } else {
    clear_has_enhancedimagedata();
  }
}

// optional .TSP.DataReference adjustedImageData = 15;
inline bool ImageArchive::has_adjustedimagedata() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImageArchive::set_has_adjustedimagedata() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImageArchive::clear_has_adjustedimagedata() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImageArchive::clear_adjustedimagedata() {
  if (adjustedimagedata_ != NULL) adjustedimagedata_->::TSP::DataReference::Clear();
  clear_has_adjustedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::adjustedimagedata() const {
  return adjustedimagedata_ != NULL ? *adjustedimagedata_ : *default_instance_->adjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_adjustedimagedata() {
  set_has_adjustedimagedata();
  if (adjustedimagedata_ == NULL) adjustedimagedata_ = new ::TSP::DataReference;
  return adjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::release_adjustedimagedata() {
  clear_has_adjustedimagedata();
  ::TSP::DataReference* temp = adjustedimagedata_;
  adjustedimagedata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata) {
  delete adjustedimagedata_;
  adjustedimagedata_ = adjustedimagedata;
  if (adjustedimagedata) {
    set_has_adjustedimagedata();
  } else {
    clear_has_adjustedimagedata();
  }
}

// optional .TSP.DataReference thumbnailAdjustedImageData = 16;
inline bool ImageArchive::has_thumbnailadjustedimagedata() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ImageArchive::set_has_thumbnailadjustedimagedata() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ImageArchive::clear_has_thumbnailadjustedimagedata() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ImageArchive::clear_thumbnailadjustedimagedata() {
  if (thumbnailadjustedimagedata_ != NULL) thumbnailadjustedimagedata_->::TSP::DataReference::Clear();
  clear_has_thumbnailadjustedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::thumbnailadjustedimagedata() const {
  return thumbnailadjustedimagedata_ != NULL ? *thumbnailadjustedimagedata_ : *default_instance_->thumbnailadjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_thumbnailadjustedimagedata() {
  set_has_thumbnailadjustedimagedata();
  if (thumbnailadjustedimagedata_ == NULL) thumbnailadjustedimagedata_ = new ::TSP::DataReference;
  return thumbnailadjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::release_thumbnailadjustedimagedata() {
  clear_has_thumbnailadjustedimagedata();
  ::TSP::DataReference* temp = thumbnailadjustedimagedata_;
  thumbnailadjustedimagedata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_thumbnailadjustedimagedata(::TSP::DataReference* thumbnailadjustedimagedata) {
  delete thumbnailadjustedimagedata_;
  thumbnailadjustedimagedata_ = thumbnailadjustedimagedata;
  if (thumbnailadjustedimagedata) {
    set_has_thumbnailadjustedimagedata();
  } else {
    clear_has_thumbnailadjustedimagedata();
  }
}

// optional bool interpretsUntaggedImageDataAsGeneric = 18;
inline bool ImageArchive::has_interpretsuntaggedimagedataasgeneric() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ImageArchive::set_has_interpretsuntaggedimagedataasgeneric() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ImageArchive::clear_has_interpretsuntaggedimagedataasgeneric() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ImageArchive::clear_interpretsuntaggedimagedataasgeneric() {
  interpretsuntaggedimagedataasgeneric_ = false;
  clear_has_interpretsuntaggedimagedataasgeneric();
}
inline bool ImageArchive::interpretsuntaggedimagedataasgeneric() const {
  return interpretsuntaggedimagedataasgeneric_;
}
inline void ImageArchive::set_interpretsuntaggedimagedataasgeneric(bool value) {
  set_has_interpretsuntaggedimagedataasgeneric();
  interpretsuntaggedimagedataasgeneric_ = value;
}

// optional .TSP.Reference database_data = 2;
inline bool ImageArchive::has_database_data() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ImageArchive::set_has_database_data() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ImageArchive::clear_has_database_data() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ImageArchive::clear_database_data() {
  if (database_data_ != NULL) database_data_->::TSP::Reference::Clear();
  clear_has_database_data();
}
inline const ::TSP::Reference& ImageArchive::database_data() const {
  return database_data_ != NULL ? *database_data_ : *default_instance_->database_data_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_data() {
  set_has_database_data();
  if (database_data_ == NULL) database_data_ = new ::TSP::Reference;
  return database_data_;
}
inline ::TSP::Reference* ImageArchive::release_database_data() {
  clear_has_database_data();
  ::TSP::Reference* temp = database_data_;
  database_data_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_database_data(::TSP::Reference* database_data) {
  delete database_data_;
  database_data_ = database_data;
  if (database_data) {
    set_has_database_data();
  } else {
    clear_has_database_data();
  }
}

// optional .TSP.Reference database_thumbnailData = 6;
inline bool ImageArchive::has_database_thumbnaildata() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ImageArchive::set_has_database_thumbnaildata() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ImageArchive::clear_has_database_thumbnaildata() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ImageArchive::clear_database_thumbnaildata() {
  if (database_thumbnaildata_ != NULL) database_thumbnaildata_->::TSP::Reference::Clear();
  clear_has_database_thumbnaildata();
}
inline const ::TSP::Reference& ImageArchive::database_thumbnaildata() const {
  return database_thumbnaildata_ != NULL ? *database_thumbnaildata_ : *default_instance_->database_thumbnaildata_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_thumbnaildata() {
  set_has_database_thumbnaildata();
  if (database_thumbnaildata_ == NULL) database_thumbnaildata_ = new ::TSP::Reference;
  return database_thumbnaildata_;
}
inline ::TSP::Reference* ImageArchive::release_database_thumbnaildata() {
  clear_has_database_thumbnaildata();
  ::TSP::Reference* temp = database_thumbnaildata_;
  database_thumbnaildata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_database_thumbnaildata(::TSP::Reference* database_thumbnaildata) {
  delete database_thumbnaildata_;
  database_thumbnaildata_ = database_thumbnaildata;
  if (database_thumbnaildata) {
    set_has_database_thumbnaildata();
  } else {
    clear_has_database_thumbnaildata();
  }
}

// optional .TSP.Reference database_originalData = 8;
inline bool ImageArchive::has_database_originaldata() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ImageArchive::set_has_database_originaldata() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ImageArchive::clear_has_database_originaldata() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ImageArchive::clear_database_originaldata() {
  if (database_originaldata_ != NULL) database_originaldata_->::TSP::Reference::Clear();
  clear_has_database_originaldata();
}
inline const ::TSP::Reference& ImageArchive::database_originaldata() const {
  return database_originaldata_ != NULL ? *database_originaldata_ : *default_instance_->database_originaldata_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_originaldata() {
  set_has_database_originaldata();
  if (database_originaldata_ == NULL) database_originaldata_ = new ::TSP::Reference;
  return database_originaldata_;
}
inline ::TSP::Reference* ImageArchive::release_database_originaldata() {
  clear_has_database_originaldata();
  ::TSP::Reference* temp = database_originaldata_;
  database_originaldata_ = NULL;
  return temp;
}
inline void ImageArchive::set_allocated_database_originaldata(::TSP::Reference* database_originaldata) {
  delete database_originaldata_;
  database_originaldata_ = database_originaldata;
  if (database_originaldata) {
    set_has_database_originaldata();
  } else {
    clear_has_database_originaldata();
  }
}

// -------------------------------------------------------------------

// MaskArchive

// required .TSD.DrawableArchive super = 1;
inline bool MaskArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaskArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaskArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaskArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::DrawableArchive::Clear();
  clear_has_super();
}
inline const ::TSD::DrawableArchive& MaskArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::DrawableArchive* MaskArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::DrawableArchive;
  return super_;
}
inline ::TSD::DrawableArchive* MaskArchive::release_super() {
  clear_has_super();
  ::TSD::DrawableArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MaskArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSD.PathSourceArchive pathsource = 2;
inline bool MaskArchive::has_pathsource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaskArchive::set_has_pathsource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaskArchive::clear_has_pathsource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaskArchive::clear_pathsource() {
  if (pathsource_ != NULL) pathsource_->::TSD::PathSourceArchive::Clear();
  clear_has_pathsource();
}
inline const ::TSD::PathSourceArchive& MaskArchive::pathsource() const {
  return pathsource_ != NULL ? *pathsource_ : *default_instance_->pathsource_;
}
inline ::TSD::PathSourceArchive* MaskArchive::mutable_pathsource() {
  set_has_pathsource();
  if (pathsource_ == NULL) pathsource_ = new ::TSD::PathSourceArchive;
  return pathsource_;
}
inline ::TSD::PathSourceArchive* MaskArchive::release_pathsource() {
  clear_has_pathsource();
  ::TSD::PathSourceArchive* temp = pathsource_;
  pathsource_ = NULL;
  return temp;
}
inline void MaskArchive::set_allocated_pathsource(::TSD::PathSourceArchive* pathsource) {
  delete pathsource_;
  pathsource_ = pathsource;
  if (pathsource) {
    set_has_pathsource();
  } else {
    clear_has_pathsource();
  }
}

// -------------------------------------------------------------------

// MovieArchive

// required .TSD.DrawableArchive super = 1;
inline bool MovieArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MovieArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MovieArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MovieArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::DrawableArchive::Clear();
  clear_has_super();
}
inline const ::TSD::DrawableArchive& MovieArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::DrawableArchive* MovieArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::DrawableArchive;
  return super_;
}
inline ::TSD::DrawableArchive* MovieArchive::release_super() {
  clear_has_super();
  ::TSD::DrawableArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.DataReference movieData = 14;
inline bool MovieArchive::has_moviedata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MovieArchive::set_has_moviedata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MovieArchive::clear_has_moviedata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MovieArchive::clear_moviedata() {
  if (moviedata_ != NULL) moviedata_->::TSP::DataReference::Clear();
  clear_has_moviedata();
}
inline const ::TSP::DataReference& MovieArchive::moviedata() const {
  return moviedata_ != NULL ? *moviedata_ : *default_instance_->moviedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_moviedata() {
  set_has_moviedata();
  if (moviedata_ == NULL) moviedata_ = new ::TSP::DataReference;
  return moviedata_;
}
inline ::TSP::DataReference* MovieArchive::release_moviedata() {
  clear_has_moviedata();
  ::TSP::DataReference* temp = moviedata_;
  moviedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_moviedata(::TSP::DataReference* moviedata) {
  delete moviedata_;
  moviedata_ = moviedata;
  if (moviedata) {
    set_has_moviedata();
  } else {
    clear_has_moviedata();
  }
}

// optional .TSP.DataReference importedAuxiliaryMovieData = 22;
inline bool MovieArchive::has_importedauxiliarymoviedata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MovieArchive::set_has_importedauxiliarymoviedata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MovieArchive::clear_has_importedauxiliarymoviedata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MovieArchive::clear_importedauxiliarymoviedata() {
  if (importedauxiliarymoviedata_ != NULL) importedauxiliarymoviedata_->::TSP::DataReference::Clear();
  clear_has_importedauxiliarymoviedata();
}
inline const ::TSP::DataReference& MovieArchive::importedauxiliarymoviedata() const {
  return importedauxiliarymoviedata_ != NULL ? *importedauxiliarymoviedata_ : *default_instance_->importedauxiliarymoviedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_importedauxiliarymoviedata() {
  set_has_importedauxiliarymoviedata();
  if (importedauxiliarymoviedata_ == NULL) importedauxiliarymoviedata_ = new ::TSP::DataReference;
  return importedauxiliarymoviedata_;
}
inline ::TSP::DataReference* MovieArchive::release_importedauxiliarymoviedata() {
  clear_has_importedauxiliarymoviedata();
  ::TSP::DataReference* temp = importedauxiliarymoviedata_;
  importedauxiliarymoviedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_importedauxiliarymoviedata(::TSP::DataReference* importedauxiliarymoviedata) {
  delete importedauxiliarymoviedata_;
  importedauxiliarymoviedata_ = importedauxiliarymoviedata;
  if (importedauxiliarymoviedata) {
    set_has_importedauxiliarymoviedata();
  } else {
    clear_has_importedauxiliarymoviedata();
  }
}

// optional string movieRemoteURL = 17;
inline bool MovieArchive::has_movieremoteurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MovieArchive::set_has_movieremoteurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MovieArchive::clear_has_movieremoteurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MovieArchive::clear_movieremoteurl() {
  if (movieremoteurl_ != &::google::protobuf::internal::kEmptyString) {
    movieremoteurl_->clear();
  }
  clear_has_movieremoteurl();
}
inline const ::std::string& MovieArchive::movieremoteurl() const {
  return *movieremoteurl_;
}
inline void MovieArchive::set_movieremoteurl(const ::std::string& value) {
  set_has_movieremoteurl();
  if (movieremoteurl_ == &::google::protobuf::internal::kEmptyString) {
    movieremoteurl_ = new ::std::string;
  }
  movieremoteurl_->assign(value);
}
inline void MovieArchive::set_movieremoteurl(const char* value) {
  set_has_movieremoteurl();
  if (movieremoteurl_ == &::google::protobuf::internal::kEmptyString) {
    movieremoteurl_ = new ::std::string;
  }
  movieremoteurl_->assign(value);
}
inline void MovieArchive::set_movieremoteurl(const char* value, size_t size) {
  set_has_movieremoteurl();
  if (movieremoteurl_ == &::google::protobuf::internal::kEmptyString) {
    movieremoteurl_ = new ::std::string;
  }
  movieremoteurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MovieArchive::mutable_movieremoteurl() {
  set_has_movieremoteurl();
  if (movieremoteurl_ == &::google::protobuf::internal::kEmptyString) {
    movieremoteurl_ = new ::std::string;
  }
  return movieremoteurl_;
}
inline ::std::string* MovieArchive::release_movieremoteurl() {
  clear_has_movieremoteurl();
  if (movieremoteurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = movieremoteurl_;
    movieremoteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MovieArchive::set_allocated_movieremoteurl(::std::string* movieremoteurl) {
  if (movieremoteurl_ != &::google::protobuf::internal::kEmptyString) {
    delete movieremoteurl_;
  }
  if (movieremoteurl) {
    set_has_movieremoteurl();
    movieremoteurl_ = movieremoteurl;
  } else {
    clear_has_movieremoteurl();
    movieremoteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float startTime = 3;
inline bool MovieArchive::has_starttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MovieArchive::set_has_starttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MovieArchive::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MovieArchive::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float MovieArchive::starttime() const {
  return starttime_;
}
inline void MovieArchive::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
}

// optional float endTime = 4;
inline bool MovieArchive::has_endtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MovieArchive::set_has_endtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MovieArchive::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MovieArchive::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline float MovieArchive::endtime() const {
  return endtime_;
}
inline void MovieArchive::set_endtime(float value) {
  set_has_endtime();
  endtime_ = value;
}

// optional float posterTime = 5;
inline bool MovieArchive::has_postertime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MovieArchive::set_has_postertime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MovieArchive::clear_has_postertime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MovieArchive::clear_postertime() {
  postertime_ = 0;
  clear_has_postertime();
}
inline float MovieArchive::postertime() const {
  return postertime_;
}
inline void MovieArchive::set_postertime(float value) {
  set_has_postertime();
  postertime_ = value;
}

// optional uint32 loopOptionAsInteger = 6 [deprecated = true];
inline bool MovieArchive::has_loopoptionasinteger() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MovieArchive::set_has_loopoptionasinteger() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MovieArchive::clear_has_loopoptionasinteger() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MovieArchive::clear_loopoptionasinteger() {
  loopoptionasinteger_ = 0u;
  clear_has_loopoptionasinteger();
}
inline ::google::protobuf::uint32 MovieArchive::loopoptionasinteger() const {
  return loopoptionasinteger_;
}
inline void MovieArchive::set_loopoptionasinteger(::google::protobuf::uint32 value) {
  set_has_loopoptionasinteger();
  loopoptionasinteger_ = value;
}

// optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
inline bool MovieArchive::has_loop_option() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MovieArchive::set_has_loop_option() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MovieArchive::clear_has_loop_option() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MovieArchive::clear_loop_option() {
  loop_option_ = 0;
  clear_has_loop_option();
}
inline ::TSD::MovieArchive_MovieLoopOption MovieArchive::loop_option() const {
  return static_cast< ::TSD::MovieArchive_MovieLoopOption >(loop_option_);
}
inline void MovieArchive::set_loop_option(::TSD::MovieArchive_MovieLoopOption value) {
  assert(::TSD::MovieArchive_MovieLoopOption_IsValid(value));
  set_has_loop_option();
  loop_option_ = value;
}

// optional float volume = 7;
inline bool MovieArchive::has_volume() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MovieArchive::set_has_volume() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MovieArchive::clear_has_volume() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MovieArchive::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline float MovieArchive::volume() const {
  return volume_;
}
inline void MovieArchive::set_volume(float value) {
  set_has_volume();
  volume_ = value;
}

// optional bool autoPlay = 8 [deprecated = true];
inline bool MovieArchive::has_autoplay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MovieArchive::set_has_autoplay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MovieArchive::clear_has_autoplay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MovieArchive::clear_autoplay() {
  autoplay_ = false;
  clear_has_autoplay();
}
inline bool MovieArchive::autoplay() const {
  return autoplay_;
}
inline void MovieArchive::set_autoplay(bool value) {
  set_has_autoplay();
  autoplay_ = value;
}

// optional bool audioOnly = 9;
inline bool MovieArchive::has_audioonly() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MovieArchive::set_has_audioonly() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MovieArchive::clear_has_audioonly() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MovieArchive::clear_audioonly() {
  audioonly_ = false;
  clear_has_audioonly();
}
inline bool MovieArchive::audioonly() const {
  return audioonly_;
}
inline void MovieArchive::set_audioonly(bool value) {
  set_has_audioonly();
  audioonly_ = value;
}

// optional bool streaming = 18;
inline bool MovieArchive::has_streaming() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MovieArchive::set_has_streaming() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MovieArchive::clear_has_streaming() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MovieArchive::clear_streaming() {
  streaming_ = false;
  clear_has_streaming();
}
inline bool MovieArchive::streaming() const {
  return streaming_;
}
inline void MovieArchive::set_streaming(bool value) {
  set_has_streaming();
  streaming_ = value;
}

// optional .TSP.DataReference posterImageData = 15;
inline bool MovieArchive::has_posterimagedata() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MovieArchive::set_has_posterimagedata() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MovieArchive::clear_has_posterimagedata() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MovieArchive::clear_posterimagedata() {
  if (posterimagedata_ != NULL) posterimagedata_->::TSP::DataReference::Clear();
  clear_has_posterimagedata();
}
inline const ::TSP::DataReference& MovieArchive::posterimagedata() const {
  return posterimagedata_ != NULL ? *posterimagedata_ : *default_instance_->posterimagedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_posterimagedata() {
  set_has_posterimagedata();
  if (posterimagedata_ == NULL) posterimagedata_ = new ::TSP::DataReference;
  return posterimagedata_;
}
inline ::TSP::DataReference* MovieArchive::release_posterimagedata() {
  clear_has_posterimagedata();
  ::TSP::DataReference* temp = posterimagedata_;
  posterimagedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_posterimagedata(::TSP::DataReference* posterimagedata) {
  delete posterimagedata_;
  posterimagedata_ = posterimagedata;
  if (posterimagedata) {
    set_has_posterimagedata();
  } else {
    clear_has_posterimagedata();
  }
}

// optional .TSP.DataReference audioOnlyImageData = 16;
inline bool MovieArchive::has_audioonlyimagedata() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MovieArchive::set_has_audioonlyimagedata() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MovieArchive::clear_has_audioonlyimagedata() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MovieArchive::clear_audioonlyimagedata() {
  if (audioonlyimagedata_ != NULL) audioonlyimagedata_->::TSP::DataReference::Clear();
  clear_has_audioonlyimagedata();
}
inline const ::TSP::DataReference& MovieArchive::audioonlyimagedata() const {
  return audioonlyimagedata_ != NULL ? *audioonlyimagedata_ : *default_instance_->audioonlyimagedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_audioonlyimagedata() {
  set_has_audioonlyimagedata();
  if (audioonlyimagedata_ == NULL) audioonlyimagedata_ = new ::TSP::DataReference;
  return audioonlyimagedata_;
}
inline ::TSP::DataReference* MovieArchive::release_audioonlyimagedata() {
  clear_has_audioonlyimagedata();
  ::TSP::DataReference* temp = audioonlyimagedata_;
  audioonlyimagedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_audioonlyimagedata(::TSP::DataReference* audioonlyimagedata) {
  delete audioonlyimagedata_;
  audioonlyimagedata_ = audioonlyimagedata;
  if (audioonlyimagedata) {
    set_has_audioonlyimagedata();
  } else {
    clear_has_audioonlyimagedata();
  }
}

// optional bool poster_image_generated_with_alpha_support = 23;
inline bool MovieArchive::has_poster_image_generated_with_alpha_support() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MovieArchive::set_has_poster_image_generated_with_alpha_support() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MovieArchive::clear_has_poster_image_generated_with_alpha_support() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MovieArchive::clear_poster_image_generated_with_alpha_support() {
  poster_image_generated_with_alpha_support_ = false;
  clear_has_poster_image_generated_with_alpha_support();
}
inline bool MovieArchive::poster_image_generated_with_alpha_support() const {
  return poster_image_generated_with_alpha_support_;
}
inline void MovieArchive::set_poster_image_generated_with_alpha_support(bool value) {
  set_has_poster_image_generated_with_alpha_support();
  poster_image_generated_with_alpha_support_ = value;
}

// optional uint32 playableState = 12;
inline bool MovieArchive::has_playablestate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MovieArchive::set_has_playablestate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MovieArchive::clear_has_playablestate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MovieArchive::clear_playablestate() {
  playablestate_ = 0u;
  clear_has_playablestate();
}
inline ::google::protobuf::uint32 MovieArchive::playablestate() const {
  return playablestate_;
}
inline void MovieArchive::set_playablestate(::google::protobuf::uint32 value) {
  set_has_playablestate();
  playablestate_ = value;
}

// optional uint32 flags = 13;
inline bool MovieArchive::has_flags() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MovieArchive::set_has_flags() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MovieArchive::clear_has_flags() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MovieArchive::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MovieArchive::flags() const {
  return flags_;
}
inline void MovieArchive::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional .TSP.Reference database_movieData = 2;
inline bool MovieArchive::has_database_moviedata() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MovieArchive::set_has_database_moviedata() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MovieArchive::clear_has_database_moviedata() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MovieArchive::clear_database_moviedata() {
  if (database_moviedata_ != NULL) database_moviedata_->::TSP::Reference::Clear();
  clear_has_database_moviedata();
}
inline const ::TSP::Reference& MovieArchive::database_moviedata() const {
  return database_moviedata_ != NULL ? *database_moviedata_ : *default_instance_->database_moviedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_moviedata() {
  set_has_database_moviedata();
  if (database_moviedata_ == NULL) database_moviedata_ = new ::TSP::Reference;
  return database_moviedata_;
}
inline ::TSP::Reference* MovieArchive::release_database_moviedata() {
  clear_has_database_moviedata();
  ::TSP::Reference* temp = database_moviedata_;
  database_moviedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_database_moviedata(::TSP::Reference* database_moviedata) {
  delete database_moviedata_;
  database_moviedata_ = database_moviedata;
  if (database_moviedata) {
    set_has_database_moviedata();
  } else {
    clear_has_database_moviedata();
  }
}

// optional .TSP.Reference database_posterImageData = 10;
inline bool MovieArchive::has_database_posterimagedata() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MovieArchive::set_has_database_posterimagedata() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MovieArchive::clear_has_database_posterimagedata() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MovieArchive::clear_database_posterimagedata() {
  if (database_posterimagedata_ != NULL) database_posterimagedata_->::TSP::Reference::Clear();
  clear_has_database_posterimagedata();
}
inline const ::TSP::Reference& MovieArchive::database_posterimagedata() const {
  return database_posterimagedata_ != NULL ? *database_posterimagedata_ : *default_instance_->database_posterimagedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_posterimagedata() {
  set_has_database_posterimagedata();
  if (database_posterimagedata_ == NULL) database_posterimagedata_ = new ::TSP::Reference;
  return database_posterimagedata_;
}
inline ::TSP::Reference* MovieArchive::release_database_posterimagedata() {
  clear_has_database_posterimagedata();
  ::TSP::Reference* temp = database_posterimagedata_;
  database_posterimagedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_database_posterimagedata(::TSP::Reference* database_posterimagedata) {
  delete database_posterimagedata_;
  database_posterimagedata_ = database_posterimagedata;
  if (database_posterimagedata) {
    set_has_database_posterimagedata();
  } else {
    clear_has_database_posterimagedata();
  }
}

// optional .TSP.Reference database_audioOnlyImageData = 11;
inline bool MovieArchive::has_database_audioonlyimagedata() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MovieArchive::set_has_database_audioonlyimagedata() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MovieArchive::clear_has_database_audioonlyimagedata() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MovieArchive::clear_database_audioonlyimagedata() {
  if (database_audioonlyimagedata_ != NULL) database_audioonlyimagedata_->::TSP::Reference::Clear();
  clear_has_database_audioonlyimagedata();
}
inline const ::TSP::Reference& MovieArchive::database_audioonlyimagedata() const {
  return database_audioonlyimagedata_ != NULL ? *database_audioonlyimagedata_ : *default_instance_->database_audioonlyimagedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_audioonlyimagedata() {
  set_has_database_audioonlyimagedata();
  if (database_audioonlyimagedata_ == NULL) database_audioonlyimagedata_ = new ::TSP::Reference;
  return database_audioonlyimagedata_;
}
inline ::TSP::Reference* MovieArchive::release_database_audioonlyimagedata() {
  clear_has_database_audioonlyimagedata();
  ::TSP::Reference* temp = database_audioonlyimagedata_;
  database_audioonlyimagedata_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_database_audioonlyimagedata(::TSP::Reference* database_audioonlyimagedata) {
  delete database_audioonlyimagedata_;
  database_audioonlyimagedata_ = database_audioonlyimagedata;
  if (database_audioonlyimagedata) {
    set_has_database_audioonlyimagedata();
  } else {
    clear_has_database_audioonlyimagedata();
  }
}

// optional .TSP.Reference style = 19;
inline bool MovieArchive::has_style() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MovieArchive::set_has_style() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MovieArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MovieArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& MovieArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* MovieArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* MovieArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// optional .TSP.Size originalSize = 20;
inline bool MovieArchive::has_originalsize() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MovieArchive::set_has_originalsize() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MovieArchive::clear_has_originalsize() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MovieArchive::clear_originalsize() {
  if (originalsize_ != NULL) originalsize_->::TSP::Size::Clear();
  clear_has_originalsize();
}
inline const ::TSP::Size& MovieArchive::originalsize() const {
  return originalsize_ != NULL ? *originalsize_ : *default_instance_->originalsize_;
}
inline ::TSP::Size* MovieArchive::mutable_originalsize() {
  set_has_originalsize();
  if (originalsize_ == NULL) originalsize_ = new ::TSP::Size;
  return originalsize_;
}
inline ::TSP::Size* MovieArchive::release_originalsize() {
  clear_has_originalsize();
  ::TSP::Size* temp = originalsize_;
  originalsize_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_originalsize(::TSP::Size* originalsize) {
  delete originalsize_;
  originalsize_ = originalsize;
  if (originalsize) {
    set_has_originalsize();
  } else {
    clear_has_originalsize();
  }
}

// optional .TSP.Size naturalSize = 21;
inline bool MovieArchive::has_naturalsize() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MovieArchive::set_has_naturalsize() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MovieArchive::clear_has_naturalsize() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MovieArchive::clear_naturalsize() {
  if (naturalsize_ != NULL) naturalsize_->::TSP::Size::Clear();
  clear_has_naturalsize();
}
inline const ::TSP::Size& MovieArchive::naturalsize() const {
  return naturalsize_ != NULL ? *naturalsize_ : *default_instance_->naturalsize_;
}
inline ::TSP::Size* MovieArchive::mutable_naturalsize() {
  set_has_naturalsize();
  if (naturalsize_ == NULL) naturalsize_ = new ::TSP::Size;
  return naturalsize_;
}
inline ::TSP::Size* MovieArchive::release_naturalsize() {
  clear_has_naturalsize();
  ::TSP::Size* temp = naturalsize_;
  naturalsize_ = NULL;
  return temp;
}
inline void MovieArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  delete naturalsize_;
  naturalsize_ = naturalsize;
  if (naturalsize) {
    set_has_naturalsize();
  } else {
    clear_has_naturalsize();
  }
}

// -------------------------------------------------------------------

// ExteriorTextWrapArchive

// optional uint32 type = 1;
inline bool ExteriorTextWrapArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExteriorTextWrapArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExteriorTextWrapArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExteriorTextWrapArchive::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ExteriorTextWrapArchive::type() const {
  return type_;
}
inline void ExteriorTextWrapArchive::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 direction = 2;
inline bool ExteriorTextWrapArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExteriorTextWrapArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExteriorTextWrapArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExteriorTextWrapArchive::clear_direction() {
  direction_ = 0u;
  clear_has_direction();
}
inline ::google::protobuf::uint32 ExteriorTextWrapArchive::direction() const {
  return direction_;
}
inline void ExteriorTextWrapArchive::set_direction(::google::protobuf::uint32 value) {
  set_has_direction();
  direction_ = value;
}

// optional uint32 fit_type = 3;
inline bool ExteriorTextWrapArchive::has_fit_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExteriorTextWrapArchive::set_has_fit_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExteriorTextWrapArchive::clear_has_fit_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExteriorTextWrapArchive::clear_fit_type() {
  fit_type_ = 0u;
  clear_has_fit_type();
}
inline ::google::protobuf::uint32 ExteriorTextWrapArchive::fit_type() const {
  return fit_type_;
}
inline void ExteriorTextWrapArchive::set_fit_type(::google::protobuf::uint32 value) {
  set_has_fit_type();
  fit_type_ = value;
}

// optional float margin = 4;
inline bool ExteriorTextWrapArchive::has_margin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExteriorTextWrapArchive::set_has_margin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExteriorTextWrapArchive::clear_has_margin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExteriorTextWrapArchive::clear_margin() {
  margin_ = 0;
  clear_has_margin();
}
inline float ExteriorTextWrapArchive::margin() const {
  return margin_;
}
inline void ExteriorTextWrapArchive::set_margin(float value) {
  set_has_margin();
  margin_ = value;
}

// optional float alpha_threshold = 5;
inline bool ExteriorTextWrapArchive::has_alpha_threshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExteriorTextWrapArchive::set_has_alpha_threshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExteriorTextWrapArchive::clear_has_alpha_threshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExteriorTextWrapArchive::clear_alpha_threshold() {
  alpha_threshold_ = 0;
  clear_has_alpha_threshold();
}
inline float ExteriorTextWrapArchive::alpha_threshold() const {
  return alpha_threshold_;
}
inline void ExteriorTextWrapArchive::set_alpha_threshold(float value) {
  set_has_alpha_threshold();
  alpha_threshold_ = value;
}

// optional bool is_html_wrap = 6;
inline bool ExteriorTextWrapArchive::has_is_html_wrap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExteriorTextWrapArchive::set_has_is_html_wrap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExteriorTextWrapArchive::clear_has_is_html_wrap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExteriorTextWrapArchive::clear_is_html_wrap() {
  is_html_wrap_ = false;
  clear_has_is_html_wrap();
}
inline bool ExteriorTextWrapArchive::is_html_wrap() const {
  return is_html_wrap_;
}
inline void ExteriorTextWrapArchive::set_is_html_wrap(bool value) {
  set_has_is_html_wrap();
  is_html_wrap_ = value;
}

// -------------------------------------------------------------------

// GuideArchive

// optional .TSD.GuideArchive.GuideType type = 1;
inline bool GuideArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::GuideArchive_GuideType GuideArchive::type() const {
  return static_cast< ::TSD::GuideArchive_GuideType >(type_);
}
inline void GuideArchive::set_type(::TSD::GuideArchive_GuideType value) {
  assert(::TSD::GuideArchive_GuideType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float offset = 2;
inline bool GuideArchive::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideArchive::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideArchive::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideArchive::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float GuideArchive::offset() const {
  return offset_;
}
inline void GuideArchive::set_offset(float value) {
  set_has_offset();
  offset_ = value;
}

// optional float start = 3;
inline bool GuideArchive::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideArchive::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideArchive::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideArchive::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline float GuideArchive::start() const {
  return start_;
}
inline void GuideArchive::set_start(float value) {
  set_has_start();
  start_ = value;
}

// optional float end = 4;
inline bool GuideArchive::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideArchive::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideArchive::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideArchive::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline float GuideArchive::end() const {
  return end_;
}
inline void GuideArchive::set_end(float value) {
  set_has_end();
  end_ = value;
}

// optional bool dynamic = 5;
inline bool GuideArchive::has_dynamic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideArchive::set_has_dynamic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideArchive::clear_has_dynamic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideArchive::clear_dynamic() {
  dynamic_ = false;
  clear_has_dynamic();
}
inline bool GuideArchive::dynamic() const {
  return dynamic_;
}
inline void GuideArchive::set_dynamic(bool value) {
  set_has_dynamic();
  dynamic_ = value;
}

// optional bool infinite = 6;
inline bool GuideArchive::has_infinite() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuideArchive::set_has_infinite() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuideArchive::clear_has_infinite() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuideArchive::clear_infinite() {
  infinite_ = false;
  clear_has_infinite();
}
inline bool GuideArchive::infinite() const {
  return infinite_;
}
inline void GuideArchive::set_infinite(bool value) {
  set_has_infinite();
  infinite_ = value;
}

// -------------------------------------------------------------------

// UserDefinedGuideArchive

// optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
inline bool UserDefinedGuideArchive::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDefinedGuideArchive::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDefinedGuideArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDefinedGuideArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TSD::UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::type() const {
  return static_cast< ::TSD::UserDefinedGuideArchive_GuideType >(type_);
}
inline void UserDefinedGuideArchive::set_type(::TSD::UserDefinedGuideArchive_GuideType value) {
  assert(::TSD::UserDefinedGuideArchive_GuideType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float position = 2;
inline bool UserDefinedGuideArchive::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDefinedGuideArchive::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDefinedGuideArchive::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDefinedGuideArchive::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline float UserDefinedGuideArchive::position() const {
  return position_;
}
inline void UserDefinedGuideArchive::set_position(float value) {
  set_has_position();
  position_ = value;
}

// -------------------------------------------------------------------

// GuideStorageArchive

// repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
inline int GuideStorageArchive::userdefinedguides_size() const {
  return userdefinedguides_.size();
}
inline void GuideStorageArchive::clear_userdefinedguides() {
  userdefinedguides_.Clear();
}
inline const ::TSD::UserDefinedGuideArchive& GuideStorageArchive::userdefinedguides(int index) const {
  return userdefinedguides_.Get(index);
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::mutable_userdefinedguides(int index) {
  return userdefinedguides_.Mutable(index);
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::add_userdefinedguides() {
  return userdefinedguides_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >&
GuideStorageArchive::userdefinedguides() const {
  return userdefinedguides_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >*
GuideStorageArchive::mutable_userdefinedguides() {
  return &userdefinedguides_;
}

// -------------------------------------------------------------------

// CanvasSelectionArchive

// repeated .TSP.Reference infos = 1;
inline int CanvasSelectionArchive::infos_size() const {
  return infos_.size();
}
inline void CanvasSelectionArchive::clear_infos() {
  infos_.Clear();
}
inline const ::TSP::Reference& CanvasSelectionArchive::infos(int index) const {
  return infos_.Get(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CanvasSelectionArchive::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CanvasSelectionArchive::mutable_infos() {
  return &infos_;
}

// optional .TSP.Reference container = 2;
inline bool CanvasSelectionArchive::has_container() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CanvasSelectionArchive::set_has_container() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CanvasSelectionArchive::clear_has_container() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CanvasSelectionArchive::clear_container() {
  if (container_ != NULL) container_->::TSP::Reference::Clear();
  clear_has_container();
}
inline const ::TSP::Reference& CanvasSelectionArchive::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::TSP::Reference;
  return container_;
}
inline ::TSP::Reference* CanvasSelectionArchive::release_container() {
  clear_has_container();
  ::TSP::Reference* temp = container_;
  container_ = NULL;
  return temp;
}
inline void CanvasSelectionArchive::set_allocated_container(::TSP::Reference* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// -------------------------------------------------------------------

// CommentStorageArchive

// optional string text = 1;
inline bool CommentStorageArchive::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentStorageArchive::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentStorageArchive::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentStorageArchive::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& CommentStorageArchive::text() const {
  return *text_;
}
inline void CommentStorageArchive::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void CommentStorageArchive::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void CommentStorageArchive::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommentStorageArchive::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* CommentStorageArchive::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommentStorageArchive::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Date creation_date = 2;
inline bool CommentStorageArchive::has_creation_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentStorageArchive::set_has_creation_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentStorageArchive::clear_has_creation_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentStorageArchive::clear_creation_date() {
  if (creation_date_ != NULL) creation_date_->::TSP::Date::Clear();
  clear_has_creation_date();
}
inline const ::TSP::Date& CommentStorageArchive::creation_date() const {
  return creation_date_ != NULL ? *creation_date_ : *default_instance_->creation_date_;
}
inline ::TSP::Date* CommentStorageArchive::mutable_creation_date() {
  set_has_creation_date();
  if (creation_date_ == NULL) creation_date_ = new ::TSP::Date;
  return creation_date_;
}
inline ::TSP::Date* CommentStorageArchive::release_creation_date() {
  clear_has_creation_date();
  ::TSP::Date* temp = creation_date_;
  creation_date_ = NULL;
  return temp;
}
inline void CommentStorageArchive::set_allocated_creation_date(::TSP::Date* creation_date) {
  delete creation_date_;
  creation_date_ = creation_date;
  if (creation_date) {
    set_has_creation_date();
  } else {
    clear_has_creation_date();
  }
}

// optional .TSP.Reference author = 3;
inline bool CommentStorageArchive::has_author() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommentStorageArchive::set_has_author() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommentStorageArchive::clear_has_author() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommentStorageArchive::clear_author() {
  if (author_ != NULL) author_->::TSP::Reference::Clear();
  clear_has_author();
}
inline const ::TSP::Reference& CommentStorageArchive::author() const {
  return author_ != NULL ? *author_ : *default_instance_->author_;
}
inline ::TSP::Reference* CommentStorageArchive::mutable_author() {
  set_has_author();
  if (author_ == NULL) author_ = new ::TSP::Reference;
  return author_;
}
inline ::TSP::Reference* CommentStorageArchive::release_author() {
  clear_has_author();
  ::TSP::Reference* temp = author_;
  author_ = NULL;
  return temp;
}
inline void CommentStorageArchive::set_allocated_author(::TSP::Reference* author) {
  delete author_;
  author_ = author;
  if (author) {
    set_has_author();
  } else {
    clear_has_author();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSD

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::PointPathSourceArchive_PointPathSourceType>() {
  return ::TSD::PointPathSourceArchive_PointPathSourceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType>() {
  return ::TSD::ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>() {
  return ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::EditableBezierPathSourceArchive_NodeType>() {
  return ::TSD::EditableBezierPathSourceArchive_NodeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GradientArchive_GradientType>() {
  return ::TSD::GradientArchive_GradientType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ImageFillArchive_ImageFillTechnique>() {
  return ::TSD::ImageFillArchive_ImageFillTechnique_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::StrokePatternArchive_StrokePatternType>() {
  return ::TSD::StrokePatternArchive_StrokePatternType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::StrokeArchive_LineCap>() {
  return ::TSD::StrokeArchive_LineCap_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ShadowArchive_ShadowType>() {
  return ::TSD::ShadowArchive_ShadowType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::MovieArchive_MovieLoopOption>() {
  return ::TSD::MovieArchive_MovieLoopOption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GuideArchive_GuideType>() {
  return ::TSD::GuideArchive_GuideType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::UserDefinedGuideArchive_GuideType>() {
  return ::TSD::UserDefinedGuideArchive_GuideType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::LineJoin>() {
  return ::TSD::LineJoin_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSDArchives_2eproto__INCLUDED
