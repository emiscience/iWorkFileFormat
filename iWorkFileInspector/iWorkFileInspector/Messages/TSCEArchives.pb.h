// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSCEArchives.proto

#ifndef PROTOBUF_TSCEArchives_2eproto__INCLUDED
#define PROTOBUF_TSCEArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TSCE {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSCEArchives_2eproto();
void protobuf_AssignDesc_TSCEArchives_2eproto();
void protobuf_ShutdownFile_TSCEArchives_2eproto();

class CFUUIDArchive;
class CellReferenceArchive;
class InternalCellReferenceArchive;
class RangeReferenceArchive;
class InternalRangeReferenceArchive;
class ReferenceArchive;
class EdgeArchive;
class EdgesArchive;
class CellRecordArchive;
class CellDependenciesArchive;
class VolatileDependenciesArchive;
class RangeBackDependencyArchive;
class RTreeInternalNodeContentsArchive;
class RTreeLeafNodeContentsArchive;
class RTreeNodeArchive;
class RTreeArchive;
class RangeDependenciesArchive;
class SpanningDependenciesArchive;
class SpanningDependenciesArchive_ReferringColumnToLocalCells;
class SpanningDependenciesArchive_ReferringColumnToRemoteCells;
class WholeOwnerDependenciesArchive;
class FormulaOwnerInfoArchive;
class OwnerIDMapArchive;
class OwnerIDMapArchive_OwnerIDMapArchiveEntry;
class DependencyTrackerArchive;
class NameTrackedReferencePair;
class NamesByTrackedReferenceArchive;
class NamedReferenceManagerArchive;
class CalculationEngineArchive;
class ASTNodeArrayArchive;
class ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive;
class ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive;
class ASTNodeArrayArchive_ASTColumnCoordinateArchive;
class ASTNodeArrayArchive_ASTRowCoordinateArchive;
class ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive;
class ASTNodeArrayArchive_ASTNodeArchive;
class FormulaTranslationFlagsArchive;
class FormulaArchive;
class FormatStructArchive;
class RangeCoordinateArchive;
class TectonicShiftArchive;
class RewriteSortMappingArchive;
class RangeMovedInfoArchive;
class TableResizedInfoArchive;
class CellMergeInfoArchive;
class FormulaRewriteSpecArchive;
class CellCoordinateFormulaPairArchive;
class CellCoordinateArchive;
class CellCoordinateVectorArchive;
class CellCoordinateObjectPairArchive;
class CellCoordinateObjectMapArchive;
class OwnerFormulaMapArchive;
class FormulaRewriteCommandArchive;
class NumberTrackedReferencePairArchive;
class NumberToTrackedReferenceMapArchive;
class TrackedReferencesRewriteCommandArchive;
class TrackedReferenceArchive;
class ReferenceTrackerArchive;
class BooleanCellValueArchive;
class DateCellValueArchive;
class NumberCellValueArchive;
class StringCellValueArchive;
class CellValueArchive;

enum ReferenceArchive_ReferenceType {
  ReferenceArchive_ReferenceType_CELL_REFERENCE = 1,
  ReferenceArchive_ReferenceType_RANGE_REFERENCE = 2,
  ReferenceArchive_ReferenceType_NAME_DEPENDENCY = 3
};
bool ReferenceArchive_ReferenceType_IsValid(int value);
const ReferenceArchive_ReferenceType ReferenceArchive_ReferenceType_ReferenceType_MIN = ReferenceArchive_ReferenceType_CELL_REFERENCE;
const ReferenceArchive_ReferenceType ReferenceArchive_ReferenceType_ReferenceType_MAX = ReferenceArchive_ReferenceType_NAME_DEPENDENCY;
const int ReferenceArchive_ReferenceType_ReferenceType_ARRAYSIZE = ReferenceArchive_ReferenceType_ReferenceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReferenceArchive_ReferenceType_descriptor();
inline const ::std::string& ReferenceArchive_ReferenceType_Name(ReferenceArchive_ReferenceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReferenceArchive_ReferenceType_descriptor(), value);
}
inline bool ReferenceArchive_ReferenceType_Parse(
    const ::std::string& name, ReferenceArchive_ReferenceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReferenceArchive_ReferenceType>(
    ReferenceArchive_ReferenceType_descriptor(), name, value);
}
enum SpanningDependenciesArchive_RangeContext {
  SpanningDependenciesArchive_RangeContext_DEFAULT = 0,
  SpanningDependenciesArchive_RangeContext_INCLUDE_HEADERS = 1
};
bool SpanningDependenciesArchive_RangeContext_IsValid(int value);
const SpanningDependenciesArchive_RangeContext SpanningDependenciesArchive_RangeContext_RangeContext_MIN = SpanningDependenciesArchive_RangeContext_DEFAULT;
const SpanningDependenciesArchive_RangeContext SpanningDependenciesArchive_RangeContext_RangeContext_MAX = SpanningDependenciesArchive_RangeContext_INCLUDE_HEADERS;
const int SpanningDependenciesArchive_RangeContext_RangeContext_ARRAYSIZE = SpanningDependenciesArchive_RangeContext_RangeContext_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpanningDependenciesArchive_RangeContext_descriptor();
inline const ::std::string& SpanningDependenciesArchive_RangeContext_Name(SpanningDependenciesArchive_RangeContext value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpanningDependenciesArchive_RangeContext_descriptor(), value);
}
inline bool SpanningDependenciesArchive_RangeContext_Parse(
    const ::std::string& name, SpanningDependenciesArchive_RangeContext* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpanningDependenciesArchive_RangeContext>(
    SpanningDependenciesArchive_RangeContext_descriptor(), name, value);
}
enum CalculationEngineArchive_ExcelImportDateMode {
  CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1900 = 1,
  CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1900_LEGACY = 2,
  CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1904_LEGACY = 3
};
bool CalculationEngineArchive_ExcelImportDateMode_IsValid(int value);
const CalculationEngineArchive_ExcelImportDateMode CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_MIN = CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1900;
const CalculationEngineArchive_ExcelImportDateMode CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_MAX = CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1904_LEGACY;
const int CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_ARRAYSIZE = CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CalculationEngineArchive_ExcelImportDateMode_descriptor();
inline const ::std::string& CalculationEngineArchive_ExcelImportDateMode_Name(CalculationEngineArchive_ExcelImportDateMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CalculationEngineArchive_ExcelImportDateMode_descriptor(), value);
}
inline bool CalculationEngineArchive_ExcelImportDateMode_Parse(
    const ::std::string& name, CalculationEngineArchive_ExcelImportDateMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CalculationEngineArchive_ExcelImportDateMode>(
    CalculationEngineArchive_ExcelImportDateMode_descriptor(), name, value);
}
enum ASTNodeArrayArchive_ASTNodeType {
  ASTNodeArrayArchive_ASTNodeType_ADDITION_NODE = 1,
  ASTNodeArrayArchive_ASTNodeType_SUBTRACTION_NODE = 2,
  ASTNodeArrayArchive_ASTNodeType_MULTIPLICATION_NODE = 3,
  ASTNodeArrayArchive_ASTNodeType_DIVISION_NODE = 4,
  ASTNodeArrayArchive_ASTNodeType_POWER_NODE = 5,
  ASTNodeArrayArchive_ASTNodeType_CONCATENATION_NODE = 6,
  ASTNodeArrayArchive_ASTNodeType_GREATER_THAN_NODE = 7,
  ASTNodeArrayArchive_ASTNodeType_GREATER_THAN_OR_EQUAL_TO_NODE = 8,
  ASTNodeArrayArchive_ASTNodeType_LESS_THAN_NODE = 9,
  ASTNodeArrayArchive_ASTNodeType_LESS_THAN_OR_EQUAL_TO_NODE = 10,
  ASTNodeArrayArchive_ASTNodeType_EQUAL_TO_NODE = 11,
  ASTNodeArrayArchive_ASTNodeType_NOT_EQUAL_TO_NODE = 12,
  ASTNodeArrayArchive_ASTNodeType_NEGATION_NODE = 13,
  ASTNodeArrayArchive_ASTNodeType_PLUS_SIGN_NODE = 14,
  ASTNodeArrayArchive_ASTNodeType_PERCENT_NODE = 15,
  ASTNodeArrayArchive_ASTNodeType_FUNCTION_NODE = 16,
  ASTNodeArrayArchive_ASTNodeType_NUMBER_NODE = 17,
  ASTNodeArrayArchive_ASTNodeType_BOOLEAN_NODE = 18,
  ASTNodeArrayArchive_ASTNodeType_STRING_NODE = 19,
  ASTNodeArrayArchive_ASTNodeType_DATE_NODE = 20,
  ASTNodeArrayArchive_ASTNodeType_DURATION_NODE = 21,
  ASTNodeArrayArchive_ASTNodeType_EMPTY_ARGUMENT_NODE = 22,
  ASTNodeArrayArchive_ASTNodeType_TOKEN_NODE = 23,
  ASTNodeArrayArchive_ASTNodeType_ARRAY_NODE = 24,
  ASTNodeArrayArchive_ASTNodeType_LIST_NODE = 25,
  ASTNodeArrayArchive_ASTNodeType_THUNK_NODE = 26,
  ASTNodeArrayArchive_ASTNodeType_LOCAL_CELL_REFERENCE_NODE = 27,
  ASTNodeArrayArchive_ASTNodeType_CROSS_TABLE_CELL_REFERENCE_NODE = 28,
  ASTNodeArrayArchive_ASTNodeType_COLON_NODE = 29,
  ASTNodeArrayArchive_ASTNodeType_REFERENCE_ERROR_NODE = 30,
  ASTNodeArrayArchive_ASTNodeType_UNKNOWN_FUNCTION_NODE = 31,
  ASTNodeArrayArchive_ASTNodeType_APPEND_WHITESPACE_NODE = 32,
  ASTNodeArrayArchive_ASTNodeType_PREPEND_WHITESPACE_NODE = 33,
  ASTNodeArrayArchive_ASTNodeType_BEGIN_THUNK_NODE = 34,
  ASTNodeArrayArchive_ASTNodeType_END_THUNK_NODE = 35,
  ASTNodeArrayArchive_ASTNodeType_CELL_REFERENCE_NODE = 36
};
bool ASTNodeArrayArchive_ASTNodeType_IsValid(int value);
const ASTNodeArrayArchive_ASTNodeType ASTNodeArrayArchive_ASTNodeType_ASTNodeType_MIN = ASTNodeArrayArchive_ASTNodeType_ADDITION_NODE;
const ASTNodeArrayArchive_ASTNodeType ASTNodeArrayArchive_ASTNodeType_ASTNodeType_MAX = ASTNodeArrayArchive_ASTNodeType_CELL_REFERENCE_NODE;
const int ASTNodeArrayArchive_ASTNodeType_ASTNodeType_ARRAYSIZE = ASTNodeArrayArchive_ASTNodeType_ASTNodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASTNodeArrayArchive_ASTNodeType_descriptor();
inline const ::std::string& ASTNodeArrayArchive_ASTNodeType_Name(ASTNodeArrayArchive_ASTNodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASTNodeArrayArchive_ASTNodeType_descriptor(), value);
}
inline bool ASTNodeArrayArchive_ASTNodeType_Parse(
    const ::std::string& name, ASTNodeArrayArchive_ASTNodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASTNodeArrayArchive_ASTNodeType>(
    ASTNodeArrayArchive_ASTNodeType_descriptor(), name, value);
}
enum FormulaRewriteSpecArchive_RewriteType {
  FormulaRewriteSpecArchive_RewriteType_TECTONIC_SHIFT = 1,
  FormulaRewriteSpecArchive_RewriteType_REMAP_WITH_SORT_MAPPING = 2,
  FormulaRewriteSpecArchive_RewriteType_MOVE_RANGE = 3,
  FormulaRewriteSpecArchive_RewriteType_DELETE_OWNER = 4,
  FormulaRewriteSpecArchive_RewriteType_TABLE_RESIZE = 5,
  FormulaRewriteSpecArchive_RewriteType_CELL_MERGE = 6
};
bool FormulaRewriteSpecArchive_RewriteType_IsValid(int value);
const FormulaRewriteSpecArchive_RewriteType FormulaRewriteSpecArchive_RewriteType_RewriteType_MIN = FormulaRewriteSpecArchive_RewriteType_TECTONIC_SHIFT;
const FormulaRewriteSpecArchive_RewriteType FormulaRewriteSpecArchive_RewriteType_RewriteType_MAX = FormulaRewriteSpecArchive_RewriteType_CELL_MERGE;
const int FormulaRewriteSpecArchive_RewriteType_RewriteType_ARRAYSIZE = FormulaRewriteSpecArchive_RewriteType_RewriteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FormulaRewriteSpecArchive_RewriteType_descriptor();
inline const ::std::string& FormulaRewriteSpecArchive_RewriteType_Name(FormulaRewriteSpecArchive_RewriteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FormulaRewriteSpecArchive_RewriteType_descriptor(), value);
}
inline bool FormulaRewriteSpecArchive_RewriteType_Parse(
    const ::std::string& name, FormulaRewriteSpecArchive_RewriteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FormulaRewriteSpecArchive_RewriteType>(
    FormulaRewriteSpecArchive_RewriteType_descriptor(), name, value);
}
enum CellValueArchive_CellValueType {
  CellValueArchive_CellValueType_NIL_TYPE = 1,
  CellValueArchive_CellValueType_BOOLEAN_TYPE = 2,
  CellValueArchive_CellValueType_DATE_TYPE = 3,
  CellValueArchive_CellValueType_NUMBER_TYPE = 4,
  CellValueArchive_CellValueType_STRING_TYPE = 5
};
bool CellValueArchive_CellValueType_IsValid(int value);
const CellValueArchive_CellValueType CellValueArchive_CellValueType_CellValueType_MIN = CellValueArchive_CellValueType_NIL_TYPE;
const CellValueArchive_CellValueType CellValueArchive_CellValueType_CellValueType_MAX = CellValueArchive_CellValueType_STRING_TYPE;
const int CellValueArchive_CellValueType_CellValueType_ARRAYSIZE = CellValueArchive_CellValueType_CellValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CellValueArchive_CellValueType_descriptor();
inline const ::std::string& CellValueArchive_CellValueType_Name(CellValueArchive_CellValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CellValueArchive_CellValueType_descriptor(), value);
}
inline bool CellValueArchive_CellValueType_Parse(
    const ::std::string& name, CellValueArchive_CellValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CellValueArchive_CellValueType>(
    CellValueArchive_CellValueType_descriptor(), name, value);
}
// ===================================================================

class CFUUIDArchive : public ::google::protobuf::Message {
 public:
  CFUUIDArchive();
  virtual ~CFUUIDArchive();

  CFUUIDArchive(const CFUUIDArchive& from);

  inline CFUUIDArchive& operator=(const CFUUIDArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CFUUIDArchive& default_instance();

  void Swap(CFUUIDArchive* other);

  // implements Message ----------------------------------------------

  CFUUIDArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CFUUIDArchive& from);
  void MergeFrom(const CFUUIDArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid_bytes = 1;
  inline bool has_uuid_bytes() const;
  inline void clear_uuid_bytes();
  static const int kUuidBytesFieldNumber = 1;
  inline const ::std::string& uuid_bytes() const;
  inline void set_uuid_bytes(const ::std::string& value);
  inline void set_uuid_bytes(const char* value);
  inline void set_uuid_bytes(const void* value, size_t size);
  inline ::std::string* mutable_uuid_bytes();
  inline ::std::string* release_uuid_bytes();
  inline void set_allocated_uuid_bytes(::std::string* uuid_bytes);

  // optional uint32 uuid_w0 = 2;
  inline bool has_uuid_w0() const;
  inline void clear_uuid_w0();
  static const int kUuidW0FieldNumber = 2;
  inline ::google::protobuf::uint32 uuid_w0() const;
  inline void set_uuid_w0(::google::protobuf::uint32 value);

  // optional uint32 uuid_w1 = 3;
  inline bool has_uuid_w1() const;
  inline void clear_uuid_w1();
  static const int kUuidW1FieldNumber = 3;
  inline ::google::protobuf::uint32 uuid_w1() const;
  inline void set_uuid_w1(::google::protobuf::uint32 value);

  // optional uint32 uuid_w2 = 4;
  inline bool has_uuid_w2() const;
  inline void clear_uuid_w2();
  static const int kUuidW2FieldNumber = 4;
  inline ::google::protobuf::uint32 uuid_w2() const;
  inline void set_uuid_w2(::google::protobuf::uint32 value);

  // optional uint32 uuid_w3 = 5;
  inline bool has_uuid_w3() const;
  inline void clear_uuid_w3();
  static const int kUuidW3FieldNumber = 5;
  inline ::google::protobuf::uint32 uuid_w3() const;
  inline void set_uuid_w3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.CFUUIDArchive)
 private:
  inline void set_has_uuid_bytes();
  inline void clear_has_uuid_bytes();
  inline void set_has_uuid_w0();
  inline void clear_has_uuid_w0();
  inline void set_has_uuid_w1();
  inline void clear_has_uuid_w1();
  inline void set_has_uuid_w2();
  inline void clear_has_uuid_w2();
  inline void set_has_uuid_w3();
  inline void clear_has_uuid_w3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_bytes_;
  ::google::protobuf::uint32 uuid_w0_;
  ::google::protobuf::uint32 uuid_w1_;
  ::google::protobuf::uint32 uuid_w2_;
  ::google::protobuf::uint32 uuid_w3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CFUUIDArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellReferenceArchive : public ::google::protobuf::Message {
 public:
  CellReferenceArchive();
  virtual ~CellReferenceArchive();

  CellReferenceArchive(const CellReferenceArchive& from);

  inline CellReferenceArchive& operator=(const CellReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellReferenceArchive& default_instance();

  void Swap(CellReferenceArchive* other);

  // implements Message ----------------------------------------------

  CellReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellReferenceArchive& from);
  void MergeFrom(const CellReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // required uint32 row = 2;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 2;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // required .TSCE.CFUUIDArchive table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // @@protoc_insertion_point(class_scope:TSCE.CellReferenceArchive)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 column_;
  ::google::protobuf::uint32 row_;
  ::TSCE::CFUUIDArchive* table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class InternalCellReferenceArchive : public ::google::protobuf::Message {
 public:
  InternalCellReferenceArchive();
  virtual ~InternalCellReferenceArchive();

  InternalCellReferenceArchive(const InternalCellReferenceArchive& from);

  inline InternalCellReferenceArchive& operator=(const InternalCellReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalCellReferenceArchive& default_instance();

  void Swap(InternalCellReferenceArchive* other);

  // implements Message ----------------------------------------------

  InternalCellReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalCellReferenceArchive& from);
  void MergeFrom(const InternalCellReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CellCoordinateArchive coordinate = 1;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 1;
  inline const ::TSCE::CellCoordinateArchive& coordinate() const;
  inline ::TSCE::CellCoordinateArchive* mutable_coordinate();
  inline ::TSCE::CellCoordinateArchive* release_coordinate();
  inline void set_allocated_coordinate(::TSCE::CellCoordinateArchive* coordinate);

  // required uint32 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 owner_id() const;
  inline void set_owner_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.InternalCellReferenceArchive)
 private:
  inline void set_has_coordinate();
  inline void clear_has_coordinate();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CellCoordinateArchive* coordinate_;
  ::google::protobuf::uint32 owner_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static InternalCellReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class RangeReferenceArchive : public ::google::protobuf::Message {
 public:
  RangeReferenceArchive();
  virtual ~RangeReferenceArchive();

  RangeReferenceArchive(const RangeReferenceArchive& from);

  inline RangeReferenceArchive& operator=(const RangeReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeReferenceArchive& default_instance();

  void Swap(RangeReferenceArchive* other);

  // implements Message ----------------------------------------------

  RangeReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeReferenceArchive& from);
  void MergeFrom(const RangeReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // required uint32 top_left_column = 2;
  inline bool has_top_left_column() const;
  inline void clear_top_left_column();
  static const int kTopLeftColumnFieldNumber = 2;
  inline ::google::protobuf::uint32 top_left_column() const;
  inline void set_top_left_column(::google::protobuf::uint32 value);

  // required uint32 top_left_row = 3;
  inline bool has_top_left_row() const;
  inline void clear_top_left_row();
  static const int kTopLeftRowFieldNumber = 3;
  inline ::google::protobuf::uint32 top_left_row() const;
  inline void set_top_left_row(::google::protobuf::uint32 value);

  // required uint32 bottom_right_column = 4;
  inline bool has_bottom_right_column() const;
  inline void clear_bottom_right_column();
  static const int kBottomRightColumnFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom_right_column() const;
  inline void set_bottom_right_column(::google::protobuf::uint32 value);

  // required uint32 bottom_right_row = 5;
  inline bool has_bottom_right_row() const;
  inline void clear_bottom_right_row();
  static const int kBottomRightRowFieldNumber = 5;
  inline ::google::protobuf::uint32 bottom_right_row() const;
  inline void set_bottom_right_row(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.RangeReferenceArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_top_left_column();
  inline void clear_has_top_left_column();
  inline void set_has_top_left_row();
  inline void clear_has_top_left_row();
  inline void set_has_bottom_right_column();
  inline void clear_has_bottom_right_column();
  inline void set_has_bottom_right_row();
  inline void clear_has_bottom_right_row();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::google::protobuf::uint32 top_left_column_;
  ::google::protobuf::uint32 top_left_row_;
  ::google::protobuf::uint32 bottom_right_column_;
  ::google::protobuf::uint32 bottom_right_row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RangeReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class InternalRangeReferenceArchive : public ::google::protobuf::Message {
 public:
  InternalRangeReferenceArchive();
  virtual ~InternalRangeReferenceArchive();

  InternalRangeReferenceArchive(const InternalRangeReferenceArchive& from);

  inline InternalRangeReferenceArchive& operator=(const InternalRangeReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRangeReferenceArchive& default_instance();

  void Swap(InternalRangeReferenceArchive* other);

  // implements Message ----------------------------------------------

  InternalRangeReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRangeReferenceArchive& from);
  void MergeFrom(const InternalRangeReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 owner_id = 1;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 owner_id() const;
  inline void set_owner_id(::google::protobuf::uint32 value);

  // required .TSCE.RangeCoordinateArchive range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline const ::TSCE::RangeCoordinateArchive& range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_range();
  inline ::TSCE::RangeCoordinateArchive* release_range();
  inline void set_allocated_range(::TSCE::RangeCoordinateArchive* range);

  // @@protoc_insertion_point(class_scope:TSCE.InternalRangeReferenceArchive)
 private:
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::RangeCoordinateArchive* range_;
  ::google::protobuf::uint32 owner_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static InternalRangeReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceArchive : public ::google::protobuf::Message {
 public:
  ReferenceArchive();
  virtual ~ReferenceArchive();

  ReferenceArchive(const ReferenceArchive& from);

  inline ReferenceArchive& operator=(const ReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceArchive& default_instance();

  void Swap(ReferenceArchive* other);

  // implements Message ----------------------------------------------

  ReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceArchive& from);
  void MergeFrom(const ReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReferenceArchive_ReferenceType ReferenceType;
  static const ReferenceType CELL_REFERENCE = ReferenceArchive_ReferenceType_CELL_REFERENCE;
  static const ReferenceType RANGE_REFERENCE = ReferenceArchive_ReferenceType_RANGE_REFERENCE;
  static const ReferenceType NAME_DEPENDENCY = ReferenceArchive_ReferenceType_NAME_DEPENDENCY;
  static inline bool ReferenceType_IsValid(int value) {
    return ReferenceArchive_ReferenceType_IsValid(value);
  }
  static const ReferenceType ReferenceType_MIN =
    ReferenceArchive_ReferenceType_ReferenceType_MIN;
  static const ReferenceType ReferenceType_MAX =
    ReferenceArchive_ReferenceType_ReferenceType_MAX;
  static const int ReferenceType_ARRAYSIZE =
    ReferenceArchive_ReferenceType_ReferenceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReferenceType_descriptor() {
    return ReferenceArchive_ReferenceType_descriptor();
  }
  static inline const ::std::string& ReferenceType_Name(ReferenceType value) {
    return ReferenceArchive_ReferenceType_Name(value);
  }
  static inline bool ReferenceType_Parse(const ::std::string& name,
      ReferenceType* value) {
    return ReferenceArchive_ReferenceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSCE.ReferenceArchive.ReferenceType reference_type = 1;
  inline bool has_reference_type() const;
  inline void clear_reference_type();
  static const int kReferenceTypeFieldNumber = 1;
  inline ::TSCE::ReferenceArchive_ReferenceType reference_type() const;
  inline void set_reference_type(::TSCE::ReferenceArchive_ReferenceType value);

  // optional .TSCE.CellReferenceArchive cell_reference = 2;
  inline bool has_cell_reference() const;
  inline void clear_cell_reference();
  static const int kCellReferenceFieldNumber = 2;
  inline const ::TSCE::CellReferenceArchive& cell_reference() const;
  inline ::TSCE::CellReferenceArchive* mutable_cell_reference();
  inline ::TSCE::CellReferenceArchive* release_cell_reference();
  inline void set_allocated_cell_reference(::TSCE::CellReferenceArchive* cell_reference);

  // optional .TSCE.RangeReferenceArchive range_reference = 3;
  inline bool has_range_reference() const;
  inline void clear_range_reference();
  static const int kRangeReferenceFieldNumber = 3;
  inline const ::TSCE::RangeReferenceArchive& range_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_range_reference();
  inline ::TSCE::RangeReferenceArchive* release_range_reference();
  inline void set_allocated_range_reference(::TSCE::RangeReferenceArchive* range_reference);

  // @@protoc_insertion_point(class_scope:TSCE.ReferenceArchive)
 private:
  inline void set_has_reference_type();
  inline void clear_has_reference_type();
  inline void set_has_cell_reference();
  inline void clear_has_cell_reference();
  inline void set_has_range_reference();
  inline void clear_has_range_reference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CellReferenceArchive* cell_reference_;
  ::TSCE::RangeReferenceArchive* range_reference_;
  int reference_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class EdgeArchive : public ::google::protobuf::Message {
 public:
  EdgeArchive();
  virtual ~EdgeArchive();

  EdgeArchive(const EdgeArchive& from);

  inline EdgeArchive& operator=(const EdgeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeArchive& default_instance();

  void Swap(EdgeArchive* other);

  // implements Message ----------------------------------------------

  EdgeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgeArchive& from);
  void MergeFrom(const EdgeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // required uint32 row = 2;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 2;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // required bool is_precedent = 3;
  inline bool has_is_precedent() const;
  inline void clear_is_precedent();
  static const int kIsPrecedentFieldNumber = 3;
  inline bool is_precedent() const;
  inline void set_is_precedent(bool value);

  // optional .TSCE.CFUUIDArchive owner_id = 4;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 4;
  inline const ::TSCE::CFUUIDArchive& owner_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_owner_id();
  inline ::TSCE::CFUUIDArchive* release_owner_id();
  inline void set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id);

  // @@protoc_insertion_point(class_scope:TSCE.EdgeArchive)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_is_precedent();
  inline void clear_has_is_precedent();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 column_;
  ::google::protobuf::uint32 row_;
  ::TSCE::CFUUIDArchive* owner_id_;
  bool is_precedent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static EdgeArchive* default_instance_;
};
// -------------------------------------------------------------------

class EdgesArchive : public ::google::protobuf::Message {
 public:
  EdgesArchive();
  virtual ~EdgesArchive();

  EdgesArchive(const EdgesArchive& from);

  inline EdgesArchive& operator=(const EdgesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgesArchive& default_instance();

  void Swap(EdgesArchive* other);

  // implements Message ----------------------------------------------

  EdgesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgesArchive& from);
  void MergeFrom(const EdgesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 packed_edge_without_owner = 9;
  inline int packed_edge_without_owner_size() const;
  inline void clear_packed_edge_without_owner();
  static const int kPackedEdgeWithoutOwnerFieldNumber = 9;
  inline ::google::protobuf::uint32 packed_edge_without_owner(int index) const;
  inline void set_packed_edge_without_owner(int index, ::google::protobuf::uint32 value);
  inline void add_packed_edge_without_owner(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      packed_edge_without_owner() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_packed_edge_without_owner();

  // repeated uint32 packed_edge_with_owner = 10;
  inline int packed_edge_with_owner_size() const;
  inline void clear_packed_edge_with_owner();
  static const int kPackedEdgeWithOwnerFieldNumber = 10;
  inline ::google::protobuf::uint32 packed_edge_with_owner(int index) const;
  inline void set_packed_edge_with_owner(int index, ::google::protobuf::uint32 value);
  inline void add_packed_edge_with_owner(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      packed_edge_with_owner() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_packed_edge_with_owner();

  // repeated .TSCE.CFUUIDArchive owner_id_for_edge = 11;
  inline int owner_id_for_edge_size() const;
  inline void clear_owner_id_for_edge();
  static const int kOwnerIdForEdgeFieldNumber = 11;
  inline const ::TSCE::CFUUIDArchive& owner_id_for_edge(int index) const;
  inline ::TSCE::CFUUIDArchive* mutable_owner_id_for_edge(int index);
  inline ::TSCE::CFUUIDArchive* add_owner_id_for_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CFUUIDArchive >&
      owner_id_for_edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CFUUIDArchive >*
      mutable_owner_id_for_edge();

  // repeated uint32 internal_owner_id_for_edge = 12;
  inline int internal_owner_id_for_edge_size() const;
  inline void clear_internal_owner_id_for_edge();
  static const int kInternalOwnerIdForEdgeFieldNumber = 12;
  inline ::google::protobuf::uint32 internal_owner_id_for_edge(int index) const;
  inline void set_internal_owner_id_for_edge(int index, ::google::protobuf::uint32 value);
  inline void add_internal_owner_id_for_edge(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      internal_owner_id_for_edge() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_internal_owner_id_for_edge();

  // @@protoc_insertion_point(class_scope:TSCE.EdgesArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > packed_edge_without_owner_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > packed_edge_with_owner_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CFUUIDArchive > owner_id_for_edge_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > internal_owner_id_for_edge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static EdgesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellRecordArchive : public ::google::protobuf::Message {
 public:
  CellRecordArchive();
  virtual ~CellRecordArchive();

  CellRecordArchive(const CellRecordArchive& from);

  inline CellRecordArchive& operator=(const CellRecordArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellRecordArchive& default_instance();

  void Swap(CellRecordArchive* other);

  // implements Message ----------------------------------------------

  CellRecordArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellRecordArchive& from);
  void MergeFrom(const CellRecordArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // required uint32 row = 2;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 2;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // optional uint32 dirty_self_plus_precedents_count = 3 [default = 0];
  inline bool has_dirty_self_plus_precedents_count() const;
  inline void clear_dirty_self_plus_precedents_count();
  static const int kDirtySelfPlusPrecedentsCountFieldNumber = 3;
  inline ::google::protobuf::uint32 dirty_self_plus_precedents_count() const;
  inline void set_dirty_self_plus_precedents_count(::google::protobuf::uint32 value);

  // optional bool is_in_a_cycle = 4 [default = false];
  inline bool has_is_in_a_cycle() const;
  inline void clear_is_in_a_cycle();
  static const int kIsInACycleFieldNumber = 4;
  inline bool is_in_a_cycle() const;
  inline void set_is_in_a_cycle(bool value);

  // repeated .TSCE.EdgeArchive edge = 5 [deprecated = true];
  inline int edge_size() const PROTOBUF_DEPRECATED;
  inline void clear_edge() PROTOBUF_DEPRECATED;
  static const int kEdgeFieldNumber = 5;
  inline const ::TSCE::EdgeArchive& edge(int index) const PROTOBUF_DEPRECATED;
  inline ::TSCE::EdgeArchive* mutable_edge(int index) PROTOBUF_DEPRECATED;
  inline ::TSCE::EdgeArchive* add_edge() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::EdgeArchive >&
      edge() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::EdgeArchive >*
      mutable_edge() PROTOBUF_DEPRECATED;

  // optional bool contains_a_formula = 6 [default = true];
  inline bool has_contains_a_formula() const;
  inline void clear_contains_a_formula();
  static const int kContainsAFormulaFieldNumber = 6;
  inline bool contains_a_formula() const;
  inline void set_contains_a_formula(bool value);

  // optional bool has_calculated_precedents = 7 [default = false];
  inline bool has_has_calculated_precedents() const;
  inline void clear_has_calculated_precedents();
  static const int kHasCalculatedPrecedentsFieldNumber = 7;
  inline bool has_calculated_precedents() const;
  inline void set_has_calculated_precedents(bool value);

  // optional bool calculate_precedents_on_next_recalc = 8 [default = false, deprecated = true];
  inline bool has_calculate_precedents_on_next_recalc() const PROTOBUF_DEPRECATED;
  inline void clear_calculate_precedents_on_next_recalc() PROTOBUF_DEPRECATED;
  static const int kCalculatePrecedentsOnNextRecalcFieldNumber = 8;
  inline bool calculate_precedents_on_next_recalc() const PROTOBUF_DEPRECATED;
  inline void set_calculate_precedents_on_next_recalc(bool value) PROTOBUF_DEPRECATED;

  // optional bool translate_for_excel_import_on_next_recalc = 10 [default = false];
  inline bool has_translate_for_excel_import_on_next_recalc() const;
  inline void clear_translate_for_excel_import_on_next_recalc();
  static const int kTranslateForExcelImportOnNextRecalcFieldNumber = 10;
  inline bool translate_for_excel_import_on_next_recalc() const;
  inline void set_translate_for_excel_import_on_next_recalc(bool value);

  // optional .TSCE.EdgesArchive edges = 9;
  inline bool has_edges() const;
  inline void clear_edges();
  static const int kEdgesFieldNumber = 9;
  inline const ::TSCE::EdgesArchive& edges() const;
  inline ::TSCE::EdgesArchive* mutable_edges();
  inline ::TSCE::EdgesArchive* release_edges();
  inline void set_allocated_edges(::TSCE::EdgesArchive* edges);

  // @@protoc_insertion_point(class_scope:TSCE.CellRecordArchive)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_dirty_self_plus_precedents_count();
  inline void clear_has_dirty_self_plus_precedents_count();
  inline void set_has_is_in_a_cycle();
  inline void clear_has_is_in_a_cycle();
  inline void set_has_contains_a_formula();
  inline void clear_has_contains_a_formula();
  inline void set_has_has_calculated_precedents();
  inline void clear_has_has_calculated_precedents();
  inline void set_has_calculate_precedents_on_next_recalc();
  inline void clear_has_calculate_precedents_on_next_recalc();
  inline void set_has_translate_for_excel_import_on_next_recalc();
  inline void clear_has_translate_for_excel_import_on_next_recalc();
  inline void set_has_edges();
  inline void clear_has_edges();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 column_;
  ::google::protobuf::uint32 row_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::EdgeArchive > edge_;
  ::google::protobuf::uint32 dirty_self_plus_precedents_count_;
  bool is_in_a_cycle_;
  bool contains_a_formula_;
  bool has_calculated_precedents_;
  bool calculate_precedents_on_next_recalc_;
  ::TSCE::EdgesArchive* edges_;
  bool translate_for_excel_import_on_next_recalc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellRecordArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellDependenciesArchive : public ::google::protobuf::Message {
 public:
  CellDependenciesArchive();
  virtual ~CellDependenciesArchive();

  CellDependenciesArchive(const CellDependenciesArchive& from);

  inline CellDependenciesArchive& operator=(const CellDependenciesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellDependenciesArchive& default_instance();

  void Swap(CellDependenciesArchive* other);

  // implements Message ----------------------------------------------

  CellDependenciesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellDependenciesArchive& from);
  void MergeFrom(const CellDependenciesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.CellRecordArchive cell_record = 1;
  inline int cell_record_size() const;
  inline void clear_cell_record();
  static const int kCellRecordFieldNumber = 1;
  inline const ::TSCE::CellRecordArchive& cell_record(int index) const;
  inline ::TSCE::CellRecordArchive* mutable_cell_record(int index);
  inline ::TSCE::CellRecordArchive* add_cell_record();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellRecordArchive >&
      cell_record() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellRecordArchive >*
      mutable_cell_record();

  // optional uint32 num_dirty_cells = 2;
  inline bool has_num_dirty_cells() const;
  inline void clear_num_dirty_cells();
  static const int kNumDirtyCellsFieldNumber = 2;
  inline ::google::protobuf::uint32 num_dirty_cells() const;
  inline void set_num_dirty_cells(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.CellDependenciesArchive)
 private:
  inline void set_has_num_dirty_cells();
  inline void clear_has_num_dirty_cells();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::CellRecordArchive > cell_record_;
  ::google::protobuf::uint32 num_dirty_cells_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellDependenciesArchive* default_instance_;
};
// -------------------------------------------------------------------

class VolatileDependenciesArchive : public ::google::protobuf::Message {
 public:
  VolatileDependenciesArchive();
  virtual ~VolatileDependenciesArchive();

  VolatileDependenciesArchive(const VolatileDependenciesArchive& from);

  inline VolatileDependenciesArchive& operator=(const VolatileDependenciesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VolatileDependenciesArchive& default_instance();

  void Swap(VolatileDependenciesArchive* other);

  // implements Message ----------------------------------------------

  VolatileDependenciesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VolatileDependenciesArchive& from);
  void MergeFrom(const VolatileDependenciesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 volatile_time_cell_column = 1;
  inline int volatile_time_cell_column_size() const;
  inline void clear_volatile_time_cell_column();
  static const int kVolatileTimeCellColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 volatile_time_cell_column(int index) const;
  inline void set_volatile_time_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_time_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_time_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_time_cell_column();

  // repeated uint32 volatile_time_cell_row = 2;
  inline int volatile_time_cell_row_size() const;
  inline void clear_volatile_time_cell_row();
  static const int kVolatileTimeCellRowFieldNumber = 2;
  inline ::google::protobuf::uint32 volatile_time_cell_row(int index) const;
  inline void set_volatile_time_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_time_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_time_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_time_cell_row();

  // repeated uint32 volatile_random_cell_column = 3;
  inline int volatile_random_cell_column_size() const;
  inline void clear_volatile_random_cell_column();
  static const int kVolatileRandomCellColumnFieldNumber = 3;
  inline ::google::protobuf::uint32 volatile_random_cell_column(int index) const;
  inline void set_volatile_random_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_random_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_random_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_random_cell_column();

  // repeated uint32 volatile_random_cell_row = 4;
  inline int volatile_random_cell_row_size() const;
  inline void clear_volatile_random_cell_row();
  static const int kVolatileRandomCellRowFieldNumber = 4;
  inline ::google::protobuf::uint32 volatile_random_cell_row(int index) const;
  inline void set_volatile_random_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_random_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_random_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_random_cell_row();

  // repeated uint32 volatile_locale_cell_column = 15;
  inline int volatile_locale_cell_column_size() const;
  inline void clear_volatile_locale_cell_column();
  static const int kVolatileLocaleCellColumnFieldNumber = 15;
  inline ::google::protobuf::uint32 volatile_locale_cell_column(int index) const;
  inline void set_volatile_locale_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_locale_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_locale_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_locale_cell_column();

  // repeated uint32 volatile_locale_cell_row = 16;
  inline int volatile_locale_cell_row_size() const;
  inline void clear_volatile_locale_cell_row();
  static const int kVolatileLocaleCellRowFieldNumber = 16;
  inline ::google::protobuf::uint32 volatile_locale_cell_row(int index) const;
  inline void set_volatile_locale_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_locale_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_locale_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_locale_cell_row();

  // repeated uint32 volatile_location_cell_column = 5;
  inline int volatile_location_cell_column_size() const;
  inline void clear_volatile_location_cell_column();
  static const int kVolatileLocationCellColumnFieldNumber = 5;
  inline ::google::protobuf::uint32 volatile_location_cell_column(int index) const;
  inline void set_volatile_location_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_location_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_location_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_location_cell_column();

  // repeated uint32 volatile_location_cell_row = 6;
  inline int volatile_location_cell_row_size() const;
  inline void clear_volatile_location_cell_row();
  static const int kVolatileLocationCellRowFieldNumber = 6;
  inline ::google::protobuf::uint32 volatile_location_cell_row(int index) const;
  inline void set_volatile_location_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_location_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_location_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_location_cell_row();

  // repeated uint32 volatile_compass_cell_column = 7;
  inline int volatile_compass_cell_column_size() const;
  inline void clear_volatile_compass_cell_column();
  static const int kVolatileCompassCellColumnFieldNumber = 7;
  inline ::google::protobuf::uint32 volatile_compass_cell_column(int index) const;
  inline void set_volatile_compass_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_compass_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_compass_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_compass_cell_column();

  // repeated uint32 volatile_compass_cell_row = 8;
  inline int volatile_compass_cell_row_size() const;
  inline void clear_volatile_compass_cell_row();
  static const int kVolatileCompassCellRowFieldNumber = 8;
  inline ::google::protobuf::uint32 volatile_compass_cell_row(int index) const;
  inline void set_volatile_compass_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_compass_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_compass_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_compass_cell_row();

  // repeated uint32 volatile_sheet_table_name_cell_column = 17;
  inline int volatile_sheet_table_name_cell_column_size() const;
  inline void clear_volatile_sheet_table_name_cell_column();
  static const int kVolatileSheetTableNameCellColumnFieldNumber = 17;
  inline ::google::protobuf::uint32 volatile_sheet_table_name_cell_column(int index) const;
  inline void set_volatile_sheet_table_name_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_sheet_table_name_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_sheet_table_name_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_sheet_table_name_cell_column();

  // repeated uint32 volatile_sheet_table_name_cell_row = 18;
  inline int volatile_sheet_table_name_cell_row_size() const;
  inline void clear_volatile_sheet_table_name_cell_row();
  static const int kVolatileSheetTableNameCellRowFieldNumber = 18;
  inline ::google::protobuf::uint32 volatile_sheet_table_name_cell_row(int index) const;
  inline void set_volatile_sheet_table_name_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_volatile_sheet_table_name_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      volatile_sheet_table_name_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_volatile_sheet_table_name_cell_row();

  // repeated uint32 calculated_dependency_cell_column = 9;
  inline int calculated_dependency_cell_column_size() const;
  inline void clear_calculated_dependency_cell_column();
  static const int kCalculatedDependencyCellColumnFieldNumber = 9;
  inline ::google::protobuf::uint32 calculated_dependency_cell_column(int index) const;
  inline void set_calculated_dependency_cell_column(int index, ::google::protobuf::uint32 value);
  inline void add_calculated_dependency_cell_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      calculated_dependency_cell_column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_calculated_dependency_cell_column();

  // repeated uint32 calculated_dependency_cell_row = 10;
  inline int calculated_dependency_cell_row_size() const;
  inline void clear_calculated_dependency_cell_row();
  static const int kCalculatedDependencyCellRowFieldNumber = 10;
  inline ::google::protobuf::uint32 calculated_dependency_cell_row(int index) const;
  inline void set_calculated_dependency_cell_row(int index, ::google::protobuf::uint32 value);
  inline void add_calculated_dependency_cell_row(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      calculated_dependency_cell_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_calculated_dependency_cell_row();

  // repeated .TSCE.CellReferenceArchive volatile_geometry_cell_reference = 13;
  inline int volatile_geometry_cell_reference_size() const;
  inline void clear_volatile_geometry_cell_reference();
  static const int kVolatileGeometryCellReferenceFieldNumber = 13;
  inline const ::TSCE::CellReferenceArchive& volatile_geometry_cell_reference(int index) const;
  inline ::TSCE::CellReferenceArchive* mutable_volatile_geometry_cell_reference(int index);
  inline ::TSCE::CellReferenceArchive* add_volatile_geometry_cell_reference();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >&
      volatile_geometry_cell_reference() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >*
      mutable_volatile_geometry_cell_reference();

  // repeated .TSCE.CellCoordinateArchive volatile_geometry_cell = 11;
  inline int volatile_geometry_cell_size() const;
  inline void clear_volatile_geometry_cell();
  static const int kVolatileGeometryCellFieldNumber = 11;
  inline const ::TSCE::CellCoordinateArchive& volatile_geometry_cell(int index) const;
  inline ::TSCE::CellCoordinateArchive* mutable_volatile_geometry_cell(int index);
  inline ::TSCE::CellCoordinateArchive* add_volatile_geometry_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >&
      volatile_geometry_cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >*
      mutable_volatile_geometry_cell();

  // @@protoc_insertion_point(class_scope:TSCE.VolatileDependenciesArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_time_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_time_cell_row_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_random_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_random_cell_row_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_locale_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_locale_cell_row_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_location_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_location_cell_row_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_compass_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_compass_cell_row_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_sheet_table_name_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > volatile_sheet_table_name_cell_row_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > calculated_dependency_cell_column_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > calculated_dependency_cell_row_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive > volatile_geometry_cell_reference_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive > volatile_geometry_cell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static VolatileDependenciesArchive* default_instance_;
};
// -------------------------------------------------------------------

class RangeBackDependencyArchive : public ::google::protobuf::Message {
 public:
  RangeBackDependencyArchive();
  virtual ~RangeBackDependencyArchive();

  RangeBackDependencyArchive(const RangeBackDependencyArchive& from);

  inline RangeBackDependencyArchive& operator=(const RangeBackDependencyArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeBackDependencyArchive& default_instance();

  void Swap(RangeBackDependencyArchive* other);

  // implements Message ----------------------------------------------

  RangeBackDependencyArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeBackDependencyArchive& from);
  void MergeFrom(const RangeBackDependencyArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cell_coord_row = 1;
  inline bool has_cell_coord_row() const;
  inline void clear_cell_coord_row();
  static const int kCellCoordRowFieldNumber = 1;
  inline ::google::protobuf::uint32 cell_coord_row() const;
  inline void set_cell_coord_row(::google::protobuf::uint32 value);

  // required uint32 cell_coord_column = 2;
  inline bool has_cell_coord_column() const;
  inline void clear_cell_coord_column();
  static const int kCellCoordColumnFieldNumber = 2;
  inline ::google::protobuf::uint32 cell_coord_column() const;
  inline void set_cell_coord_column(::google::protobuf::uint32 value);

  // optional .TSCE.RangeReferenceArchive range_reference = 3;
  inline bool has_range_reference() const;
  inline void clear_range_reference();
  static const int kRangeReferenceFieldNumber = 3;
  inline const ::TSCE::RangeReferenceArchive& range_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_range_reference();
  inline ::TSCE::RangeReferenceArchive* release_range_reference();
  inline void set_allocated_range_reference(::TSCE::RangeReferenceArchive* range_reference);

  // optional .TSCE.InternalRangeReferenceArchive internal_range_reference = 4;
  inline bool has_internal_range_reference() const;
  inline void clear_internal_range_reference();
  static const int kInternalRangeReferenceFieldNumber = 4;
  inline const ::TSCE::InternalRangeReferenceArchive& internal_range_reference() const;
  inline ::TSCE::InternalRangeReferenceArchive* mutable_internal_range_reference();
  inline ::TSCE::InternalRangeReferenceArchive* release_internal_range_reference();
  inline void set_allocated_internal_range_reference(::TSCE::InternalRangeReferenceArchive* internal_range_reference);

  // @@protoc_insertion_point(class_scope:TSCE.RangeBackDependencyArchive)
 private:
  inline void set_has_cell_coord_row();
  inline void clear_has_cell_coord_row();
  inline void set_has_cell_coord_column();
  inline void clear_has_cell_coord_column();
  inline void set_has_range_reference();
  inline void clear_has_range_reference();
  inline void set_has_internal_range_reference();
  inline void clear_has_internal_range_reference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cell_coord_row_;
  ::google::protobuf::uint32 cell_coord_column_;
  ::TSCE::RangeReferenceArchive* range_reference_;
  ::TSCE::InternalRangeReferenceArchive* internal_range_reference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RangeBackDependencyArchive* default_instance_;
};
// -------------------------------------------------------------------

class RTreeInternalNodeContentsArchive : public ::google::protobuf::Message {
 public:
  RTreeInternalNodeContentsArchive();
  virtual ~RTreeInternalNodeContentsArchive();

  RTreeInternalNodeContentsArchive(const RTreeInternalNodeContentsArchive& from);

  inline RTreeInternalNodeContentsArchive& operator=(const RTreeInternalNodeContentsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RTreeInternalNodeContentsArchive& default_instance();

  void Swap(RTreeInternalNodeContentsArchive* other);

  // implements Message ----------------------------------------------

  RTreeInternalNodeContentsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RTreeInternalNodeContentsArchive& from);
  void MergeFrom(const RTreeInternalNodeContentsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 min = 1;
  inline int min_size() const;
  inline void clear_min();
  static const int kMinFieldNumber = 1;
  inline ::google::protobuf::uint32 min(int index) const;
  inline void set_min(int index, ::google::protobuf::uint32 value);
  inline void add_min(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      min() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_min();

  // repeated uint32 max = 2;
  inline int max_size() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline ::google::protobuf::uint32 max(int index) const;
  inline void set_max(int index, ::google::protobuf::uint32 value);
  inline void add_max(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      max() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_max();

  // required .TSCE.RTreeNodeArchive child = 3;
  inline bool has_child() const;
  inline void clear_child();
  static const int kChildFieldNumber = 3;
  inline const ::TSCE::RTreeNodeArchive& child() const;
  inline ::TSCE::RTreeNodeArchive* mutable_child();
  inline ::TSCE::RTreeNodeArchive* release_child();
  inline void set_allocated_child(::TSCE::RTreeNodeArchive* child);

  // @@protoc_insertion_point(class_scope:TSCE.RTreeInternalNodeContentsArchive)
 private:
  inline void set_has_child();
  inline void clear_has_child();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > min_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > max_;
  ::TSCE::RTreeNodeArchive* child_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RTreeInternalNodeContentsArchive* default_instance_;
};
// -------------------------------------------------------------------

class RTreeLeafNodeContentsArchive : public ::google::protobuf::Message {
 public:
  RTreeLeafNodeContentsArchive();
  virtual ~RTreeLeafNodeContentsArchive();

  RTreeLeafNodeContentsArchive(const RTreeLeafNodeContentsArchive& from);

  inline RTreeLeafNodeContentsArchive& operator=(const RTreeLeafNodeContentsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RTreeLeafNodeContentsArchive& default_instance();

  void Swap(RTreeLeafNodeContentsArchive* other);

  // implements Message ----------------------------------------------

  RTreeLeafNodeContentsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RTreeLeafNodeContentsArchive& from);
  void MergeFrom(const RTreeLeafNodeContentsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 min = 1;
  inline int min_size() const;
  inline void clear_min();
  static const int kMinFieldNumber = 1;
  inline ::google::protobuf::uint32 min(int index) const;
  inline void set_min(int index, ::google::protobuf::uint32 value);
  inline void add_min(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      min() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_min();

  // repeated uint32 max = 2;
  inline int max_size() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline ::google::protobuf::uint32 max(int index) const;
  inline void set_max(int index, ::google::protobuf::uint32 value);
  inline void add_max(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      max() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_max();

  // required .TSCE.CellReferenceArchive cell_reference = 3;
  inline bool has_cell_reference() const;
  inline void clear_cell_reference();
  static const int kCellReferenceFieldNumber = 3;
  inline const ::TSCE::CellReferenceArchive& cell_reference() const;
  inline ::TSCE::CellReferenceArchive* mutable_cell_reference();
  inline ::TSCE::CellReferenceArchive* release_cell_reference();
  inline void set_allocated_cell_reference(::TSCE::CellReferenceArchive* cell_reference);

  // @@protoc_insertion_point(class_scope:TSCE.RTreeLeafNodeContentsArchive)
 private:
  inline void set_has_cell_reference();
  inline void clear_has_cell_reference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > min_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > max_;
  ::TSCE::CellReferenceArchive* cell_reference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RTreeLeafNodeContentsArchive* default_instance_;
};
// -------------------------------------------------------------------

class RTreeNodeArchive : public ::google::protobuf::Message {
 public:
  RTreeNodeArchive();
  virtual ~RTreeNodeArchive();

  RTreeNodeArchive(const RTreeNodeArchive& from);

  inline RTreeNodeArchive& operator=(const RTreeNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RTreeNodeArchive& default_instance();

  void Swap(RTreeNodeArchive* other);

  // implements Message ----------------------------------------------

  RTreeNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RTreeNodeArchive& from);
  void MergeFrom(const RTreeNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .TSCE.RTreeInternalNodeContentsArchive internal_node_contents = 3;
  inline int internal_node_contents_size() const;
  inline void clear_internal_node_contents();
  static const int kInternalNodeContentsFieldNumber = 3;
  inline const ::TSCE::RTreeInternalNodeContentsArchive& internal_node_contents(int index) const;
  inline ::TSCE::RTreeInternalNodeContentsArchive* mutable_internal_node_contents(int index);
  inline ::TSCE::RTreeInternalNodeContentsArchive* add_internal_node_contents();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeInternalNodeContentsArchive >&
      internal_node_contents() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeInternalNodeContentsArchive >*
      mutable_internal_node_contents();

  // repeated .TSCE.RTreeLeafNodeContentsArchive leaf_node_contents = 4;
  inline int leaf_node_contents_size() const;
  inline void clear_leaf_node_contents();
  static const int kLeafNodeContentsFieldNumber = 4;
  inline const ::TSCE::RTreeLeafNodeContentsArchive& leaf_node_contents(int index) const;
  inline ::TSCE::RTreeLeafNodeContentsArchive* mutable_leaf_node_contents(int index);
  inline ::TSCE::RTreeLeafNodeContentsArchive* add_leaf_node_contents();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeLeafNodeContentsArchive >&
      leaf_node_contents() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeLeafNodeContentsArchive >*
      mutable_leaf_node_contents();

  // @@protoc_insertion_point(class_scope:TSCE.RTreeNodeArchive)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeInternalNodeContentsArchive > internal_node_contents_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeLeafNodeContentsArchive > leaf_node_contents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RTreeNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class RTreeArchive : public ::google::protobuf::Message {
 public:
  RTreeArchive();
  virtual ~RTreeArchive();

  RTreeArchive(const RTreeArchive& from);

  inline RTreeArchive& operator=(const RTreeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RTreeArchive& default_instance();

  void Swap(RTreeArchive* other);

  // implements Message ----------------------------------------------

  RTreeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RTreeArchive& from);
  void MergeFrom(const RTreeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 data_file_id = 1;
  inline bool has_data_file_id() const;
  inline void clear_data_file_id();
  static const int kDataFileIdFieldNumber = 1;
  inline ::google::protobuf::uint32 data_file_id() const;
  inline void set_data_file_id(::google::protobuf::uint32 value);

  // required uint32 data_size = 2;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 data_size() const;
  inline void set_data_size(::google::protobuf::uint32 value);

  // required uint32 data_num_dims = 3;
  inline bool has_data_num_dims() const;
  inline void clear_data_num_dims();
  static const int kDataNumDimsFieldNumber = 3;
  inline ::google::protobuf::uint32 data_num_dims() const;
  inline void set_data_num_dims(::google::protobuf::uint32 value);

  // required uint32 data_elem_size = 4;
  inline bool has_data_elem_size() const;
  inline void clear_data_elem_size();
  static const int kDataElemSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 data_elem_size() const;
  inline void set_data_elem_size(::google::protobuf::uint32 value);

  // required uint32 data_elem_real_size = 5;
  inline bool has_data_elem_real_size() const;
  inline void clear_data_elem_real_size();
  static const int kDataElemRealSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 data_elem_real_size() const;
  inline void set_data_elem_real_size(::google::protobuf::uint32 value);

  // required uint32 data_max_nodes = 6;
  inline bool has_data_max_nodes() const;
  inline void clear_data_max_nodes();
  static const int kDataMaxNodesFieldNumber = 6;
  inline ::google::protobuf::uint32 data_max_nodes() const;
  inline void set_data_max_nodes(::google::protobuf::uint32 value);

  // required uint32 data_min_nodes = 7;
  inline bool has_data_min_nodes() const;
  inline void clear_data_min_nodes();
  static const int kDataMinNodesFieldNumber = 7;
  inline ::google::protobuf::uint32 data_min_nodes() const;
  inline void set_data_min_nodes(::google::protobuf::uint32 value);

  // required .TSCE.RTreeNodeArchive root = 8;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 8;
  inline const ::TSCE::RTreeNodeArchive& root() const;
  inline ::TSCE::RTreeNodeArchive* mutable_root();
  inline ::TSCE::RTreeNodeArchive* release_root();
  inline void set_allocated_root(::TSCE::RTreeNodeArchive* root);

  // @@protoc_insertion_point(class_scope:TSCE.RTreeArchive)
 private:
  inline void set_has_data_file_id();
  inline void clear_has_data_file_id();
  inline void set_has_data_size();
  inline void clear_has_data_size();
  inline void set_has_data_num_dims();
  inline void clear_has_data_num_dims();
  inline void set_has_data_elem_size();
  inline void clear_has_data_elem_size();
  inline void set_has_data_elem_real_size();
  inline void clear_has_data_elem_real_size();
  inline void set_has_data_max_nodes();
  inline void clear_has_data_max_nodes();
  inline void set_has_data_min_nodes();
  inline void clear_has_data_min_nodes();
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 data_file_id_;
  ::google::protobuf::uint32 data_size_;
  ::google::protobuf::uint32 data_num_dims_;
  ::google::protobuf::uint32 data_elem_size_;
  ::google::protobuf::uint32 data_elem_real_size_;
  ::google::protobuf::uint32 data_max_nodes_;
  ::TSCE::RTreeNodeArchive* root_;
  ::google::protobuf::uint32 data_min_nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RTreeArchive* default_instance_;
};
// -------------------------------------------------------------------

class RangeDependenciesArchive : public ::google::protobuf::Message {
 public:
  RangeDependenciesArchive();
  virtual ~RangeDependenciesArchive();

  RangeDependenciesArchive(const RangeDependenciesArchive& from);

  inline RangeDependenciesArchive& operator=(const RangeDependenciesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeDependenciesArchive& default_instance();

  void Swap(RangeDependenciesArchive* other);

  // implements Message ----------------------------------------------

  RangeDependenciesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeDependenciesArchive& from);
  void MergeFrom(const RangeDependenciesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSCE.RTreeArchive r_tree = 1;
  inline bool has_r_tree() const;
  inline void clear_r_tree();
  static const int kRTreeFieldNumber = 1;
  inline const ::TSCE::RTreeArchive& r_tree() const;
  inline ::TSCE::RTreeArchive* mutable_r_tree();
  inline ::TSCE::RTreeArchive* release_r_tree();
  inline void set_allocated_r_tree(::TSCE::RTreeArchive* r_tree);

  // repeated .TSCE.RangeBackDependencyArchive back_dependency = 2;
  inline int back_dependency_size() const;
  inline void clear_back_dependency();
  static const int kBackDependencyFieldNumber = 2;
  inline const ::TSCE::RangeBackDependencyArchive& back_dependency(int index) const;
  inline ::TSCE::RangeBackDependencyArchive* mutable_back_dependency(int index);
  inline ::TSCE::RangeBackDependencyArchive* add_back_dependency();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::RangeBackDependencyArchive >&
      back_dependency() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::RangeBackDependencyArchive >*
      mutable_back_dependency();

  // @@protoc_insertion_point(class_scope:TSCE.RangeDependenciesArchive)
 private:
  inline void set_has_r_tree();
  inline void clear_has_r_tree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::RTreeArchive* r_tree_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::RangeBackDependencyArchive > back_dependency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RangeDependenciesArchive* default_instance_;
};
// -------------------------------------------------------------------

class SpanningDependenciesArchive_ReferringColumnToLocalCells : public ::google::protobuf::Message {
 public:
  SpanningDependenciesArchive_ReferringColumnToLocalCells();
  virtual ~SpanningDependenciesArchive_ReferringColumnToLocalCells();

  SpanningDependenciesArchive_ReferringColumnToLocalCells(const SpanningDependenciesArchive_ReferringColumnToLocalCells& from);

  inline SpanningDependenciesArchive_ReferringColumnToLocalCells& operator=(const SpanningDependenciesArchive_ReferringColumnToLocalCells& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpanningDependenciesArchive_ReferringColumnToLocalCells& default_instance();

  void Swap(SpanningDependenciesArchive_ReferringColumnToLocalCells* other);

  // implements Message ----------------------------------------------

  SpanningDependenciesArchive_ReferringColumnToLocalCells* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpanningDependenciesArchive_ReferringColumnToLocalCells& from);
  void MergeFrom(const SpanningDependenciesArchive_ReferringColumnToLocalCells& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // required .TSCE.SpanningDependenciesArchive.RangeContext range_context = 2;
  inline bool has_range_context() const;
  inline void clear_range_context();
  static const int kRangeContextFieldNumber = 2;
  inline ::TSCE::SpanningDependenciesArchive_RangeContext range_context() const;
  inline void set_range_context(::TSCE::SpanningDependenciesArchive_RangeContext value);

  // repeated .TSCE.CellCoordinateArchive cell_coordinate = 3;
  inline int cell_coordinate_size() const;
  inline void clear_cell_coordinate();
  static const int kCellCoordinateFieldNumber = 3;
  inline const ::TSCE::CellCoordinateArchive& cell_coordinate(int index) const;
  inline ::TSCE::CellCoordinateArchive* mutable_cell_coordinate(int index);
  inline ::TSCE::CellCoordinateArchive* add_cell_coordinate();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >&
      cell_coordinate() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >*
      mutable_cell_coordinate();

  // @@protoc_insertion_point(class_scope:TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_range_context();
  inline void clear_has_range_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 column_;
  int range_context_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive > cell_coordinate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static SpanningDependenciesArchive_ReferringColumnToLocalCells* default_instance_;
};
// -------------------------------------------------------------------

class SpanningDependenciesArchive_ReferringColumnToRemoteCells : public ::google::protobuf::Message {
 public:
  SpanningDependenciesArchive_ReferringColumnToRemoteCells();
  virtual ~SpanningDependenciesArchive_ReferringColumnToRemoteCells();

  SpanningDependenciesArchive_ReferringColumnToRemoteCells(const SpanningDependenciesArchive_ReferringColumnToRemoteCells& from);

  inline SpanningDependenciesArchive_ReferringColumnToRemoteCells& operator=(const SpanningDependenciesArchive_ReferringColumnToRemoteCells& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpanningDependenciesArchive_ReferringColumnToRemoteCells& default_instance();

  void Swap(SpanningDependenciesArchive_ReferringColumnToRemoteCells* other);

  // implements Message ----------------------------------------------

  SpanningDependenciesArchive_ReferringColumnToRemoteCells* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpanningDependenciesArchive_ReferringColumnToRemoteCells& from);
  void MergeFrom(const SpanningDependenciesArchive_ReferringColumnToRemoteCells& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // required .TSCE.SpanningDependenciesArchive.RangeContext range_context = 2;
  inline bool has_range_context() const;
  inline void clear_range_context();
  static const int kRangeContextFieldNumber = 2;
  inline ::TSCE::SpanningDependenciesArchive_RangeContext range_context() const;
  inline void set_range_context(::TSCE::SpanningDependenciesArchive_RangeContext value);

  // repeated .TSCE.InternalCellReferenceArchive internal_cell_reference = 3;
  inline int internal_cell_reference_size() const;
  inline void clear_internal_cell_reference();
  static const int kInternalCellReferenceFieldNumber = 3;
  inline const ::TSCE::InternalCellReferenceArchive& internal_cell_reference(int index) const;
  inline ::TSCE::InternalCellReferenceArchive* mutable_internal_cell_reference(int index);
  inline ::TSCE::InternalCellReferenceArchive* add_internal_cell_reference();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >&
      internal_cell_reference() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >*
      mutable_internal_cell_reference();

  // @@protoc_insertion_point(class_scope:TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_range_context();
  inline void clear_has_range_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 column_;
  int range_context_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive > internal_cell_reference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static SpanningDependenciesArchive_ReferringColumnToRemoteCells* default_instance_;
};
// -------------------------------------------------------------------

class SpanningDependenciesArchive : public ::google::protobuf::Message {
 public:
  SpanningDependenciesArchive();
  virtual ~SpanningDependenciesArchive();

  SpanningDependenciesArchive(const SpanningDependenciesArchive& from);

  inline SpanningDependenciesArchive& operator=(const SpanningDependenciesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpanningDependenciesArchive& default_instance();

  void Swap(SpanningDependenciesArchive* other);

  // implements Message ----------------------------------------------

  SpanningDependenciesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpanningDependenciesArchive& from);
  void MergeFrom(const SpanningDependenciesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SpanningDependenciesArchive_ReferringColumnToLocalCells ReferringColumnToLocalCells;
  typedef SpanningDependenciesArchive_ReferringColumnToRemoteCells ReferringColumnToRemoteCells;

  typedef SpanningDependenciesArchive_RangeContext RangeContext;
  static const RangeContext DEFAULT = SpanningDependenciesArchive_RangeContext_DEFAULT;
  static const RangeContext INCLUDE_HEADERS = SpanningDependenciesArchive_RangeContext_INCLUDE_HEADERS;
  static inline bool RangeContext_IsValid(int value) {
    return SpanningDependenciesArchive_RangeContext_IsValid(value);
  }
  static const RangeContext RangeContext_MIN =
    SpanningDependenciesArchive_RangeContext_RangeContext_MIN;
  static const RangeContext RangeContext_MAX =
    SpanningDependenciesArchive_RangeContext_RangeContext_MAX;
  static const int RangeContext_ARRAYSIZE =
    SpanningDependenciesArchive_RangeContext_RangeContext_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RangeContext_descriptor() {
    return SpanningDependenciesArchive_RangeContext_descriptor();
  }
  static inline const ::std::string& RangeContext_Name(RangeContext value) {
    return SpanningDependenciesArchive_RangeContext_Name(value);
  }
  static inline bool RangeContext_Parse(const ::std::string& name,
      RangeContext* value) {
    return SpanningDependenciesArchive_RangeContext_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 column = 1;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column(int index) const;
  inline void set_column(int index, ::google::protobuf::uint32 value);
  inline void add_column(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      column() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_column();

  // repeated .TSCE.SpanningDependenciesArchive.RangeContext range_context = 2;
  inline int range_context_size() const;
  inline void clear_range_context();
  static const int kRangeContextFieldNumber = 2;
  inline ::TSCE::SpanningDependenciesArchive_RangeContext range_context(int index) const;
  inline void set_range_context(int index, ::TSCE::SpanningDependenciesArchive_RangeContext value);
  inline void add_range_context(::TSCE::SpanningDependenciesArchive_RangeContext value);
  inline const ::google::protobuf::RepeatedField<int>& range_context() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_range_context();

  // repeated .TSCE.CellReferenceArchive cell = 3;
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 3;
  inline const ::TSCE::CellReferenceArchive& cell(int index) const;
  inline ::TSCE::CellReferenceArchive* mutable_cell(int index);
  inline ::TSCE::CellReferenceArchive* add_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >&
      cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >*
      mutable_cell();

  // optional .TSCE.RangeCoordinateArchive total_range_for_deleted_table = 4;
  inline bool has_total_range_for_deleted_table() const;
  inline void clear_total_range_for_deleted_table();
  static const int kTotalRangeForDeletedTableFieldNumber = 4;
  inline const ::TSCE::RangeCoordinateArchive& total_range_for_deleted_table() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_total_range_for_deleted_table();
  inline ::TSCE::RangeCoordinateArchive* release_total_range_for_deleted_table();
  inline void set_allocated_total_range_for_deleted_table(::TSCE::RangeCoordinateArchive* total_range_for_deleted_table);

  // optional .TSCE.RangeCoordinateArchive body_range_for_deleted_table = 5;
  inline bool has_body_range_for_deleted_table() const;
  inline void clear_body_range_for_deleted_table();
  static const int kBodyRangeForDeletedTableFieldNumber = 5;
  inline const ::TSCE::RangeCoordinateArchive& body_range_for_deleted_table() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_body_range_for_deleted_table();
  inline ::TSCE::RangeCoordinateArchive* release_body_range_for_deleted_table();
  inline void set_allocated_body_range_for_deleted_table(::TSCE::RangeCoordinateArchive* body_range_for_deleted_table);

  // repeated .TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells referring_column_to_local_cells = 6;
  inline int referring_column_to_local_cells_size() const;
  inline void clear_referring_column_to_local_cells();
  static const int kReferringColumnToLocalCellsFieldNumber = 6;
  inline const ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells& referring_column_to_local_cells(int index) const;
  inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells* mutable_referring_column_to_local_cells(int index);
  inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells* add_referring_column_to_local_cells();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells >&
      referring_column_to_local_cells() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells >*
      mutable_referring_column_to_local_cells();

  // repeated .TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells referring_column_to_remote_cells = 7;
  inline int referring_column_to_remote_cells_size() const;
  inline void clear_referring_column_to_remote_cells();
  static const int kReferringColumnToRemoteCellsFieldNumber = 7;
  inline const ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells& referring_column_to_remote_cells(int index) const;
  inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells* mutable_referring_column_to_remote_cells(int index);
  inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells* add_referring_column_to_remote_cells();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells >&
      referring_column_to_remote_cells() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells >*
      mutable_referring_column_to_remote_cells();

  // @@protoc_insertion_point(class_scope:TSCE.SpanningDependenciesArchive)
 private:
  inline void set_has_total_range_for_deleted_table();
  inline void clear_has_total_range_for_deleted_table();
  inline void set_has_body_range_for_deleted_table();
  inline void clear_has_body_range_for_deleted_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > column_;
  ::google::protobuf::RepeatedField<int> range_context_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive > cell_;
  ::TSCE::RangeCoordinateArchive* total_range_for_deleted_table_;
  ::TSCE::RangeCoordinateArchive* body_range_for_deleted_table_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells > referring_column_to_local_cells_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells > referring_column_to_remote_cells_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static SpanningDependenciesArchive* default_instance_;
};
// -------------------------------------------------------------------

class WholeOwnerDependenciesArchive : public ::google::protobuf::Message {
 public:
  WholeOwnerDependenciesArchive();
  virtual ~WholeOwnerDependenciesArchive();

  WholeOwnerDependenciesArchive(const WholeOwnerDependenciesArchive& from);

  inline WholeOwnerDependenciesArchive& operator=(const WholeOwnerDependenciesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WholeOwnerDependenciesArchive& default_instance();

  void Swap(WholeOwnerDependenciesArchive* other);

  // implements Message ----------------------------------------------

  WholeOwnerDependenciesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WholeOwnerDependenciesArchive& from);
  void MergeFrom(const WholeOwnerDependenciesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.InternalCellReferenceArchive dependent_cell = 1;
  inline int dependent_cell_size() const;
  inline void clear_dependent_cell();
  static const int kDependentCellFieldNumber = 1;
  inline const ::TSCE::InternalCellReferenceArchive& dependent_cell(int index) const;
  inline ::TSCE::InternalCellReferenceArchive* mutable_dependent_cell(int index);
  inline ::TSCE::InternalCellReferenceArchive* add_dependent_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >&
      dependent_cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >*
      mutable_dependent_cell();

  // @@protoc_insertion_point(class_scope:TSCE.WholeOwnerDependenciesArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive > dependent_cell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static WholeOwnerDependenciesArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaOwnerInfoArchive : public ::google::protobuf::Message {
 public:
  FormulaOwnerInfoArchive();
  virtual ~FormulaOwnerInfoArchive();

  FormulaOwnerInfoArchive(const FormulaOwnerInfoArchive& from);

  inline FormulaOwnerInfoArchive& operator=(const FormulaOwnerInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaOwnerInfoArchive& default_instance();

  void Swap(FormulaOwnerInfoArchive* other);

  // implements Message ----------------------------------------------

  FormulaOwnerInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaOwnerInfoArchive& from);
  void MergeFrom(const FormulaOwnerInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive formula_owner_id = 1;
  inline bool has_formula_owner_id() const;
  inline void clear_formula_owner_id();
  static const int kFormulaOwnerIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& formula_owner_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_formula_owner_id();
  inline ::TSCE::CFUUIDArchive* release_formula_owner_id();
  inline void set_allocated_formula_owner_id(::TSCE::CFUUIDArchive* formula_owner_id);

  // optional .TSCE.CellDependenciesArchive cell_dependencies = 2;
  inline bool has_cell_dependencies() const;
  inline void clear_cell_dependencies();
  static const int kCellDependenciesFieldNumber = 2;
  inline const ::TSCE::CellDependenciesArchive& cell_dependencies() const;
  inline ::TSCE::CellDependenciesArchive* mutable_cell_dependencies();
  inline ::TSCE::CellDependenciesArchive* release_cell_dependencies();
  inline void set_allocated_cell_dependencies(::TSCE::CellDependenciesArchive* cell_dependencies);

  // optional .TSCE.RangeDependenciesArchive range_dependencies = 3;
  inline bool has_range_dependencies() const;
  inline void clear_range_dependencies();
  static const int kRangeDependenciesFieldNumber = 3;
  inline const ::TSCE::RangeDependenciesArchive& range_dependencies() const;
  inline ::TSCE::RangeDependenciesArchive* mutable_range_dependencies();
  inline ::TSCE::RangeDependenciesArchive* release_range_dependencies();
  inline void set_allocated_range_dependencies(::TSCE::RangeDependenciesArchive* range_dependencies);

  // optional .TSCE.VolatileDependenciesArchive volatile_dependencies = 4;
  inline bool has_volatile_dependencies() const;
  inline void clear_volatile_dependencies();
  static const int kVolatileDependenciesFieldNumber = 4;
  inline const ::TSCE::VolatileDependenciesArchive& volatile_dependencies() const;
  inline ::TSCE::VolatileDependenciesArchive* mutable_volatile_dependencies();
  inline ::TSCE::VolatileDependenciesArchive* release_volatile_dependencies();
  inline void set_allocated_volatile_dependencies(::TSCE::VolatileDependenciesArchive* volatile_dependencies);

  // optional .TSCE.SpanningDependenciesArchive spanning_column_dependencies = 5;
  inline bool has_spanning_column_dependencies() const;
  inline void clear_spanning_column_dependencies();
  static const int kSpanningColumnDependenciesFieldNumber = 5;
  inline const ::TSCE::SpanningDependenciesArchive& spanning_column_dependencies() const;
  inline ::TSCE::SpanningDependenciesArchive* mutable_spanning_column_dependencies();
  inline ::TSCE::SpanningDependenciesArchive* release_spanning_column_dependencies();
  inline void set_allocated_spanning_column_dependencies(::TSCE::SpanningDependenciesArchive* spanning_column_dependencies);

  // optional .TSCE.SpanningDependenciesArchive spanning_row_dependencies = 6;
  inline bool has_spanning_row_dependencies() const;
  inline void clear_spanning_row_dependencies();
  static const int kSpanningRowDependenciesFieldNumber = 6;
  inline const ::TSCE::SpanningDependenciesArchive& spanning_row_dependencies() const;
  inline ::TSCE::SpanningDependenciesArchive* mutable_spanning_row_dependencies();
  inline ::TSCE::SpanningDependenciesArchive* release_spanning_row_dependencies();
  inline void set_allocated_spanning_row_dependencies(::TSCE::SpanningDependenciesArchive* spanning_row_dependencies);

  // optional .TSCE.WholeOwnerDependenciesArchive whole_owner_dependencies = 8;
  inline bool has_whole_owner_dependencies() const;
  inline void clear_whole_owner_dependencies();
  static const int kWholeOwnerDependenciesFieldNumber = 8;
  inline const ::TSCE::WholeOwnerDependenciesArchive& whole_owner_dependencies() const;
  inline ::TSCE::WholeOwnerDependenciesArchive* mutable_whole_owner_dependencies();
  inline ::TSCE::WholeOwnerDependenciesArchive* release_whole_owner_dependencies();
  inline void set_allocated_whole_owner_dependencies(::TSCE::WholeOwnerDependenciesArchive* whole_owner_dependencies);

  // optional .TSP.Reference formula_owner = 7;
  inline bool has_formula_owner() const;
  inline void clear_formula_owner();
  static const int kFormulaOwnerFieldNumber = 7;
  inline const ::TSP::Reference& formula_owner() const;
  inline ::TSP::Reference* mutable_formula_owner();
  inline ::TSP::Reference* release_formula_owner();
  inline void set_allocated_formula_owner(::TSP::Reference* formula_owner);

  // @@protoc_insertion_point(class_scope:TSCE.FormulaOwnerInfoArchive)
 private:
  inline void set_has_formula_owner_id();
  inline void clear_has_formula_owner_id();
  inline void set_has_cell_dependencies();
  inline void clear_has_cell_dependencies();
  inline void set_has_range_dependencies();
  inline void clear_has_range_dependencies();
  inline void set_has_volatile_dependencies();
  inline void clear_has_volatile_dependencies();
  inline void set_has_spanning_column_dependencies();
  inline void clear_has_spanning_column_dependencies();
  inline void set_has_spanning_row_dependencies();
  inline void clear_has_spanning_row_dependencies();
  inline void set_has_whole_owner_dependencies();
  inline void clear_has_whole_owner_dependencies();
  inline void set_has_formula_owner();
  inline void clear_has_formula_owner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* formula_owner_id_;
  ::TSCE::CellDependenciesArchive* cell_dependencies_;
  ::TSCE::RangeDependenciesArchive* range_dependencies_;
  ::TSCE::VolatileDependenciesArchive* volatile_dependencies_;
  ::TSCE::SpanningDependenciesArchive* spanning_column_dependencies_;
  ::TSCE::SpanningDependenciesArchive* spanning_row_dependencies_;
  ::TSCE::WholeOwnerDependenciesArchive* whole_owner_dependencies_;
  ::TSP::Reference* formula_owner_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaOwnerInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class OwnerIDMapArchive_OwnerIDMapArchiveEntry : public ::google::protobuf::Message {
 public:
  OwnerIDMapArchive_OwnerIDMapArchiveEntry();
  virtual ~OwnerIDMapArchive_OwnerIDMapArchiveEntry();

  OwnerIDMapArchive_OwnerIDMapArchiveEntry(const OwnerIDMapArchive_OwnerIDMapArchiveEntry& from);

  inline OwnerIDMapArchive_OwnerIDMapArchiveEntry& operator=(const OwnerIDMapArchive_OwnerIDMapArchiveEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnerIDMapArchive_OwnerIDMapArchiveEntry& default_instance();

  void Swap(OwnerIDMapArchive_OwnerIDMapArchiveEntry* other);

  // implements Message ----------------------------------------------

  OwnerIDMapArchive_OwnerIDMapArchiveEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnerIDMapArchive_OwnerIDMapArchiveEntry& from);
  void MergeFrom(const OwnerIDMapArchive_OwnerIDMapArchiveEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 internal_owner_id = 1;
  inline bool has_internal_owner_id() const;
  inline void clear_internal_owner_id();
  static const int kInternalOwnerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 internal_owner_id() const;
  inline void set_internal_owner_id(::google::protobuf::uint32 value);

  // required .TSCE.CFUUIDArchive owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline const ::TSCE::CFUUIDArchive& owner_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_owner_id();
  inline ::TSCE::CFUUIDArchive* release_owner_id();
  inline void set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id);

  // @@protoc_insertion_point(class_scope:TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry)
 private:
  inline void set_has_internal_owner_id();
  inline void clear_has_internal_owner_id();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* owner_id_;
  ::google::protobuf::uint32 internal_owner_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static OwnerIDMapArchive_OwnerIDMapArchiveEntry* default_instance_;
};
// -------------------------------------------------------------------

class OwnerIDMapArchive : public ::google::protobuf::Message {
 public:
  OwnerIDMapArchive();
  virtual ~OwnerIDMapArchive();

  OwnerIDMapArchive(const OwnerIDMapArchive& from);

  inline OwnerIDMapArchive& operator=(const OwnerIDMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnerIDMapArchive& default_instance();

  void Swap(OwnerIDMapArchive* other);

  // implements Message ----------------------------------------------

  OwnerIDMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnerIDMapArchive& from);
  void MergeFrom(const OwnerIDMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OwnerIDMapArchive_OwnerIDMapArchiveEntry OwnerIDMapArchiveEntry;

  // accessors -------------------------------------------------------

  // repeated .TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry map_entry = 1;
  inline int map_entry_size() const;
  inline void clear_map_entry();
  static const int kMapEntryFieldNumber = 1;
  inline const ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry& map_entry(int index) const;
  inline ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry* mutable_map_entry(int index);
  inline ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry* add_map_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry >&
      map_entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry >*
      mutable_map_entry();

  // @@protoc_insertion_point(class_scope:TSCE.OwnerIDMapArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry > map_entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static OwnerIDMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class DependencyTrackerArchive : public ::google::protobuf::Message {
 public:
  DependencyTrackerArchive();
  virtual ~DependencyTrackerArchive();

  DependencyTrackerArchive(const DependencyTrackerArchive& from);

  inline DependencyTrackerArchive& operator=(const DependencyTrackerArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DependencyTrackerArchive& default_instance();

  void Swap(DependencyTrackerArchive* other);

  // implements Message ----------------------------------------------

  DependencyTrackerArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DependencyTrackerArchive& from);
  void MergeFrom(const DependencyTrackerArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.FormulaOwnerInfoArchive formula_owner_info = 1;
  inline int formula_owner_info_size() const;
  inline void clear_formula_owner_info();
  static const int kFormulaOwnerInfoFieldNumber = 1;
  inline const ::TSCE::FormulaOwnerInfoArchive& formula_owner_info(int index) const;
  inline ::TSCE::FormulaOwnerInfoArchive* mutable_formula_owner_info(int index);
  inline ::TSCE::FormulaOwnerInfoArchive* add_formula_owner_info();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::FormulaOwnerInfoArchive >&
      formula_owner_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::FormulaOwnerInfoArchive >*
      mutable_formula_owner_info();

  // repeated .TSCE.CellReferenceArchive dirty_leaf = 2 [deprecated = true];
  inline int dirty_leaf_size() const PROTOBUF_DEPRECATED;
  inline void clear_dirty_leaf() PROTOBUF_DEPRECATED;
  static const int kDirtyLeafFieldNumber = 2;
  inline const ::TSCE::CellReferenceArchive& dirty_leaf(int index) const PROTOBUF_DEPRECATED;
  inline ::TSCE::CellReferenceArchive* mutable_dirty_leaf(int index) PROTOBUF_DEPRECATED;
  inline ::TSCE::CellReferenceArchive* add_dirty_leaf() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >&
      dirty_leaf() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >*
      mutable_dirty_leaf() PROTOBUF_DEPRECATED;

  // repeated .TSCE.InternalCellReferenceArchive internal_dirty_leaf = 4 [deprecated = true];
  inline int internal_dirty_leaf_size() const PROTOBUF_DEPRECATED;
  inline void clear_internal_dirty_leaf() PROTOBUF_DEPRECATED;
  static const int kInternalDirtyLeafFieldNumber = 4;
  inline const ::TSCE::InternalCellReferenceArchive& internal_dirty_leaf(int index) const PROTOBUF_DEPRECATED;
  inline ::TSCE::InternalCellReferenceArchive* mutable_internal_dirty_leaf(int index) PROTOBUF_DEPRECATED;
  inline ::TSCE::InternalCellReferenceArchive* add_internal_dirty_leaf() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >&
      internal_dirty_leaf() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >*
      mutable_internal_dirty_leaf() PROTOBUF_DEPRECATED;

  // optional .TSCE.OwnerIDMapArchive owner_id_map = 3;
  inline bool has_owner_id_map() const;
  inline void clear_owner_id_map();
  static const int kOwnerIdMapFieldNumber = 3;
  inline const ::TSCE::OwnerIDMapArchive& owner_id_map() const;
  inline ::TSCE::OwnerIDMapArchive* mutable_owner_id_map();
  inline ::TSCE::OwnerIDMapArchive* release_owner_id_map();
  inline void set_allocated_owner_id_map(::TSCE::OwnerIDMapArchive* owner_id_map);

  // @@protoc_insertion_point(class_scope:TSCE.DependencyTrackerArchive)
 private:
  inline void set_has_owner_id_map();
  inline void clear_has_owner_id_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::FormulaOwnerInfoArchive > formula_owner_info_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive > dirty_leaf_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive > internal_dirty_leaf_;
  ::TSCE::OwnerIDMapArchive* owner_id_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static DependencyTrackerArchive* default_instance_;
};
// -------------------------------------------------------------------

class NameTrackedReferencePair : public ::google::protobuf::Message {
 public:
  NameTrackedReferencePair();
  virtual ~NameTrackedReferencePair();

  NameTrackedReferencePair(const NameTrackedReferencePair& from);

  inline NameTrackedReferencePair& operator=(const NameTrackedReferencePair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameTrackedReferencePair& default_instance();

  void Swap(NameTrackedReferencePair* other);

  // implements Message ----------------------------------------------

  NameTrackedReferencePair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameTrackedReferencePair& from);
  void MergeFrom(const NameTrackedReferencePair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .TSP.Reference tracked_reference = 2;
  inline bool has_tracked_reference() const;
  inline void clear_tracked_reference();
  static const int kTrackedReferenceFieldNumber = 2;
  inline const ::TSP::Reference& tracked_reference() const;
  inline ::TSP::Reference* mutable_tracked_reference();
  inline ::TSP::Reference* release_tracked_reference();
  inline void set_allocated_tracked_reference(::TSP::Reference* tracked_reference);

  // optional uint32 tracked_reference_id = 3;
  inline bool has_tracked_reference_id() const;
  inline void clear_tracked_reference_id();
  static const int kTrackedReferenceIdFieldNumber = 3;
  inline ::google::protobuf::uint32 tracked_reference_id() const;
  inline void set_tracked_reference_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.NameTrackedReferencePair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tracked_reference();
  inline void clear_has_tracked_reference();
  inline void set_has_tracked_reference_id();
  inline void clear_has_tracked_reference_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::TSP::Reference* tracked_reference_;
  ::google::protobuf::uint32 tracked_reference_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static NameTrackedReferencePair* default_instance_;
};
// -------------------------------------------------------------------

class NamesByTrackedReferenceArchive : public ::google::protobuf::Message {
 public:
  NamesByTrackedReferenceArchive();
  virtual ~NamesByTrackedReferenceArchive();

  NamesByTrackedReferenceArchive(const NamesByTrackedReferenceArchive& from);

  inline NamesByTrackedReferenceArchive& operator=(const NamesByTrackedReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamesByTrackedReferenceArchive& default_instance();

  void Swap(NamesByTrackedReferenceArchive* other);

  // implements Message ----------------------------------------------

  NamesByTrackedReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamesByTrackedReferenceArchive& from);
  void MergeFrom(const NamesByTrackedReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // repeated .TSCE.NameTrackedReferencePair name_tracked_reference_pair = 2;
  inline int name_tracked_reference_pair_size() const;
  inline void clear_name_tracked_reference_pair();
  static const int kNameTrackedReferencePairFieldNumber = 2;
  inline const ::TSCE::NameTrackedReferencePair& name_tracked_reference_pair(int index) const;
  inline ::TSCE::NameTrackedReferencePair* mutable_name_tracked_reference_pair(int index);
  inline ::TSCE::NameTrackedReferencePair* add_name_tracked_reference_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::NameTrackedReferencePair >&
      name_tracked_reference_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::NameTrackedReferencePair >*
      mutable_name_tracked_reference_pair();

  // @@protoc_insertion_point(class_scope:TSCE.NamesByTrackedReferenceArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::NameTrackedReferencePair > name_tracked_reference_pair_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static NamesByTrackedReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class NamedReferenceManagerArchive : public ::google::protobuf::Message {
 public:
  NamedReferenceManagerArchive();
  virtual ~NamedReferenceManagerArchive();

  NamedReferenceManagerArchive(const NamedReferenceManagerArchive& from);

  inline NamedReferenceManagerArchive& operator=(const NamedReferenceManagerArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamedReferenceManagerArchive& default_instance();

  void Swap(NamedReferenceManagerArchive* other);

  // implements Message ----------------------------------------------

  NamedReferenceManagerArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamedReferenceManagerArchive& from);
  void MergeFrom(const NamedReferenceManagerArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference reference_tracker = 1;
  inline bool has_reference_tracker() const;
  inline void clear_reference_tracker();
  static const int kReferenceTrackerFieldNumber = 1;
  inline const ::TSP::Reference& reference_tracker() const;
  inline ::TSP::Reference* mutable_reference_tracker();
  inline ::TSP::Reference* release_reference_tracker();
  inline void set_allocated_reference_tracker(::TSP::Reference* reference_tracker);

  // repeated .TSCE.NamesByTrackedReferenceArchive names_by_tracked_reference_by_table = 2 [deprecated = true];
  inline int names_by_tracked_reference_by_table_size() const PROTOBUF_DEPRECATED;
  inline void clear_names_by_tracked_reference_by_table() PROTOBUF_DEPRECATED;
  static const int kNamesByTrackedReferenceByTableFieldNumber = 2;
  inline const ::TSCE::NamesByTrackedReferenceArchive& names_by_tracked_reference_by_table(int index) const PROTOBUF_DEPRECATED;
  inline ::TSCE::NamesByTrackedReferenceArchive* mutable_names_by_tracked_reference_by_table(int index) PROTOBUF_DEPRECATED;
  inline ::TSCE::NamesByTrackedReferenceArchive* add_names_by_tracked_reference_by_table() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::NamesByTrackedReferenceArchive >&
      names_by_tracked_reference_by_table() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::NamesByTrackedReferenceArchive >*
      mutable_names_by_tracked_reference_by_table() PROTOBUF_DEPRECATED;

  // @@protoc_insertion_point(class_scope:TSCE.NamedReferenceManagerArchive)
 private:
  inline void set_has_reference_tracker();
  inline void clear_has_reference_tracker();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* reference_tracker_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::NamesByTrackedReferenceArchive > names_by_tracked_reference_by_table_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static NamedReferenceManagerArchive* default_instance_;
};
// -------------------------------------------------------------------

class CalculationEngineArchive : public ::google::protobuf::Message {
 public:
  CalculationEngineArchive();
  virtual ~CalculationEngineArchive();

  CalculationEngineArchive(const CalculationEngineArchive& from);

  inline CalculationEngineArchive& operator=(const CalculationEngineArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalculationEngineArchive& default_instance();

  void Swap(CalculationEngineArchive* other);

  // implements Message ----------------------------------------------

  CalculationEngineArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalculationEngineArchive& from);
  void MergeFrom(const CalculationEngineArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CalculationEngineArchive_ExcelImportDateMode ExcelImportDateMode;
  static const ExcelImportDateMode DATE_MODE_1900 = CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1900;
  static const ExcelImportDateMode DATE_MODE_1900_LEGACY = CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1900_LEGACY;
  static const ExcelImportDateMode DATE_MODE_1904_LEGACY = CalculationEngineArchive_ExcelImportDateMode_DATE_MODE_1904_LEGACY;
  static inline bool ExcelImportDateMode_IsValid(int value) {
    return CalculationEngineArchive_ExcelImportDateMode_IsValid(value);
  }
  static const ExcelImportDateMode ExcelImportDateMode_MIN =
    CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_MIN;
  static const ExcelImportDateMode ExcelImportDateMode_MAX =
    CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_MAX;
  static const int ExcelImportDateMode_ARRAYSIZE =
    CalculationEngineArchive_ExcelImportDateMode_ExcelImportDateMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExcelImportDateMode_descriptor() {
    return CalculationEngineArchive_ExcelImportDateMode_descriptor();
  }
  static inline const ::std::string& ExcelImportDateMode_Name(ExcelImportDateMode value) {
    return CalculationEngineArchive_ExcelImportDateMode_Name(value);
  }
  static inline bool ExcelImportDateMode_Parse(const ::std::string& name,
      ExcelImportDateMode* value) {
    return CalculationEngineArchive_ExcelImportDateMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool base_date_1904 = 1;
  inline bool has_base_date_1904() const;
  inline void clear_base_date_1904();
  static const int kBaseDate1904FieldNumber = 1;
  inline bool base_date_1904() const;
  inline void set_base_date_1904(bool value);

  // required .TSCE.DependencyTrackerArchive dependency_tracker = 2;
  inline bool has_dependency_tracker() const;
  inline void clear_dependency_tracker();
  static const int kDependencyTrackerFieldNumber = 2;
  inline const ::TSCE::DependencyTrackerArchive& dependency_tracker() const;
  inline ::TSCE::DependencyTrackerArchive* mutable_dependency_tracker();
  inline ::TSCE::DependencyTrackerArchive* release_dependency_tracker();
  inline void set_allocated_dependency_tracker(::TSCE::DependencyTrackerArchive* dependency_tracker);

  // optional .TSP.Reference named_reference_manager = 3;
  inline bool has_named_reference_manager() const;
  inline void clear_named_reference_manager();
  static const int kNamedReferenceManagerFieldNumber = 3;
  inline const ::TSP::Reference& named_reference_manager() const;
  inline ::TSP::Reference* mutable_named_reference_manager();
  inline ::TSP::Reference* release_named_reference_manager();
  inline void set_allocated_named_reference_manager(::TSP::Reference* named_reference_manager);

  // optional .TSCE.CalculationEngineArchive.ExcelImportDateMode excel_import_date_mode = 4 [default = DATE_MODE_1900];
  inline bool has_excel_import_date_mode() const;
  inline void clear_excel_import_date_mode();
  static const int kExcelImportDateModeFieldNumber = 4;
  inline ::TSCE::CalculationEngineArchive_ExcelImportDateMode excel_import_date_mode() const;
  inline void set_excel_import_date_mode(::TSCE::CalculationEngineArchive_ExcelImportDateMode value);

  // optional string saved_locale_identifier = 5;
  inline bool has_saved_locale_identifier() const;
  inline void clear_saved_locale_identifier();
  static const int kSavedLocaleIdentifierFieldNumber = 5;
  inline const ::std::string& saved_locale_identifier() const;
  inline void set_saved_locale_identifier(const ::std::string& value);
  inline void set_saved_locale_identifier(const char* value);
  inline void set_saved_locale_identifier(const char* value, size_t size);
  inline ::std::string* mutable_saved_locale_identifier();
  inline ::std::string* release_saved_locale_identifier();
  inline void set_allocated_saved_locale_identifier(::std::string* saved_locale_identifier);

  // @@protoc_insertion_point(class_scope:TSCE.CalculationEngineArchive)
 private:
  inline void set_has_base_date_1904();
  inline void clear_has_base_date_1904();
  inline void set_has_dependency_tracker();
  inline void clear_has_dependency_tracker();
  inline void set_has_named_reference_manager();
  inline void clear_has_named_reference_manager();
  inline void set_has_excel_import_date_mode();
  inline void clear_has_excel_import_date_mode();
  inline void set_has_saved_locale_identifier();
  inline void clear_has_saved_locale_identifier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::DependencyTrackerArchive* dependency_tracker_;
  bool base_date_1904_;
  int excel_import_date_mode_;
  ::TSP::Reference* named_reference_manager_;
  ::std::string* saved_locale_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CalculationEngineArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive();
  virtual ~ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive();

  ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive(const ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& from);

  inline ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& operator=(const ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& default_instance();

  void Swap(ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& from);
  void MergeFrom(const ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 row_handle = 1;
  inline bool has_row_handle() const;
  inline void clear_row_handle();
  static const int kRowHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 row_handle() const;
  inline void set_row_handle(::google::protobuf::uint32 value);

  // required uint32 column_handle = 2;
  inline bool has_column_handle() const;
  inline void clear_column_handle();
  static const int kColumnHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 column_handle() const;
  inline void set_column_handle(::google::protobuf::uint32 value);

  // required uint32 row_is_sticky = 3;
  inline bool has_row_is_sticky() const;
  inline void clear_row_is_sticky();
  static const int kRowIsStickyFieldNumber = 3;
  inline ::google::protobuf::uint32 row_is_sticky() const;
  inline void set_row_is_sticky(::google::protobuf::uint32 value);

  // required uint32 column_is_sticky = 4;
  inline bool has_column_is_sticky() const;
  inline void clear_column_is_sticky();
  static const int kColumnIsStickyFieldNumber = 4;
  inline ::google::protobuf::uint32 column_is_sticky() const;
  inline void set_column_is_sticky(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive)
 private:
  inline void set_has_row_handle();
  inline void clear_has_row_handle();
  inline void set_has_column_handle();
  inline void clear_has_column_handle();
  inline void set_has_row_is_sticky();
  inline void clear_has_row_is_sticky();
  inline void set_has_column_is_sticky();
  inline void clear_has_column_is_sticky();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 row_handle_;
  ::google::protobuf::uint32 column_handle_;
  ::google::protobuf::uint32 row_is_sticky_;
  ::google::protobuf::uint32 column_is_sticky_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive();
  virtual ~ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive();

  ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive(const ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& from);

  inline ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& operator=(const ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& default_instance();

  void Swap(ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& from);
  void MergeFrom(const ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 row_handle = 1;
  inline bool has_row_handle() const;
  inline void clear_row_handle();
  static const int kRowHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 row_handle() const;
  inline void set_row_handle(::google::protobuf::uint32 value);

  // required uint32 column_handle = 2;
  inline bool has_column_handle() const;
  inline void clear_column_handle();
  static const int kColumnHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 column_handle() const;
  inline void set_column_handle(::google::protobuf::uint32 value);

  // required uint32 row_is_sticky = 3;
  inline bool has_row_is_sticky() const;
  inline void clear_row_is_sticky();
  static const int kRowIsStickyFieldNumber = 3;
  inline ::google::protobuf::uint32 row_is_sticky() const;
  inline void set_row_is_sticky(::google::protobuf::uint32 value);

  // required uint32 column_is_sticky = 4;
  inline bool has_column_is_sticky() const;
  inline void clear_column_is_sticky();
  static const int kColumnIsStickyFieldNumber = 4;
  inline ::google::protobuf::uint32 column_is_sticky() const;
  inline void set_column_is_sticky(::google::protobuf::uint32 value);

  // required .TSCE.CFUUIDArchive table_id = 5;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 5;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // optional string AST_reference_whitespace_after_sheet_name = 6;
  inline bool has_ast_reference_whitespace_after_sheet_name() const;
  inline void clear_ast_reference_whitespace_after_sheet_name();
  static const int kASTReferenceWhitespaceAfterSheetNameFieldNumber = 6;
  inline const ::std::string& ast_reference_whitespace_after_sheet_name() const;
  inline void set_ast_reference_whitespace_after_sheet_name(const ::std::string& value);
  inline void set_ast_reference_whitespace_after_sheet_name(const char* value);
  inline void set_ast_reference_whitespace_after_sheet_name(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_after_sheet_name();
  inline ::std::string* release_ast_reference_whitespace_after_sheet_name();
  inline void set_allocated_ast_reference_whitespace_after_sheet_name(::std::string* ast_reference_whitespace_after_sheet_name);

  // optional string AST_reference_whitespace_before_table_name = 7;
  inline bool has_ast_reference_whitespace_before_table_name() const;
  inline void clear_ast_reference_whitespace_before_table_name();
  static const int kASTReferenceWhitespaceBeforeTableNameFieldNumber = 7;
  inline const ::std::string& ast_reference_whitespace_before_table_name() const;
  inline void set_ast_reference_whitespace_before_table_name(const ::std::string& value);
  inline void set_ast_reference_whitespace_before_table_name(const char* value);
  inline void set_ast_reference_whitespace_before_table_name(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_before_table_name();
  inline ::std::string* release_ast_reference_whitespace_before_table_name();
  inline void set_allocated_ast_reference_whitespace_before_table_name(::std::string* ast_reference_whitespace_before_table_name);

  // optional string AST_reference_whitespace_after_table_name = 8;
  inline bool has_ast_reference_whitespace_after_table_name() const;
  inline void clear_ast_reference_whitespace_after_table_name();
  static const int kASTReferenceWhitespaceAfterTableNameFieldNumber = 8;
  inline const ::std::string& ast_reference_whitespace_after_table_name() const;
  inline void set_ast_reference_whitespace_after_table_name(const ::std::string& value);
  inline void set_ast_reference_whitespace_after_table_name(const char* value);
  inline void set_ast_reference_whitespace_after_table_name(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_after_table_name();
  inline ::std::string* release_ast_reference_whitespace_after_table_name();
  inline void set_allocated_ast_reference_whitespace_after_table_name(::std::string* ast_reference_whitespace_after_table_name);

  // optional string AST_reference_whitespace_before_cell_address = 9;
  inline bool has_ast_reference_whitespace_before_cell_address() const;
  inline void clear_ast_reference_whitespace_before_cell_address();
  static const int kASTReferenceWhitespaceBeforeCellAddressFieldNumber = 9;
  inline const ::std::string& ast_reference_whitespace_before_cell_address() const;
  inline void set_ast_reference_whitespace_before_cell_address(const ::std::string& value);
  inline void set_ast_reference_whitespace_before_cell_address(const char* value);
  inline void set_ast_reference_whitespace_before_cell_address(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_before_cell_address();
  inline ::std::string* release_ast_reference_whitespace_before_cell_address();
  inline void set_allocated_ast_reference_whitespace_before_cell_address(::std::string* ast_reference_whitespace_before_cell_address);

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive)
 private:
  inline void set_has_row_handle();
  inline void clear_has_row_handle();
  inline void set_has_column_handle();
  inline void clear_has_column_handle();
  inline void set_has_row_is_sticky();
  inline void clear_has_row_is_sticky();
  inline void set_has_column_is_sticky();
  inline void clear_has_column_is_sticky();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_ast_reference_whitespace_after_sheet_name();
  inline void clear_has_ast_reference_whitespace_after_sheet_name();
  inline void set_has_ast_reference_whitespace_before_table_name();
  inline void clear_has_ast_reference_whitespace_before_table_name();
  inline void set_has_ast_reference_whitespace_after_table_name();
  inline void clear_has_ast_reference_whitespace_after_table_name();
  inline void set_has_ast_reference_whitespace_before_cell_address();
  inline void clear_has_ast_reference_whitespace_before_cell_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 row_handle_;
  ::google::protobuf::uint32 column_handle_;
  ::google::protobuf::uint32 row_is_sticky_;
  ::google::protobuf::uint32 column_is_sticky_;
  ::TSCE::CFUUIDArchive* table_id_;
  ::std::string* ast_reference_whitespace_after_sheet_name_;
  ::std::string* ast_reference_whitespace_before_table_name_;
  ::std::string* ast_reference_whitespace_after_table_name_;
  ::std::string* ast_reference_whitespace_before_cell_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive_ASTColumnCoordinateArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive_ASTColumnCoordinateArchive();
  virtual ~ASTNodeArrayArchive_ASTColumnCoordinateArchive();

  ASTNodeArrayArchive_ASTColumnCoordinateArchive(const ASTNodeArrayArchive_ASTColumnCoordinateArchive& from);

  inline ASTNodeArrayArchive_ASTColumnCoordinateArchive& operator=(const ASTNodeArrayArchive_ASTColumnCoordinateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive_ASTColumnCoordinateArchive& default_instance();

  void Swap(ASTNodeArrayArchive_ASTColumnCoordinateArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive_ASTColumnCoordinateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive_ASTColumnCoordinateArchive& from);
  void MergeFrom(const ASTNodeArrayArchive_ASTColumnCoordinateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::int32 column() const;
  inline void set_column(::google::protobuf::int32 value);

  // optional bool absolute = 2 [default = false];
  inline bool has_absolute() const;
  inline void clear_absolute();
  static const int kAbsoluteFieldNumber = 2;
  inline bool absolute() const;
  inline void set_absolute(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_absolute();
  inline void clear_has_absolute();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 column_;
  bool absolute_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive_ASTColumnCoordinateArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive_ASTRowCoordinateArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive_ASTRowCoordinateArchive();
  virtual ~ASTNodeArrayArchive_ASTRowCoordinateArchive();

  ASTNodeArrayArchive_ASTRowCoordinateArchive(const ASTNodeArrayArchive_ASTRowCoordinateArchive& from);

  inline ASTNodeArrayArchive_ASTRowCoordinateArchive& operator=(const ASTNodeArrayArchive_ASTRowCoordinateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive_ASTRowCoordinateArchive& default_instance();

  void Swap(ASTNodeArrayArchive_ASTRowCoordinateArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive_ASTRowCoordinateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive_ASTRowCoordinateArchive& from);
  void MergeFrom(const ASTNodeArrayArchive_ASTRowCoordinateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // optional bool absolute = 2 [default = false];
  inline bool has_absolute() const;
  inline void clear_absolute();
  static const int kAbsoluteFieldNumber = 2;
  inline bool absolute() const;
  inline void set_absolute(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_absolute();
  inline void clear_has_absolute();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 row_;
  bool absolute_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive_ASTRowCoordinateArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive();
  virtual ~ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive();

  ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive(const ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& from);

  inline ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& operator=(const ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& default_instance();

  void Swap(ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& from);
  void MergeFrom(const ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // optional string AST_reference_whitespace_after_sheet_name = 2;
  inline bool has_ast_reference_whitespace_after_sheet_name() const;
  inline void clear_ast_reference_whitespace_after_sheet_name();
  static const int kASTReferenceWhitespaceAfterSheetNameFieldNumber = 2;
  inline const ::std::string& ast_reference_whitespace_after_sheet_name() const;
  inline void set_ast_reference_whitespace_after_sheet_name(const ::std::string& value);
  inline void set_ast_reference_whitespace_after_sheet_name(const char* value);
  inline void set_ast_reference_whitespace_after_sheet_name(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_after_sheet_name();
  inline ::std::string* release_ast_reference_whitespace_after_sheet_name();
  inline void set_allocated_ast_reference_whitespace_after_sheet_name(::std::string* ast_reference_whitespace_after_sheet_name);

  // optional string AST_reference_whitespace_before_table_name = 3;
  inline bool has_ast_reference_whitespace_before_table_name() const;
  inline void clear_ast_reference_whitespace_before_table_name();
  static const int kASTReferenceWhitespaceBeforeTableNameFieldNumber = 3;
  inline const ::std::string& ast_reference_whitespace_before_table_name() const;
  inline void set_ast_reference_whitespace_before_table_name(const ::std::string& value);
  inline void set_ast_reference_whitespace_before_table_name(const char* value);
  inline void set_ast_reference_whitespace_before_table_name(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_before_table_name();
  inline ::std::string* release_ast_reference_whitespace_before_table_name();
  inline void set_allocated_ast_reference_whitespace_before_table_name(::std::string* ast_reference_whitespace_before_table_name);

  // optional string AST_reference_whitespace_after_table_name = 4;
  inline bool has_ast_reference_whitespace_after_table_name() const;
  inline void clear_ast_reference_whitespace_after_table_name();
  static const int kASTReferenceWhitespaceAfterTableNameFieldNumber = 4;
  inline const ::std::string& ast_reference_whitespace_after_table_name() const;
  inline void set_ast_reference_whitespace_after_table_name(const ::std::string& value);
  inline void set_ast_reference_whitespace_after_table_name(const char* value);
  inline void set_ast_reference_whitespace_after_table_name(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_after_table_name();
  inline ::std::string* release_ast_reference_whitespace_after_table_name();
  inline void set_allocated_ast_reference_whitespace_after_table_name(::std::string* ast_reference_whitespace_after_table_name);

  // optional string AST_reference_whitespace_before_cell_address = 5;
  inline bool has_ast_reference_whitespace_before_cell_address() const;
  inline void clear_ast_reference_whitespace_before_cell_address();
  static const int kASTReferenceWhitespaceBeforeCellAddressFieldNumber = 5;
  inline const ::std::string& ast_reference_whitespace_before_cell_address() const;
  inline void set_ast_reference_whitespace_before_cell_address(const ::std::string& value);
  inline void set_ast_reference_whitespace_before_cell_address(const char* value);
  inline void set_ast_reference_whitespace_before_cell_address(const char* value, size_t size);
  inline ::std::string* mutable_ast_reference_whitespace_before_cell_address();
  inline ::std::string* release_ast_reference_whitespace_before_cell_address();
  inline void set_allocated_ast_reference_whitespace_before_cell_address(::std::string* ast_reference_whitespace_before_cell_address);

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_ast_reference_whitespace_after_sheet_name();
  inline void clear_has_ast_reference_whitespace_after_sheet_name();
  inline void set_has_ast_reference_whitespace_before_table_name();
  inline void clear_has_ast_reference_whitespace_before_table_name();
  inline void set_has_ast_reference_whitespace_after_table_name();
  inline void clear_has_ast_reference_whitespace_after_table_name();
  inline void set_has_ast_reference_whitespace_before_cell_address();
  inline void clear_has_ast_reference_whitespace_before_cell_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::std::string* ast_reference_whitespace_after_sheet_name_;
  ::std::string* ast_reference_whitespace_before_table_name_;
  ::std::string* ast_reference_whitespace_after_table_name_;
  ::std::string* ast_reference_whitespace_before_cell_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive_ASTNodeArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive_ASTNodeArchive();
  virtual ~ASTNodeArrayArchive_ASTNodeArchive();

  ASTNodeArrayArchive_ASTNodeArchive(const ASTNodeArrayArchive_ASTNodeArchive& from);

  inline ASTNodeArrayArchive_ASTNodeArchive& operator=(const ASTNodeArrayArchive_ASTNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive_ASTNodeArchive& default_instance();

  void Swap(ASTNodeArrayArchive_ASTNodeArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive_ASTNodeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive_ASTNodeArchive& from);
  void MergeFrom(const ASTNodeArrayArchive_ASTNodeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.ASTNodeArrayArchive.ASTNodeType AST_node_type = 1;
  inline bool has_ast_node_type() const;
  inline void clear_ast_node_type();
  static const int kASTNodeTypeFieldNumber = 1;
  inline ::TSCE::ASTNodeArrayArchive_ASTNodeType ast_node_type() const;
  inline void set_ast_node_type(::TSCE::ASTNodeArrayArchive_ASTNodeType value);

  // optional uint32 AST_function_node_index = 2;
  inline bool has_ast_function_node_index() const;
  inline void clear_ast_function_node_index();
  static const int kASTFunctionNodeIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 ast_function_node_index() const;
  inline void set_ast_function_node_index(::google::protobuf::uint32 value);

  // optional uint32 AST_function_node_numArgs = 3;
  inline bool has_ast_function_node_numargs() const;
  inline void clear_ast_function_node_numargs();
  static const int kASTFunctionNodeNumArgsFieldNumber = 3;
  inline ::google::protobuf::uint32 ast_function_node_numargs() const;
  inline void set_ast_function_node_numargs(::google::protobuf::uint32 value);

  // optional double AST_number_node_number = 4;
  inline bool has_ast_number_node_number() const;
  inline void clear_ast_number_node_number();
  static const int kASTNumberNodeNumberFieldNumber = 4;
  inline double ast_number_node_number() const;
  inline void set_ast_number_node_number(double value);

  // optional bool AST_boolean_node_boolean = 5;
  inline bool has_ast_boolean_node_boolean() const;
  inline void clear_ast_boolean_node_boolean();
  static const int kASTBooleanNodeBooleanFieldNumber = 5;
  inline bool ast_boolean_node_boolean() const;
  inline void set_ast_boolean_node_boolean(bool value);

  // optional string AST_string_node_string = 6;
  inline bool has_ast_string_node_string() const;
  inline void clear_ast_string_node_string();
  static const int kASTStringNodeStringFieldNumber = 6;
  inline const ::std::string& ast_string_node_string() const;
  inline void set_ast_string_node_string(const ::std::string& value);
  inline void set_ast_string_node_string(const char* value);
  inline void set_ast_string_node_string(const char* value, size_t size);
  inline ::std::string* mutable_ast_string_node_string();
  inline ::std::string* release_ast_string_node_string();
  inline void set_allocated_ast_string_node_string(::std::string* ast_string_node_string);

  // optional double AST_date_node_dateNum = 7;
  inline bool has_ast_date_node_datenum() const;
  inline void clear_ast_date_node_datenum();
  static const int kASTDateNodeDateNumFieldNumber = 7;
  inline double ast_date_node_datenum() const;
  inline void set_ast_date_node_datenum(double value);

  // optional bool AST_date_node_suppress_date_format = 19;
  inline bool has_ast_date_node_suppress_date_format() const;
  inline void clear_ast_date_node_suppress_date_format();
  static const int kASTDateNodeSuppressDateFormatFieldNumber = 19;
  inline bool ast_date_node_suppress_date_format() const;
  inline void set_ast_date_node_suppress_date_format(bool value);

  // optional bool AST_date_node_suppress_time_format = 20;
  inline bool has_ast_date_node_suppress_time_format() const;
  inline void clear_ast_date_node_suppress_time_format();
  static const int kASTDateNodeSuppressTimeFormatFieldNumber = 20;
  inline bool ast_date_node_suppress_time_format() const;
  inline void set_ast_date_node_suppress_time_format(bool value);

  // optional string AST_date_node_date_time_format = 21;
  inline bool has_ast_date_node_date_time_format() const;
  inline void clear_ast_date_node_date_time_format();
  static const int kASTDateNodeDateTimeFormatFieldNumber = 21;
  inline const ::std::string& ast_date_node_date_time_format() const;
  inline void set_ast_date_node_date_time_format(const ::std::string& value);
  inline void set_ast_date_node_date_time_format(const char* value);
  inline void set_ast_date_node_date_time_format(const char* value, size_t size);
  inline ::std::string* mutable_ast_date_node_date_time_format();
  inline ::std::string* release_ast_date_node_date_time_format();
  inline void set_allocated_ast_date_node_date_time_format(::std::string* ast_date_node_date_time_format);

  // optional double AST_duration_node_unitNum = 8;
  inline bool has_ast_duration_node_unitnum() const;
  inline void clear_ast_duration_node_unitnum();
  static const int kASTDurationNodeUnitNumFieldNumber = 8;
  inline double ast_duration_node_unitnum() const;
  inline void set_ast_duration_node_unitnum(double value);

  // optional int32 AST_duration_node_unit = 9;
  inline bool has_ast_duration_node_unit() const;
  inline void clear_ast_duration_node_unit();
  static const int kASTDurationNodeUnitFieldNumber = 9;
  inline ::google::protobuf::int32 ast_duration_node_unit() const;
  inline void set_ast_duration_node_unit(::google::protobuf::int32 value);

  // optional uint32 AST_duration_node_style = 22;
  inline bool has_ast_duration_node_style() const;
  inline void clear_ast_duration_node_style();
  static const int kASTDurationNodeStyleFieldNumber = 22;
  inline ::google::protobuf::uint32 ast_duration_node_style() const;
  inline void set_ast_duration_node_style(::google::protobuf::uint32 value);

  // optional uint32 AST_duration_node_duration_unit_largest = 23;
  inline bool has_ast_duration_node_duration_unit_largest() const;
  inline void clear_ast_duration_node_duration_unit_largest();
  static const int kASTDurationNodeDurationUnitLargestFieldNumber = 23;
  inline ::google::protobuf::uint32 ast_duration_node_duration_unit_largest() const;
  inline void set_ast_duration_node_duration_unit_largest(::google::protobuf::uint32 value);

  // optional uint32 AST_duration_node_duration_unit_smallest = 24;
  inline bool has_ast_duration_node_duration_unit_smallest() const;
  inline void clear_ast_duration_node_duration_unit_smallest();
  static const int kASTDurationNodeDurationUnitSmallestFieldNumber = 24;
  inline ::google::protobuf::uint32 ast_duration_node_duration_unit_smallest() const;
  inline void set_ast_duration_node_duration_unit_smallest(::google::protobuf::uint32 value);

  // optional bool AST_duration_node_use_automatic_units = 29;
  inline bool has_ast_duration_node_use_automatic_units() const;
  inline void clear_ast_duration_node_use_automatic_units();
  static const int kASTDurationNodeUseAutomaticUnitsFieldNumber = 29;
  inline bool ast_duration_node_use_automatic_units() const;
  inline void set_ast_duration_node_use_automatic_units(bool value);

  // optional bool AST_token_node_boolean = 10;
  inline bool has_ast_token_node_boolean() const;
  inline void clear_ast_token_node_boolean();
  static const int kASTTokenNodeBooleanFieldNumber = 10;
  inline bool ast_token_node_boolean() const;
  inline void set_ast_token_node_boolean(bool value);

  // optional uint32 AST_array_node_numCol = 11;
  inline bool has_ast_array_node_numcol() const;
  inline void clear_ast_array_node_numcol();
  static const int kASTArrayNodeNumColFieldNumber = 11;
  inline ::google::protobuf::uint32 ast_array_node_numcol() const;
  inline void set_ast_array_node_numcol(::google::protobuf::uint32 value);

  // optional uint32 AST_array_node_numRow = 12;
  inline bool has_ast_array_node_numrow() const;
  inline void clear_ast_array_node_numrow();
  static const int kASTArrayNodeNumRowFieldNumber = 12;
  inline ::google::protobuf::uint32 ast_array_node_numrow() const;
  inline void set_ast_array_node_numrow(::google::protobuf::uint32 value);

  // optional uint32 AST_list_node_numArgs = 13;
  inline bool has_ast_list_node_numargs() const;
  inline void clear_ast_list_node_numargs();
  static const int kASTListNodeNumArgsFieldNumber = 13;
  inline ::google::protobuf::uint32 ast_list_node_numargs() const;
  inline void set_ast_list_node_numargs(::google::protobuf::uint32 value);

  // optional .TSCE.ASTNodeArrayArchive AST_thunk_node_array = 14;
  inline bool has_ast_thunk_node_array() const;
  inline void clear_ast_thunk_node_array();
  static const int kASTThunkNodeArrayFieldNumber = 14;
  inline const ::TSCE::ASTNodeArrayArchive& ast_thunk_node_array() const;
  inline ::TSCE::ASTNodeArrayArchive* mutable_ast_thunk_node_array();
  inline ::TSCE::ASTNodeArrayArchive* release_ast_thunk_node_array();
  inline void set_allocated_ast_thunk_node_array(::TSCE::ASTNodeArrayArchive* ast_thunk_node_array);

  // optional .TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive AST_local_cell_reference_node_reference = 15;
  inline bool has_ast_local_cell_reference_node_reference() const;
  inline void clear_ast_local_cell_reference_node_reference();
  static const int kASTLocalCellReferenceNodeReferenceFieldNumber = 15;
  inline const ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& ast_local_cell_reference_node_reference() const;
  inline ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* mutable_ast_local_cell_reference_node_reference();
  inline ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* release_ast_local_cell_reference_node_reference();
  inline void set_allocated_ast_local_cell_reference_node_reference(::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* ast_local_cell_reference_node_reference);

  // optional .TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive AST_cross_table_cell_reference_node_reference = 16;
  inline bool has_ast_cross_table_cell_reference_node_reference() const;
  inline void clear_ast_cross_table_cell_reference_node_reference();
  static const int kASTCrossTableCellReferenceNodeReferenceFieldNumber = 16;
  inline const ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& ast_cross_table_cell_reference_node_reference() const;
  inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* mutable_ast_cross_table_cell_reference_node_reference();
  inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* release_ast_cross_table_cell_reference_node_reference();
  inline void set_allocated_ast_cross_table_cell_reference_node_reference(::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* ast_cross_table_cell_reference_node_reference);

  // optional string AST_unknown_function_node_string = 17;
  inline bool has_ast_unknown_function_node_string() const;
  inline void clear_ast_unknown_function_node_string();
  static const int kASTUnknownFunctionNodeStringFieldNumber = 17;
  inline const ::std::string& ast_unknown_function_node_string() const;
  inline void set_ast_unknown_function_node_string(const ::std::string& value);
  inline void set_ast_unknown_function_node_string(const char* value);
  inline void set_ast_unknown_function_node_string(const char* value, size_t size);
  inline ::std::string* mutable_ast_unknown_function_node_string();
  inline ::std::string* release_ast_unknown_function_node_string();
  inline void set_allocated_ast_unknown_function_node_string(::std::string* ast_unknown_function_node_string);

  // optional uint32 AST_unknown_function_node_numArgs = 18;
  inline bool has_ast_unknown_function_node_numargs() const;
  inline void clear_ast_unknown_function_node_numargs();
  static const int kASTUnknownFunctionNodeNumArgsFieldNumber = 18;
  inline ::google::protobuf::uint32 ast_unknown_function_node_numargs() const;
  inline void set_ast_unknown_function_node_numargs(::google::protobuf::uint32 value);

  // optional string AST_whitespace = 25;
  inline bool has_ast_whitespace() const;
  inline void clear_ast_whitespace();
  static const int kASTWhitespaceFieldNumber = 25;
  inline const ::std::string& ast_whitespace() const;
  inline void set_ast_whitespace(const ::std::string& value);
  inline void set_ast_whitespace(const char* value);
  inline void set_ast_whitespace(const char* value, size_t size);
  inline ::std::string* mutable_ast_whitespace();
  inline ::std::string* release_ast_whitespace();
  inline void set_allocated_ast_whitespace(::std::string* ast_whitespace);

  // optional .TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive AST_column = 26;
  inline bool has_ast_column() const;
  inline void clear_ast_column();
  static const int kASTColumnFieldNumber = 26;
  inline const ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive& ast_column() const;
  inline ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* mutable_ast_column();
  inline ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* release_ast_column();
  inline void set_allocated_ast_column(::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* ast_column);

  // optional .TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive AST_row = 27;
  inline bool has_ast_row() const;
  inline void clear_ast_row();
  static const int kASTRowFieldNumber = 27;
  inline const ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive& ast_row() const;
  inline ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* mutable_ast_row();
  inline ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* release_ast_row();
  inline void set_allocated_ast_row(::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* ast_row);

  // optional .TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive AST_cross_table_reference_extra_info = 28;
  inline bool has_ast_cross_table_reference_extra_info() const;
  inline void clear_ast_cross_table_reference_extra_info();
  static const int kASTCrossTableReferenceExtraInfoFieldNumber = 28;
  inline const ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& ast_cross_table_reference_extra_info() const;
  inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* mutable_ast_cross_table_reference_extra_info();
  inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* release_ast_cross_table_reference_extra_info();
  inline void set_allocated_ast_cross_table_reference_extra_info(::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* ast_cross_table_reference_extra_info);

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive.ASTNodeArchive)
 private:
  inline void set_has_ast_node_type();
  inline void clear_has_ast_node_type();
  inline void set_has_ast_function_node_index();
  inline void clear_has_ast_function_node_index();
  inline void set_has_ast_function_node_numargs();
  inline void clear_has_ast_function_node_numargs();
  inline void set_has_ast_number_node_number();
  inline void clear_has_ast_number_node_number();
  inline void set_has_ast_boolean_node_boolean();
  inline void clear_has_ast_boolean_node_boolean();
  inline void set_has_ast_string_node_string();
  inline void clear_has_ast_string_node_string();
  inline void set_has_ast_date_node_datenum();
  inline void clear_has_ast_date_node_datenum();
  inline void set_has_ast_date_node_suppress_date_format();
  inline void clear_has_ast_date_node_suppress_date_format();
  inline void set_has_ast_date_node_suppress_time_format();
  inline void clear_has_ast_date_node_suppress_time_format();
  inline void set_has_ast_date_node_date_time_format();
  inline void clear_has_ast_date_node_date_time_format();
  inline void set_has_ast_duration_node_unitnum();
  inline void clear_has_ast_duration_node_unitnum();
  inline void set_has_ast_duration_node_unit();
  inline void clear_has_ast_duration_node_unit();
  inline void set_has_ast_duration_node_style();
  inline void clear_has_ast_duration_node_style();
  inline void set_has_ast_duration_node_duration_unit_largest();
  inline void clear_has_ast_duration_node_duration_unit_largest();
  inline void set_has_ast_duration_node_duration_unit_smallest();
  inline void clear_has_ast_duration_node_duration_unit_smallest();
  inline void set_has_ast_duration_node_use_automatic_units();
  inline void clear_has_ast_duration_node_use_automatic_units();
  inline void set_has_ast_token_node_boolean();
  inline void clear_has_ast_token_node_boolean();
  inline void set_has_ast_array_node_numcol();
  inline void clear_has_ast_array_node_numcol();
  inline void set_has_ast_array_node_numrow();
  inline void clear_has_ast_array_node_numrow();
  inline void set_has_ast_list_node_numargs();
  inline void clear_has_ast_list_node_numargs();
  inline void set_has_ast_thunk_node_array();
  inline void clear_has_ast_thunk_node_array();
  inline void set_has_ast_local_cell_reference_node_reference();
  inline void clear_has_ast_local_cell_reference_node_reference();
  inline void set_has_ast_cross_table_cell_reference_node_reference();
  inline void clear_has_ast_cross_table_cell_reference_node_reference();
  inline void set_has_ast_unknown_function_node_string();
  inline void clear_has_ast_unknown_function_node_string();
  inline void set_has_ast_unknown_function_node_numargs();
  inline void clear_has_ast_unknown_function_node_numargs();
  inline void set_has_ast_whitespace();
  inline void clear_has_ast_whitespace();
  inline void set_has_ast_column();
  inline void clear_has_ast_column();
  inline void set_has_ast_row();
  inline void clear_has_ast_row();
  inline void set_has_ast_cross_table_reference_extra_info();
  inline void clear_has_ast_cross_table_reference_extra_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ast_node_type_;
  ::google::protobuf::uint32 ast_function_node_index_;
  double ast_number_node_number_;
  ::std::string* ast_string_node_string_;
  double ast_date_node_datenum_;
  ::google::protobuf::uint32 ast_function_node_numargs_;
  bool ast_boolean_node_boolean_;
  bool ast_date_node_suppress_date_format_;
  bool ast_date_node_suppress_time_format_;
  bool ast_duration_node_use_automatic_units_;
  ::std::string* ast_date_node_date_time_format_;
  double ast_duration_node_unitnum_;
  ::google::protobuf::int32 ast_duration_node_unit_;
  ::google::protobuf::uint32 ast_duration_node_style_;
  ::google::protobuf::uint32 ast_duration_node_duration_unit_largest_;
  ::google::protobuf::uint32 ast_duration_node_duration_unit_smallest_;
  bool ast_token_node_boolean_;
  ::google::protobuf::uint32 ast_array_node_numcol_;
  ::google::protobuf::uint32 ast_array_node_numrow_;
  ::google::protobuf::uint32 ast_list_node_numargs_;
  ::TSCE::ASTNodeArrayArchive* ast_thunk_node_array_;
  ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* ast_local_cell_reference_node_reference_;
  ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* ast_cross_table_cell_reference_node_reference_;
  ::std::string* ast_unknown_function_node_string_;
  ::std::string* ast_whitespace_;
  ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* ast_column_;
  ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* ast_row_;
  ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* ast_cross_table_reference_extra_info_;
  ::google::protobuf::uint32 ast_unknown_function_node_numargs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive_ASTNodeArchive* default_instance_;
};
// -------------------------------------------------------------------

class ASTNodeArrayArchive : public ::google::protobuf::Message {
 public:
  ASTNodeArrayArchive();
  virtual ~ASTNodeArrayArchive();

  ASTNodeArrayArchive(const ASTNodeArrayArchive& from);

  inline ASTNodeArrayArchive& operator=(const ASTNodeArrayArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ASTNodeArrayArchive& default_instance();

  void Swap(ASTNodeArrayArchive* other);

  // implements Message ----------------------------------------------

  ASTNodeArrayArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ASTNodeArrayArchive& from);
  void MergeFrom(const ASTNodeArrayArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive ASTLocalCellReferenceNodeArchive;
  typedef ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive ASTCrossTableCellReferenceNodeArchive;
  typedef ASTNodeArrayArchive_ASTColumnCoordinateArchive ASTColumnCoordinateArchive;
  typedef ASTNodeArrayArchive_ASTRowCoordinateArchive ASTRowCoordinateArchive;
  typedef ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive ASTCrossTableReferenceExtraInfoArchive;
  typedef ASTNodeArrayArchive_ASTNodeArchive ASTNodeArchive;

  typedef ASTNodeArrayArchive_ASTNodeType ASTNodeType;
  static const ASTNodeType ADDITION_NODE = ASTNodeArrayArchive_ASTNodeType_ADDITION_NODE;
  static const ASTNodeType SUBTRACTION_NODE = ASTNodeArrayArchive_ASTNodeType_SUBTRACTION_NODE;
  static const ASTNodeType MULTIPLICATION_NODE = ASTNodeArrayArchive_ASTNodeType_MULTIPLICATION_NODE;
  static const ASTNodeType DIVISION_NODE = ASTNodeArrayArchive_ASTNodeType_DIVISION_NODE;
  static const ASTNodeType POWER_NODE = ASTNodeArrayArchive_ASTNodeType_POWER_NODE;
  static const ASTNodeType CONCATENATION_NODE = ASTNodeArrayArchive_ASTNodeType_CONCATENATION_NODE;
  static const ASTNodeType GREATER_THAN_NODE = ASTNodeArrayArchive_ASTNodeType_GREATER_THAN_NODE;
  static const ASTNodeType GREATER_THAN_OR_EQUAL_TO_NODE = ASTNodeArrayArchive_ASTNodeType_GREATER_THAN_OR_EQUAL_TO_NODE;
  static const ASTNodeType LESS_THAN_NODE = ASTNodeArrayArchive_ASTNodeType_LESS_THAN_NODE;
  static const ASTNodeType LESS_THAN_OR_EQUAL_TO_NODE = ASTNodeArrayArchive_ASTNodeType_LESS_THAN_OR_EQUAL_TO_NODE;
  static const ASTNodeType EQUAL_TO_NODE = ASTNodeArrayArchive_ASTNodeType_EQUAL_TO_NODE;
  static const ASTNodeType NOT_EQUAL_TO_NODE = ASTNodeArrayArchive_ASTNodeType_NOT_EQUAL_TO_NODE;
  static const ASTNodeType NEGATION_NODE = ASTNodeArrayArchive_ASTNodeType_NEGATION_NODE;
  static const ASTNodeType PLUS_SIGN_NODE = ASTNodeArrayArchive_ASTNodeType_PLUS_SIGN_NODE;
  static const ASTNodeType PERCENT_NODE = ASTNodeArrayArchive_ASTNodeType_PERCENT_NODE;
  static const ASTNodeType FUNCTION_NODE = ASTNodeArrayArchive_ASTNodeType_FUNCTION_NODE;
  static const ASTNodeType NUMBER_NODE = ASTNodeArrayArchive_ASTNodeType_NUMBER_NODE;
  static const ASTNodeType BOOLEAN_NODE = ASTNodeArrayArchive_ASTNodeType_BOOLEAN_NODE;
  static const ASTNodeType STRING_NODE = ASTNodeArrayArchive_ASTNodeType_STRING_NODE;
  static const ASTNodeType DATE_NODE = ASTNodeArrayArchive_ASTNodeType_DATE_NODE;
  static const ASTNodeType DURATION_NODE = ASTNodeArrayArchive_ASTNodeType_DURATION_NODE;
  static const ASTNodeType EMPTY_ARGUMENT_NODE = ASTNodeArrayArchive_ASTNodeType_EMPTY_ARGUMENT_NODE;
  static const ASTNodeType TOKEN_NODE = ASTNodeArrayArchive_ASTNodeType_TOKEN_NODE;
  static const ASTNodeType ARRAY_NODE = ASTNodeArrayArchive_ASTNodeType_ARRAY_NODE;
  static const ASTNodeType LIST_NODE = ASTNodeArrayArchive_ASTNodeType_LIST_NODE;
  static const ASTNodeType THUNK_NODE = ASTNodeArrayArchive_ASTNodeType_THUNK_NODE;
  static const ASTNodeType LOCAL_CELL_REFERENCE_NODE = ASTNodeArrayArchive_ASTNodeType_LOCAL_CELL_REFERENCE_NODE;
  static const ASTNodeType CROSS_TABLE_CELL_REFERENCE_NODE = ASTNodeArrayArchive_ASTNodeType_CROSS_TABLE_CELL_REFERENCE_NODE;
  static const ASTNodeType COLON_NODE = ASTNodeArrayArchive_ASTNodeType_COLON_NODE;
  static const ASTNodeType REFERENCE_ERROR_NODE = ASTNodeArrayArchive_ASTNodeType_REFERENCE_ERROR_NODE;
  static const ASTNodeType UNKNOWN_FUNCTION_NODE = ASTNodeArrayArchive_ASTNodeType_UNKNOWN_FUNCTION_NODE;
  static const ASTNodeType APPEND_WHITESPACE_NODE = ASTNodeArrayArchive_ASTNodeType_APPEND_WHITESPACE_NODE;
  static const ASTNodeType PREPEND_WHITESPACE_NODE = ASTNodeArrayArchive_ASTNodeType_PREPEND_WHITESPACE_NODE;
  static const ASTNodeType BEGIN_THUNK_NODE = ASTNodeArrayArchive_ASTNodeType_BEGIN_THUNK_NODE;
  static const ASTNodeType END_THUNK_NODE = ASTNodeArrayArchive_ASTNodeType_END_THUNK_NODE;
  static const ASTNodeType CELL_REFERENCE_NODE = ASTNodeArrayArchive_ASTNodeType_CELL_REFERENCE_NODE;
  static inline bool ASTNodeType_IsValid(int value) {
    return ASTNodeArrayArchive_ASTNodeType_IsValid(value);
  }
  static const ASTNodeType ASTNodeType_MIN =
    ASTNodeArrayArchive_ASTNodeType_ASTNodeType_MIN;
  static const ASTNodeType ASTNodeType_MAX =
    ASTNodeArrayArchive_ASTNodeType_ASTNodeType_MAX;
  static const int ASTNodeType_ARRAYSIZE =
    ASTNodeArrayArchive_ASTNodeType_ASTNodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ASTNodeType_descriptor() {
    return ASTNodeArrayArchive_ASTNodeType_descriptor();
  }
  static inline const ::std::string& ASTNodeType_Name(ASTNodeType value) {
    return ASTNodeArrayArchive_ASTNodeType_Name(value);
  }
  static inline bool ASTNodeType_Parse(const ::std::string& name,
      ASTNodeType* value) {
    return ASTNodeArrayArchive_ASTNodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TSCE.ASTNodeArrayArchive.ASTNodeArchive AST_node = 1;
  inline int ast_node_size() const;
  inline void clear_ast_node();
  static const int kASTNodeFieldNumber = 1;
  inline const ::TSCE::ASTNodeArrayArchive_ASTNodeArchive& ast_node(int index) const;
  inline ::TSCE::ASTNodeArrayArchive_ASTNodeArchive* mutable_ast_node(int index);
  inline ::TSCE::ASTNodeArrayArchive_ASTNodeArchive* add_ast_node();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::ASTNodeArrayArchive_ASTNodeArchive >&
      ast_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::ASTNodeArrayArchive_ASTNodeArchive >*
      mutable_ast_node();

  // @@protoc_insertion_point(class_scope:TSCE.ASTNodeArrayArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::ASTNodeArrayArchive_ASTNodeArchive > ast_node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ASTNodeArrayArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaTranslationFlagsArchive : public ::google::protobuf::Message {
 public:
  FormulaTranslationFlagsArchive();
  virtual ~FormulaTranslationFlagsArchive();

  FormulaTranslationFlagsArchive(const FormulaTranslationFlagsArchive& from);

  inline FormulaTranslationFlagsArchive& operator=(const FormulaTranslationFlagsArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaTranslationFlagsArchive& default_instance();

  void Swap(FormulaTranslationFlagsArchive* other);

  // implements Message ----------------------------------------------

  FormulaTranslationFlagsArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaTranslationFlagsArchive& from);
  void MergeFrom(const FormulaTranslationFlagsArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool excel_import_translation = 1 [default = false];
  inline bool has_excel_import_translation() const;
  inline void clear_excel_import_translation();
  static const int kExcelImportTranslationFieldNumber = 1;
  inline bool excel_import_translation() const;
  inline void set_excel_import_translation(bool value);

  // optional bool number_to_date_coercion_removal_translation = 2 [default = false];
  inline bool has_number_to_date_coercion_removal_translation() const;
  inline void clear_number_to_date_coercion_removal_translation();
  static const int kNumberToDateCoercionRemovalTranslationFieldNumber = 2;
  inline bool number_to_date_coercion_removal_translation() const;
  inline void set_number_to_date_coercion_removal_translation(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.FormulaTranslationFlagsArchive)
 private:
  inline void set_has_excel_import_translation();
  inline void clear_has_excel_import_translation();
  inline void set_has_number_to_date_coercion_removal_translation();
  inline void clear_has_number_to_date_coercion_removal_translation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool excel_import_translation_;
  bool number_to_date_coercion_removal_translation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaTranslationFlagsArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaArchive : public ::google::protobuf::Message {
 public:
  FormulaArchive();
  virtual ~FormulaArchive();

  FormulaArchive(const FormulaArchive& from);

  inline FormulaArchive& operator=(const FormulaArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaArchive& default_instance();

  void Swap(FormulaArchive* other);

  // implements Message ----------------------------------------------

  FormulaArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaArchive& from);
  void MergeFrom(const FormulaArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.ASTNodeArrayArchive AST_node_array = 1;
  inline bool has_ast_node_array() const;
  inline void clear_ast_node_array();
  static const int kASTNodeArrayFieldNumber = 1;
  inline const ::TSCE::ASTNodeArrayArchive& ast_node_array() const;
  inline ::TSCE::ASTNodeArrayArchive* mutable_ast_node_array();
  inline ::TSCE::ASTNodeArrayArchive* release_ast_node_array();
  inline void set_allocated_ast_node_array(::TSCE::ASTNodeArrayArchive* ast_node_array);

  // optional uint32 host_column = 2;
  inline bool has_host_column() const;
  inline void clear_host_column();
  static const int kHostColumnFieldNumber = 2;
  inline ::google::protobuf::uint32 host_column() const;
  inline void set_host_column(::google::protobuf::uint32 value);

  // optional uint32 host_row = 3;
  inline bool has_host_row() const;
  inline void clear_host_row();
  static const int kHostRowFieldNumber = 3;
  inline ::google::protobuf::uint32 host_row() const;
  inline void set_host_row(::google::protobuf::uint32 value);

  // optional bool host_column_is_negative = 4 [default = false];
  inline bool has_host_column_is_negative() const;
  inline void clear_host_column_is_negative();
  static const int kHostColumnIsNegativeFieldNumber = 4;
  inline bool host_column_is_negative() const;
  inline void set_host_column_is_negative(bool value);

  // optional bool host_row_is_negative = 5 [default = false];
  inline bool has_host_row_is_negative() const;
  inline void clear_host_row_is_negative();
  static const int kHostRowIsNegativeFieldNumber = 5;
  inline bool host_row_is_negative() const;
  inline void set_host_row_is_negative(bool value);

  // optional .TSCE.FormulaTranslationFlagsArchive translation_flags = 6;
  inline bool has_translation_flags() const;
  inline void clear_translation_flags();
  static const int kTranslationFlagsFieldNumber = 6;
  inline const ::TSCE::FormulaTranslationFlagsArchive& translation_flags() const;
  inline ::TSCE::FormulaTranslationFlagsArchive* mutable_translation_flags();
  inline ::TSCE::FormulaTranslationFlagsArchive* release_translation_flags();
  inline void set_allocated_translation_flags(::TSCE::FormulaTranslationFlagsArchive* translation_flags);

  // @@protoc_insertion_point(class_scope:TSCE.FormulaArchive)
 private:
  inline void set_has_ast_node_array();
  inline void clear_has_ast_node_array();
  inline void set_has_host_column();
  inline void clear_has_host_column();
  inline void set_has_host_row();
  inline void clear_has_host_row();
  inline void set_has_host_column_is_negative();
  inline void clear_has_host_column_is_negative();
  inline void set_has_host_row_is_negative();
  inline void clear_has_host_row_is_negative();
  inline void set_has_translation_flags();
  inline void clear_has_translation_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::ASTNodeArrayArchive* ast_node_array_;
  ::google::protobuf::uint32 host_column_;
  ::google::protobuf::uint32 host_row_;
  ::TSCE::FormulaTranslationFlagsArchive* translation_flags_;
  bool host_column_is_negative_;
  bool host_row_is_negative_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormatStructArchive : public ::google::protobuf::Message {
 public:
  FormatStructArchive();
  virtual ~FormatStructArchive();

  FormatStructArchive(const FormatStructArchive& from);

  inline FormatStructArchive& operator=(const FormatStructArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatStructArchive& default_instance();

  void Swap(FormatStructArchive* other);

  // implements Message ----------------------------------------------

  FormatStructArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormatStructArchive& from);
  void MergeFrom(const FormatStructArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 format_type = 1;
  inline bool has_format_type() const;
  inline void clear_format_type();
  static const int kFormatTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 format_type() const;
  inline void set_format_type(::google::protobuf::uint32 value);

  // optional uint32 decimal_places = 2;
  inline bool has_decimal_places() const;
  inline void clear_decimal_places();
  static const int kDecimalPlacesFieldNumber = 2;
  inline ::google::protobuf::uint32 decimal_places() const;
  inline void set_decimal_places(::google::protobuf::uint32 value);

  // optional string currency_code = 3;
  inline bool has_currency_code() const;
  inline void clear_currency_code();
  static const int kCurrencyCodeFieldNumber = 3;
  inline const ::std::string& currency_code() const;
  inline void set_currency_code(const ::std::string& value);
  inline void set_currency_code(const char* value);
  inline void set_currency_code(const char* value, size_t size);
  inline ::std::string* mutable_currency_code();
  inline ::std::string* release_currency_code();
  inline void set_allocated_currency_code(::std::string* currency_code);

  // optional uint32 negative_style = 4;
  inline bool has_negative_style() const;
  inline void clear_negative_style();
  static const int kNegativeStyleFieldNumber = 4;
  inline ::google::protobuf::uint32 negative_style() const;
  inline void set_negative_style(::google::protobuf::uint32 value);

  // optional bool show_thousands_separator = 5;
  inline bool has_show_thousands_separator() const;
  inline void clear_show_thousands_separator();
  static const int kShowThousandsSeparatorFieldNumber = 5;
  inline bool show_thousands_separator() const;
  inline void set_show_thousands_separator(bool value);

  // optional bool use_accounting_style = 6;
  inline bool has_use_accounting_style() const;
  inline void clear_use_accounting_style();
  static const int kUseAccountingStyleFieldNumber = 6;
  inline bool use_accounting_style() const;
  inline void set_use_accounting_style(bool value);

  // optional uint32 duration_style = 7;
  inline bool has_duration_style() const;
  inline void clear_duration_style();
  static const int kDurationStyleFieldNumber = 7;
  inline ::google::protobuf::uint32 duration_style() const;
  inline void set_duration_style(::google::protobuf::uint32 value);

  // optional uint32 base = 8;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 8;
  inline ::google::protobuf::uint32 base() const;
  inline void set_base(::google::protobuf::uint32 value);

  // optional uint32 base_places = 9;
  inline bool has_base_places() const;
  inline void clear_base_places();
  static const int kBasePlacesFieldNumber = 9;
  inline ::google::protobuf::uint32 base_places() const;
  inline void set_base_places(::google::protobuf::uint32 value);

  // optional bool base_use_minus_sign = 10;
  inline bool has_base_use_minus_sign() const;
  inline void clear_base_use_minus_sign();
  static const int kBaseUseMinusSignFieldNumber = 10;
  inline bool base_use_minus_sign() const;
  inline void set_base_use_minus_sign(bool value);

  // optional uint32 fraction_accuracy = 11;
  inline bool has_fraction_accuracy() const;
  inline void clear_fraction_accuracy();
  static const int kFractionAccuracyFieldNumber = 11;
  inline ::google::protobuf::uint32 fraction_accuracy() const;
  inline void set_fraction_accuracy(::google::protobuf::uint32 value);

  // optional bool suppress_date_format = 12;
  inline bool has_suppress_date_format() const;
  inline void clear_suppress_date_format();
  static const int kSuppressDateFormatFieldNumber = 12;
  inline bool suppress_date_format() const;
  inline void set_suppress_date_format(bool value);

  // optional bool suppress_time_format = 13;
  inline bool has_suppress_time_format() const;
  inline void clear_suppress_time_format();
  static const int kSuppressTimeFormatFieldNumber = 13;
  inline bool suppress_time_format() const;
  inline void set_suppress_time_format(bool value);

  // optional string date_time_format = 14;
  inline bool has_date_time_format() const;
  inline void clear_date_time_format();
  static const int kDateTimeFormatFieldNumber = 14;
  inline const ::std::string& date_time_format() const;
  inline void set_date_time_format(const ::std::string& value);
  inline void set_date_time_format(const char* value);
  inline void set_date_time_format(const char* value, size_t size);
  inline ::std::string* mutable_date_time_format();
  inline ::std::string* release_date_time_format();
  inline void set_allocated_date_time_format(::std::string* date_time_format);

  // optional uint32 duration_unit_largest = 15;
  inline bool has_duration_unit_largest() const;
  inline void clear_duration_unit_largest();
  static const int kDurationUnitLargestFieldNumber = 15;
  inline ::google::protobuf::uint32 duration_unit_largest() const;
  inline void set_duration_unit_largest(::google::protobuf::uint32 value);

  // optional uint32 duration_unit_smallest = 16;
  inline bool has_duration_unit_smallest() const;
  inline void clear_duration_unit_smallest();
  static const int kDurationUnitSmallestFieldNumber = 16;
  inline ::google::protobuf::uint32 duration_unit_smallest() const;
  inline void set_duration_unit_smallest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.FormatStructArchive)
 private:
  inline void set_has_format_type();
  inline void clear_has_format_type();
  inline void set_has_decimal_places();
  inline void clear_has_decimal_places();
  inline void set_has_currency_code();
  inline void clear_has_currency_code();
  inline void set_has_negative_style();
  inline void clear_has_negative_style();
  inline void set_has_show_thousands_separator();
  inline void clear_has_show_thousands_separator();
  inline void set_has_use_accounting_style();
  inline void clear_has_use_accounting_style();
  inline void set_has_duration_style();
  inline void clear_has_duration_style();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_base_places();
  inline void clear_has_base_places();
  inline void set_has_base_use_minus_sign();
  inline void clear_has_base_use_minus_sign();
  inline void set_has_fraction_accuracy();
  inline void clear_has_fraction_accuracy();
  inline void set_has_suppress_date_format();
  inline void clear_has_suppress_date_format();
  inline void set_has_suppress_time_format();
  inline void clear_has_suppress_time_format();
  inline void set_has_date_time_format();
  inline void clear_has_date_time_format();
  inline void set_has_duration_unit_largest();
  inline void clear_has_duration_unit_largest();
  inline void set_has_duration_unit_smallest();
  inline void clear_has_duration_unit_smallest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 format_type_;
  ::google::protobuf::uint32 decimal_places_;
  ::std::string* currency_code_;
  ::google::protobuf::uint32 negative_style_;
  ::google::protobuf::uint32 duration_style_;
  ::google::protobuf::uint32 base_;
  bool show_thousands_separator_;
  bool use_accounting_style_;
  bool base_use_minus_sign_;
  bool suppress_date_format_;
  ::google::protobuf::uint32 base_places_;
  ::google::protobuf::uint32 fraction_accuracy_;
  ::std::string* date_time_format_;
  bool suppress_time_format_;
  ::google::protobuf::uint32 duration_unit_largest_;
  ::google::protobuf::uint32 duration_unit_smallest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static FormatStructArchive* default_instance_;
};
// -------------------------------------------------------------------

class RangeCoordinateArchive : public ::google::protobuf::Message {
 public:
  RangeCoordinateArchive();
  virtual ~RangeCoordinateArchive();

  RangeCoordinateArchive(const RangeCoordinateArchive& from);

  inline RangeCoordinateArchive& operator=(const RangeCoordinateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeCoordinateArchive& default_instance();

  void Swap(RangeCoordinateArchive* other);

  // implements Message ----------------------------------------------

  RangeCoordinateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeCoordinateArchive& from);
  void MergeFrom(const RangeCoordinateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 top_left_column = 1;
  inline bool has_top_left_column() const;
  inline void clear_top_left_column();
  static const int kTopLeftColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 top_left_column() const;
  inline void set_top_left_column(::google::protobuf::uint32 value);

  // required uint32 top_left_row = 2;
  inline bool has_top_left_row() const;
  inline void clear_top_left_row();
  static const int kTopLeftRowFieldNumber = 2;
  inline ::google::protobuf::uint32 top_left_row() const;
  inline void set_top_left_row(::google::protobuf::uint32 value);

  // required uint32 bottom_right_column = 3;
  inline bool has_bottom_right_column() const;
  inline void clear_bottom_right_column();
  static const int kBottomRightColumnFieldNumber = 3;
  inline ::google::protobuf::uint32 bottom_right_column() const;
  inline void set_bottom_right_column(::google::protobuf::uint32 value);

  // required uint32 bottom_right_row = 4;
  inline bool has_bottom_right_row() const;
  inline void clear_bottom_right_row();
  static const int kBottomRightRowFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom_right_row() const;
  inline void set_bottom_right_row(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.RangeCoordinateArchive)
 private:
  inline void set_has_top_left_column();
  inline void clear_has_top_left_column();
  inline void set_has_top_left_row();
  inline void clear_has_top_left_row();
  inline void set_has_bottom_right_column();
  inline void clear_has_bottom_right_column();
  inline void set_has_bottom_right_row();
  inline void clear_has_bottom_right_row();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 top_left_column_;
  ::google::protobuf::uint32 top_left_row_;
  ::google::protobuf::uint32 bottom_right_column_;
  ::google::protobuf::uint32 bottom_right_row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RangeCoordinateArchive* default_instance_;
};
// -------------------------------------------------------------------

class TectonicShiftArchive : public ::google::protobuf::Message {
 public:
  TectonicShiftArchive();
  virtual ~TectonicShiftArchive();

  TectonicShiftArchive(const TectonicShiftArchive& from);

  inline TectonicShiftArchive& operator=(const TectonicShiftArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TectonicShiftArchive& default_instance();

  void Swap(TectonicShiftArchive* other);

  // implements Message ----------------------------------------------

  TectonicShiftArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TectonicShiftArchive& from);
  void MergeFrom(const TectonicShiftArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 grid_coordinate_offset_x = 1;
  inline bool has_grid_coordinate_offset_x() const;
  inline void clear_grid_coordinate_offset_x();
  static const int kGridCoordinateOffsetXFieldNumber = 1;
  inline ::google::protobuf::uint32 grid_coordinate_offset_x() const;
  inline void set_grid_coordinate_offset_x(::google::protobuf::uint32 value);

  // required uint32 grid_coordinate_offset_y = 2;
  inline bool has_grid_coordinate_offset_y() const;
  inline void clear_grid_coordinate_offset_y();
  static const int kGridCoordinateOffsetYFieldNumber = 2;
  inline ::google::protobuf::uint32 grid_coordinate_offset_y() const;
  inline void set_grid_coordinate_offset_y(::google::protobuf::uint32 value);

  // required bool grid_coordinate_offset_x_is_negative = 3;
  inline bool has_grid_coordinate_offset_x_is_negative() const;
  inline void clear_grid_coordinate_offset_x_is_negative();
  static const int kGridCoordinateOffsetXIsNegativeFieldNumber = 3;
  inline bool grid_coordinate_offset_x_is_negative() const;
  inline void set_grid_coordinate_offset_x_is_negative(bool value);

  // required bool grid_coordinate_offset_y_is_negative = 4;
  inline bool has_grid_coordinate_offset_y_is_negative() const;
  inline void clear_grid_coordinate_offset_y_is_negative();
  static const int kGridCoordinateOffsetYIsNegativeFieldNumber = 4;
  inline bool grid_coordinate_offset_y_is_negative() const;
  inline void set_grid_coordinate_offset_y_is_negative(bool value);

  // optional .TSCE.RangeCoordinateArchive range_for_shift = 5;
  inline bool has_range_for_shift() const;
  inline void clear_range_for_shift();
  static const int kRangeForShiftFieldNumber = 5;
  inline const ::TSCE::RangeCoordinateArchive& range_for_shift() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_range_for_shift();
  inline ::TSCE::RangeCoordinateArchive* release_range_for_shift();
  inline void set_allocated_range_for_shift(::TSCE::RangeCoordinateArchive* range_for_shift);

  // optional .TSCE.RangeCoordinateArchive range_for_deletion = 6;
  inline bool has_range_for_deletion() const;
  inline void clear_range_for_deletion();
  static const int kRangeForDeletionFieldNumber = 6;
  inline const ::TSCE::RangeCoordinateArchive& range_for_deletion() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_range_for_deletion();
  inline ::TSCE::RangeCoordinateArchive* release_range_for_deletion();
  inline void set_allocated_range_for_deletion(::TSCE::RangeCoordinateArchive* range_for_deletion);

  // optional .TSCE.RangeCoordinateArchive inserted_range = 7;
  inline bool has_inserted_range() const;
  inline void clear_inserted_range();
  static const int kInsertedRangeFieldNumber = 7;
  inline const ::TSCE::RangeCoordinateArchive& inserted_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_inserted_range();
  inline ::TSCE::RangeCoordinateArchive* release_inserted_range();
  inline void set_allocated_inserted_range(::TSCE::RangeCoordinateArchive* inserted_range);

  // required bool apply_to_absolute = 8;
  inline bool has_apply_to_absolute() const;
  inline void clear_apply_to_absolute();
  static const int kApplyToAbsoluteFieldNumber = 8;
  inline bool apply_to_absolute() const;
  inline void set_apply_to_absolute(bool value);

  // required bool inserting_after = 9;
  inline bool has_inserting_after() const;
  inline void clear_inserting_after();
  static const int kInsertingAfterFieldNumber = 9;
  inline bool inserting_after() const;
  inline void set_inserting_after(bool value);

  // required bool ignore_sticky_bits = 10;
  inline bool has_ignore_sticky_bits() const;
  inline void clear_ignore_sticky_bits();
  static const int kIgnoreStickyBitsFieldNumber = 10;
  inline bool ignore_sticky_bits() const;
  inline void set_ignore_sticky_bits(bool value);

  // optional .TSCE.RangeCoordinateArchive table_range = 11;
  inline bool has_table_range() const;
  inline void clear_table_range();
  static const int kTableRangeFieldNumber = 11;
  inline const ::TSCE::RangeCoordinateArchive& table_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_table_range();
  inline ::TSCE::RangeCoordinateArchive* release_table_range();
  inline void set_allocated_table_range(::TSCE::RangeCoordinateArchive* table_range);

  // optional .TSCE.CFUUIDArchive table_id = 12;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 12;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // @@protoc_insertion_point(class_scope:TSCE.TectonicShiftArchive)
 private:
  inline void set_has_grid_coordinate_offset_x();
  inline void clear_has_grid_coordinate_offset_x();
  inline void set_has_grid_coordinate_offset_y();
  inline void clear_has_grid_coordinate_offset_y();
  inline void set_has_grid_coordinate_offset_x_is_negative();
  inline void clear_has_grid_coordinate_offset_x_is_negative();
  inline void set_has_grid_coordinate_offset_y_is_negative();
  inline void clear_has_grid_coordinate_offset_y_is_negative();
  inline void set_has_range_for_shift();
  inline void clear_has_range_for_shift();
  inline void set_has_range_for_deletion();
  inline void clear_has_range_for_deletion();
  inline void set_has_inserted_range();
  inline void clear_has_inserted_range();
  inline void set_has_apply_to_absolute();
  inline void clear_has_apply_to_absolute();
  inline void set_has_inserting_after();
  inline void clear_has_inserting_after();
  inline void set_has_ignore_sticky_bits();
  inline void clear_has_ignore_sticky_bits();
  inline void set_has_table_range();
  inline void clear_has_table_range();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 grid_coordinate_offset_x_;
  ::google::protobuf::uint32 grid_coordinate_offset_y_;
  ::TSCE::RangeCoordinateArchive* range_for_shift_;
  ::TSCE::RangeCoordinateArchive* range_for_deletion_;
  bool grid_coordinate_offset_x_is_negative_;
  bool grid_coordinate_offset_y_is_negative_;
  bool apply_to_absolute_;
  bool inserting_after_;
  bool ignore_sticky_bits_;
  ::TSCE::RangeCoordinateArchive* inserted_range_;
  ::TSCE::RangeCoordinateArchive* table_range_;
  ::TSCE::CFUUIDArchive* table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static TectonicShiftArchive* default_instance_;
};
// -------------------------------------------------------------------

class RewriteSortMappingArchive : public ::google::protobuf::Message {
 public:
  RewriteSortMappingArchive();
  virtual ~RewriteSortMappingArchive();

  RewriteSortMappingArchive(const RewriteSortMappingArchive& from);

  inline RewriteSortMappingArchive& operator=(const RewriteSortMappingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RewriteSortMappingArchive& default_instance();

  void Swap(RewriteSortMappingArchive* other);

  // implements Message ----------------------------------------------

  RewriteSortMappingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RewriteSortMappingArchive& from);
  void MergeFrom(const RewriteSortMappingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // required .TSK.ShuffleMappingArchive shuffle_mapping = 2;
  inline bool has_shuffle_mapping() const;
  inline void clear_shuffle_mapping();
  static const int kShuffleMappingFieldNumber = 2;
  inline const ::TSK::ShuffleMappingArchive& shuffle_mapping() const;
  inline ::TSK::ShuffleMappingArchive* mutable_shuffle_mapping();
  inline ::TSK::ShuffleMappingArchive* release_shuffle_mapping();
  inline void set_allocated_shuffle_mapping(::TSK::ShuffleMappingArchive* shuffle_mapping);

  // required bool explode_ranges = 3;
  inline bool has_explode_ranges() const;
  inline void clear_explode_ranges();
  static const int kExplodeRangesFieldNumber = 3;
  inline bool explode_ranges() const;
  inline void set_explode_ranges(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.RewriteSortMappingArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_shuffle_mapping();
  inline void clear_has_shuffle_mapping();
  inline void set_has_explode_ranges();
  inline void clear_has_explode_ranges();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::TSK::ShuffleMappingArchive* shuffle_mapping_;
  bool explode_ranges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RewriteSortMappingArchive* default_instance_;
};
// -------------------------------------------------------------------

class RangeMovedInfoArchive : public ::google::protobuf::Message {
 public:
  RangeMovedInfoArchive();
  virtual ~RangeMovedInfoArchive();

  RangeMovedInfoArchive(const RangeMovedInfoArchive& from);

  inline RangeMovedInfoArchive& operator=(const RangeMovedInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeMovedInfoArchive& default_instance();

  void Swap(RangeMovedInfoArchive* other);

  // implements Message ----------------------------------------------

  RangeMovedInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeMovedInfoArchive& from);
  void MergeFrom(const RangeMovedInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // optional .TSCE.RangeCoordinateArchive from_range = 2;
  inline bool has_from_range() const;
  inline void clear_from_range();
  static const int kFromRangeFieldNumber = 2;
  inline const ::TSCE::RangeCoordinateArchive& from_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_from_range();
  inline ::TSCE::RangeCoordinateArchive* release_from_range();
  inline void set_allocated_from_range(::TSCE::RangeCoordinateArchive* from_range);

  // optional .TSCE.RangeCoordinateArchive to_range = 3;
  inline bool has_to_range() const;
  inline void clear_to_range();
  static const int kToRangeFieldNumber = 3;
  inline const ::TSCE::RangeCoordinateArchive& to_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_to_range();
  inline ::TSCE::RangeCoordinateArchive* release_to_range();
  inline void set_allocated_to_range(::TSCE::RangeCoordinateArchive* to_range);

  // optional .TSCE.RangeReferenceArchive from_range_reference = 4;
  inline bool has_from_range_reference() const;
  inline void clear_from_range_reference();
  static const int kFromRangeReferenceFieldNumber = 4;
  inline const ::TSCE::RangeReferenceArchive& from_range_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_from_range_reference();
  inline ::TSCE::RangeReferenceArchive* release_from_range_reference();
  inline void set_allocated_from_range_reference(::TSCE::RangeReferenceArchive* from_range_reference);

  // optional .TSCE.RangeReferenceArchive to_range_reference = 5;
  inline bool has_to_range_reference() const;
  inline void clear_to_range_reference();
  static const int kToRangeReferenceFieldNumber = 5;
  inline const ::TSCE::RangeReferenceArchive& to_range_reference() const;
  inline ::TSCE::RangeReferenceArchive* mutable_to_range_reference();
  inline ::TSCE::RangeReferenceArchive* release_to_range_reference();
  inline void set_allocated_to_range_reference(::TSCE::RangeReferenceArchive* to_range_reference);

  // @@protoc_insertion_point(class_scope:TSCE.RangeMovedInfoArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_from_range();
  inline void clear_has_from_range();
  inline void set_has_to_range();
  inline void clear_has_to_range();
  inline void set_has_from_range_reference();
  inline void clear_has_from_range_reference();
  inline void set_has_to_range_reference();
  inline void clear_has_to_range_reference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::TSCE::RangeCoordinateArchive* from_range_;
  ::TSCE::RangeCoordinateArchive* to_range_;
  ::TSCE::RangeReferenceArchive* from_range_reference_;
  ::TSCE::RangeReferenceArchive* to_range_reference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static RangeMovedInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class TableResizedInfoArchive : public ::google::protobuf::Message {
 public:
  TableResizedInfoArchive();
  virtual ~TableResizedInfoArchive();

  TableResizedInfoArchive(const TableResizedInfoArchive& from);

  inline TableResizedInfoArchive& operator=(const TableResizedInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableResizedInfoArchive& default_instance();

  void Swap(TableResizedInfoArchive* other);

  // implements Message ----------------------------------------------

  TableResizedInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableResizedInfoArchive& from);
  void MergeFrom(const TableResizedInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // required .TSCE.RangeCoordinateArchive new_table_size = 2;
  inline bool has_new_table_size() const;
  inline void clear_new_table_size();
  static const int kNewTableSizeFieldNumber = 2;
  inline const ::TSCE::RangeCoordinateArchive& new_table_size() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_new_table_size();
  inline ::TSCE::RangeCoordinateArchive* release_new_table_size();
  inline void set_allocated_new_table_size(::TSCE::RangeCoordinateArchive* new_table_size);

  // optional .TSCE.RangeCoordinateArchive old_table_size = 3;
  inline bool has_old_table_size() const;
  inline void clear_old_table_size();
  static const int kOldTableSizeFieldNumber = 3;
  inline const ::TSCE::RangeCoordinateArchive& old_table_size() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_old_table_size();
  inline ::TSCE::RangeCoordinateArchive* release_old_table_size();
  inline void set_allocated_old_table_size(::TSCE::RangeCoordinateArchive* old_table_size);

  // @@protoc_insertion_point(class_scope:TSCE.TableResizedInfoArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_new_table_size();
  inline void clear_has_new_table_size();
  inline void set_has_old_table_size();
  inline void clear_has_old_table_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::TSCE::RangeCoordinateArchive* new_table_size_;
  ::TSCE::RangeCoordinateArchive* old_table_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static TableResizedInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellMergeInfoArchive : public ::google::protobuf::Message {
 public:
  CellMergeInfoArchive();
  virtual ~CellMergeInfoArchive();

  CellMergeInfoArchive(const CellMergeInfoArchive& from);

  inline CellMergeInfoArchive& operator=(const CellMergeInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellMergeInfoArchive& default_instance();

  void Swap(CellMergeInfoArchive* other);

  // implements Message ----------------------------------------------

  CellMergeInfoArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellMergeInfoArchive& from);
  void MergeFrom(const CellMergeInfoArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // required .TSCE.RangeCoordinateArchive merged_range = 2;
  inline bool has_merged_range() const;
  inline void clear_merged_range();
  static const int kMergedRangeFieldNumber = 2;
  inline const ::TSCE::RangeCoordinateArchive& merged_range() const;
  inline ::TSCE::RangeCoordinateArchive* mutable_merged_range();
  inline ::TSCE::RangeCoordinateArchive* release_merged_range();
  inline void set_allocated_merged_range(::TSCE::RangeCoordinateArchive* merged_range);

  // @@protoc_insertion_point(class_scope:TSCE.CellMergeInfoArchive)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_merged_range();
  inline void clear_has_merged_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* table_id_;
  ::TSCE::RangeCoordinateArchive* merged_range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellMergeInfoArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaRewriteSpecArchive : public ::google::protobuf::Message {
 public:
  FormulaRewriteSpecArchive();
  virtual ~FormulaRewriteSpecArchive();

  FormulaRewriteSpecArchive(const FormulaRewriteSpecArchive& from);

  inline FormulaRewriteSpecArchive& operator=(const FormulaRewriteSpecArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaRewriteSpecArchive& default_instance();

  void Swap(FormulaRewriteSpecArchive* other);

  // implements Message ----------------------------------------------

  FormulaRewriteSpecArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaRewriteSpecArchive& from);
  void MergeFrom(const FormulaRewriteSpecArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FormulaRewriteSpecArchive_RewriteType RewriteType;
  static const RewriteType TECTONIC_SHIFT = FormulaRewriteSpecArchive_RewriteType_TECTONIC_SHIFT;
  static const RewriteType REMAP_WITH_SORT_MAPPING = FormulaRewriteSpecArchive_RewriteType_REMAP_WITH_SORT_MAPPING;
  static const RewriteType MOVE_RANGE = FormulaRewriteSpecArchive_RewriteType_MOVE_RANGE;
  static const RewriteType DELETE_OWNER = FormulaRewriteSpecArchive_RewriteType_DELETE_OWNER;
  static const RewriteType TABLE_RESIZE = FormulaRewriteSpecArchive_RewriteType_TABLE_RESIZE;
  static const RewriteType CELL_MERGE = FormulaRewriteSpecArchive_RewriteType_CELL_MERGE;
  static inline bool RewriteType_IsValid(int value) {
    return FormulaRewriteSpecArchive_RewriteType_IsValid(value);
  }
  static const RewriteType RewriteType_MIN =
    FormulaRewriteSpecArchive_RewriteType_RewriteType_MIN;
  static const RewriteType RewriteType_MAX =
    FormulaRewriteSpecArchive_RewriteType_RewriteType_MAX;
  static const int RewriteType_ARRAYSIZE =
    FormulaRewriteSpecArchive_RewriteType_RewriteType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RewriteType_descriptor() {
    return FormulaRewriteSpecArchive_RewriteType_descriptor();
  }
  static inline const ::std::string& RewriteType_Name(RewriteType value) {
    return FormulaRewriteSpecArchive_RewriteType_Name(value);
  }
  static inline bool RewriteType_Parse(const ::std::string& name,
      RewriteType* value) {
    return FormulaRewriteSpecArchive_RewriteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSCE.FormulaRewriteSpecArchive.RewriteType rewrite_type = 1;
  inline bool has_rewrite_type() const;
  inline void clear_rewrite_type();
  static const int kRewriteTypeFieldNumber = 1;
  inline ::TSCE::FormulaRewriteSpecArchive_RewriteType rewrite_type() const;
  inline void set_rewrite_type(::TSCE::FormulaRewriteSpecArchive_RewriteType value);

  // optional .TSCE.TectonicShiftArchive tectonic_shift = 2;
  inline bool has_tectonic_shift() const;
  inline void clear_tectonic_shift();
  static const int kTectonicShiftFieldNumber = 2;
  inline const ::TSCE::TectonicShiftArchive& tectonic_shift() const;
  inline ::TSCE::TectonicShiftArchive* mutable_tectonic_shift();
  inline ::TSCE::TectonicShiftArchive* release_tectonic_shift();
  inline void set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift);

  // optional .TSCE.RewriteSortMappingArchive sort_mapping = 3;
  inline bool has_sort_mapping() const;
  inline void clear_sort_mapping();
  static const int kSortMappingFieldNumber = 3;
  inline const ::TSCE::RewriteSortMappingArchive& sort_mapping() const;
  inline ::TSCE::RewriteSortMappingArchive* mutable_sort_mapping();
  inline ::TSCE::RewriteSortMappingArchive* release_sort_mapping();
  inline void set_allocated_sort_mapping(::TSCE::RewriteSortMappingArchive* sort_mapping);

  // optional .TSCE.RangeMovedInfoArchive range_moved_info = 4;
  inline bool has_range_moved_info() const;
  inline void clear_range_moved_info();
  static const int kRangeMovedInfoFieldNumber = 4;
  inline const ::TSCE::RangeMovedInfoArchive& range_moved_info() const;
  inline ::TSCE::RangeMovedInfoArchive* mutable_range_moved_info();
  inline ::TSCE::RangeMovedInfoArchive* release_range_moved_info();
  inline void set_allocated_range_moved_info(::TSCE::RangeMovedInfoArchive* range_moved_info);

  // optional .TSCE.CFUUIDArchive deleted_owner_id = 5;
  inline bool has_deleted_owner_id() const;
  inline void clear_deleted_owner_id();
  static const int kDeletedOwnerIdFieldNumber = 5;
  inline const ::TSCE::CFUUIDArchive& deleted_owner_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_deleted_owner_id();
  inline ::TSCE::CFUUIDArchive* release_deleted_owner_id();
  inline void set_allocated_deleted_owner_id(::TSCE::CFUUIDArchive* deleted_owner_id);

  // optional .TSCE.TableResizedInfoArchive table_resized_info = 6;
  inline bool has_table_resized_info() const;
  inline void clear_table_resized_info();
  static const int kTableResizedInfoFieldNumber = 6;
  inline const ::TSCE::TableResizedInfoArchive& table_resized_info() const;
  inline ::TSCE::TableResizedInfoArchive* mutable_table_resized_info();
  inline ::TSCE::TableResizedInfoArchive* release_table_resized_info();
  inline void set_allocated_table_resized_info(::TSCE::TableResizedInfoArchive* table_resized_info);

  // optional .TSCE.CellMergeInfoArchive cell_merge_info = 7;
  inline bool has_cell_merge_info() const;
  inline void clear_cell_merge_info();
  static const int kCellMergeInfoFieldNumber = 7;
  inline const ::TSCE::CellMergeInfoArchive& cell_merge_info() const;
  inline ::TSCE::CellMergeInfoArchive* mutable_cell_merge_info();
  inline ::TSCE::CellMergeInfoArchive* release_cell_merge_info();
  inline void set_allocated_cell_merge_info(::TSCE::CellMergeInfoArchive* cell_merge_info);

  // @@protoc_insertion_point(class_scope:TSCE.FormulaRewriteSpecArchive)
 private:
  inline void set_has_rewrite_type();
  inline void clear_has_rewrite_type();
  inline void set_has_tectonic_shift();
  inline void clear_has_tectonic_shift();
  inline void set_has_sort_mapping();
  inline void clear_has_sort_mapping();
  inline void set_has_range_moved_info();
  inline void clear_has_range_moved_info();
  inline void set_has_deleted_owner_id();
  inline void clear_has_deleted_owner_id();
  inline void set_has_table_resized_info();
  inline void clear_has_table_resized_info();
  inline void set_has_cell_merge_info();
  inline void clear_has_cell_merge_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::TectonicShiftArchive* tectonic_shift_;
  ::TSCE::RewriteSortMappingArchive* sort_mapping_;
  ::TSCE::RangeMovedInfoArchive* range_moved_info_;
  ::TSCE::CFUUIDArchive* deleted_owner_id_;
  ::TSCE::TableResizedInfoArchive* table_resized_info_;
  ::TSCE::CellMergeInfoArchive* cell_merge_info_;
  int rewrite_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaRewriteSpecArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellCoordinateFormulaPairArchive : public ::google::protobuf::Message {
 public:
  CellCoordinateFormulaPairArchive();
  virtual ~CellCoordinateFormulaPairArchive();

  CellCoordinateFormulaPairArchive(const CellCoordinateFormulaPairArchive& from);

  inline CellCoordinateFormulaPairArchive& operator=(const CellCoordinateFormulaPairArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellCoordinateFormulaPairArchive& default_instance();

  void Swap(CellCoordinateFormulaPairArchive* other);

  // implements Message ----------------------------------------------

  CellCoordinateFormulaPairArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellCoordinateFormulaPairArchive& from);
  void MergeFrom(const CellCoordinateFormulaPairArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 column = 1;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // required uint32 row = 2;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 2;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // optional .TSCE.FormulaArchive formula = 3;
  inline bool has_formula() const;
  inline void clear_formula();
  static const int kFormulaFieldNumber = 3;
  inline const ::TSCE::FormulaArchive& formula() const;
  inline ::TSCE::FormulaArchive* mutable_formula();
  inline ::TSCE::FormulaArchive* release_formula();
  inline void set_allocated_formula(::TSCE::FormulaArchive* formula);

  // @@protoc_insertion_point(class_scope:TSCE.CellCoordinateFormulaPairArchive)
 private:
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_formula();
  inline void clear_has_formula();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 column_;
  ::google::protobuf::uint32 row_;
  ::TSCE::FormulaArchive* formula_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellCoordinateFormulaPairArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellCoordinateArchive : public ::google::protobuf::Message {
 public:
  CellCoordinateArchive();
  virtual ~CellCoordinateArchive();

  CellCoordinateArchive(const CellCoordinateArchive& from);

  inline CellCoordinateArchive& operator=(const CellCoordinateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellCoordinateArchive& default_instance();

  void Swap(CellCoordinateArchive* other);

  // implements Message ----------------------------------------------

  CellCoordinateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellCoordinateArchive& from);
  void MergeFrom(const CellCoordinateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 packedData = 1;
  inline bool has_packeddata() const;
  inline void clear_packeddata();
  static const int kPackedDataFieldNumber = 1;
  inline ::google::protobuf::uint32 packeddata() const;
  inline void set_packeddata(::google::protobuf::uint32 value);

  // optional uint32 column = 2;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // optional uint32 row = 3;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 3;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.CellCoordinateArchive)
 private:
  inline void set_has_packeddata();
  inline void clear_has_packeddata();
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_row();
  inline void clear_has_row();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 packeddata_;
  ::google::protobuf::uint32 column_;
  ::google::protobuf::uint32 row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellCoordinateArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellCoordinateVectorArchive : public ::google::protobuf::Message {
 public:
  CellCoordinateVectorArchive();
  virtual ~CellCoordinateVectorArchive();

  CellCoordinateVectorArchive(const CellCoordinateVectorArchive& from);

  inline CellCoordinateVectorArchive& operator=(const CellCoordinateVectorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellCoordinateVectorArchive& default_instance();

  void Swap(CellCoordinateVectorArchive* other);

  // implements Message ----------------------------------------------

  CellCoordinateVectorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellCoordinateVectorArchive& from);
  void MergeFrom(const CellCoordinateVectorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.CellCoordinateArchive cell_coordinate = 1;
  inline int cell_coordinate_size() const;
  inline void clear_cell_coordinate();
  static const int kCellCoordinateFieldNumber = 1;
  inline const ::TSCE::CellCoordinateArchive& cell_coordinate(int index) const;
  inline ::TSCE::CellCoordinateArchive* mutable_cell_coordinate(int index);
  inline ::TSCE::CellCoordinateArchive* add_cell_coordinate();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >&
      cell_coordinate() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >*
      mutable_cell_coordinate();

  // @@protoc_insertion_point(class_scope:TSCE.CellCoordinateVectorArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive > cell_coordinate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellCoordinateVectorArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellCoordinateObjectPairArchive : public ::google::protobuf::Message {
 public:
  CellCoordinateObjectPairArchive();
  virtual ~CellCoordinateObjectPairArchive();

  CellCoordinateObjectPairArchive(const CellCoordinateObjectPairArchive& from);

  inline CellCoordinateObjectPairArchive& operator=(const CellCoordinateObjectPairArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellCoordinateObjectPairArchive& default_instance();

  void Swap(CellCoordinateObjectPairArchive* other);

  // implements Message ----------------------------------------------

  CellCoordinateObjectPairArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellCoordinateObjectPairArchive& from);
  void MergeFrom(const CellCoordinateObjectPairArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CellCoordinateArchive cell_coordinate = 1;
  inline bool has_cell_coordinate() const;
  inline void clear_cell_coordinate();
  static const int kCellCoordinateFieldNumber = 1;
  inline const ::TSCE::CellCoordinateArchive& cell_coordinate() const;
  inline ::TSCE::CellCoordinateArchive* mutable_cell_coordinate();
  inline ::TSCE::CellCoordinateArchive* release_cell_coordinate();
  inline void set_allocated_cell_coordinate(::TSCE::CellCoordinateArchive* cell_coordinate);

  // required .TSP.Reference object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // @@protoc_insertion_point(class_scope:TSCE.CellCoordinateObjectPairArchive)
 private:
  inline void set_has_cell_coordinate();
  inline void clear_has_cell_coordinate();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CellCoordinateArchive* cell_coordinate_;
  ::TSP::Reference* object_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellCoordinateObjectPairArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellCoordinateObjectMapArchive : public ::google::protobuf::Message {
 public:
  CellCoordinateObjectMapArchive();
  virtual ~CellCoordinateObjectMapArchive();

  CellCoordinateObjectMapArchive(const CellCoordinateObjectMapArchive& from);

  inline CellCoordinateObjectMapArchive& operator=(const CellCoordinateObjectMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellCoordinateObjectMapArchive& default_instance();

  void Swap(CellCoordinateObjectMapArchive* other);

  // implements Message ----------------------------------------------

  CellCoordinateObjectMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellCoordinateObjectMapArchive& from);
  void MergeFrom(const CellCoordinateObjectMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.CellCoordinateObjectPairArchive cell_coordinate_object_pair = 1;
  inline int cell_coordinate_object_pair_size() const;
  inline void clear_cell_coordinate_object_pair();
  static const int kCellCoordinateObjectPairFieldNumber = 1;
  inline const ::TSCE::CellCoordinateObjectPairArchive& cell_coordinate_object_pair(int index) const;
  inline ::TSCE::CellCoordinateObjectPairArchive* mutable_cell_coordinate_object_pair(int index);
  inline ::TSCE::CellCoordinateObjectPairArchive* add_cell_coordinate_object_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateObjectPairArchive >&
      cell_coordinate_object_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateObjectPairArchive >*
      mutable_cell_coordinate_object_pair();

  // @@protoc_insertion_point(class_scope:TSCE.CellCoordinateObjectMapArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateObjectPairArchive > cell_coordinate_object_pair_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellCoordinateObjectMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class OwnerFormulaMapArchive : public ::google::protobuf::Message {
 public:
  OwnerFormulaMapArchive();
  virtual ~OwnerFormulaMapArchive();

  OwnerFormulaMapArchive(const OwnerFormulaMapArchive& from);

  inline OwnerFormulaMapArchive& operator=(const OwnerFormulaMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnerFormulaMapArchive& default_instance();

  void Swap(OwnerFormulaMapArchive* other);

  // implements Message ----------------------------------------------

  OwnerFormulaMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnerFormulaMapArchive& from);
  void MergeFrom(const OwnerFormulaMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.CellCoordinateFormulaPairArchive coordinate_formula_pair = 1;
  inline int coordinate_formula_pair_size() const;
  inline void clear_coordinate_formula_pair();
  static const int kCoordinateFormulaPairFieldNumber = 1;
  inline const ::TSCE::CellCoordinateFormulaPairArchive& coordinate_formula_pair(int index) const;
  inline ::TSCE::CellCoordinateFormulaPairArchive* mutable_coordinate_formula_pair(int index);
  inline ::TSCE::CellCoordinateFormulaPairArchive* add_coordinate_formula_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateFormulaPairArchive >&
      coordinate_formula_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateFormulaPairArchive >*
      mutable_coordinate_formula_pair();

  // @@protoc_insertion_point(class_scope:TSCE.OwnerFormulaMapArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateFormulaPairArchive > coordinate_formula_pair_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static OwnerFormulaMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormulaRewriteCommandArchive : public ::google::protobuf::Message {
 public:
  FormulaRewriteCommandArchive();
  virtual ~FormulaRewriteCommandArchive();

  FormulaRewriteCommandArchive(const FormulaRewriteCommandArchive& from);

  inline FormulaRewriteCommandArchive& operator=(const FormulaRewriteCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormulaRewriteCommandArchive& default_instance();

  void Swap(FormulaRewriteCommandArchive* other);

  // implements Message ----------------------------------------------

  FormulaRewriteCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormulaRewriteCommandArchive& from);
  void MergeFrom(const FormulaRewriteCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference table_rewrite_command = 1;
  inline bool has_table_rewrite_command() const;
  inline void clear_table_rewrite_command();
  static const int kTableRewriteCommandFieldNumber = 1;
  inline const ::TSP::Reference& table_rewrite_command() const;
  inline ::TSP::Reference* mutable_table_rewrite_command();
  inline ::TSP::Reference* release_table_rewrite_command();
  inline void set_allocated_table_rewrite_command(::TSP::Reference* table_rewrite_command);

  // optional .TSK.CommandArchive super = 2;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 2;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TSCE.FormulaRewriteCommandArchive)
 private:
  inline void set_has_table_rewrite_command();
  inline void clear_has_table_rewrite_command();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* table_rewrite_command_;
  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static FormulaRewriteCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class NumberTrackedReferencePairArchive : public ::google::protobuf::Message {
 public:
  NumberTrackedReferencePairArchive();
  virtual ~NumberTrackedReferencePairArchive();

  NumberTrackedReferencePairArchive(const NumberTrackedReferencePairArchive& from);

  inline NumberTrackedReferencePairArchive& operator=(const NumberTrackedReferencePairArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberTrackedReferencePairArchive& default_instance();

  void Swap(NumberTrackedReferencePairArchive* other);

  // implements Message ----------------------------------------------

  NumberTrackedReferencePairArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumberTrackedReferencePairArchive& from);
  void MergeFrom(const NumberTrackedReferencePairArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // optional .TSP.Reference tracked_reference = 2;
  inline bool has_tracked_reference() const;
  inline void clear_tracked_reference();
  static const int kTrackedReferenceFieldNumber = 2;
  inline const ::TSP::Reference& tracked_reference() const;
  inline ::TSP::Reference* mutable_tracked_reference();
  inline ::TSP::Reference* release_tracked_reference();
  inline void set_allocated_tracked_reference(::TSP::Reference* tracked_reference);

  // @@protoc_insertion_point(class_scope:TSCE.NumberTrackedReferencePairArchive)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_tracked_reference();
  inline void clear_has_tracked_reference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* tracked_reference_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static NumberTrackedReferencePairArchive* default_instance_;
};
// -------------------------------------------------------------------

class NumberToTrackedReferenceMapArchive : public ::google::protobuf::Message {
 public:
  NumberToTrackedReferenceMapArchive();
  virtual ~NumberToTrackedReferenceMapArchive();

  NumberToTrackedReferenceMapArchive(const NumberToTrackedReferenceMapArchive& from);

  inline NumberToTrackedReferenceMapArchive& operator=(const NumberToTrackedReferenceMapArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberToTrackedReferenceMapArchive& default_instance();

  void Swap(NumberToTrackedReferenceMapArchive* other);

  // implements Message ----------------------------------------------

  NumberToTrackedReferenceMapArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumberToTrackedReferenceMapArchive& from);
  void MergeFrom(const NumberToTrackedReferenceMapArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSCE.NumberTrackedReferencePairArchive number_tracked_reference_pair = 1;
  inline int number_tracked_reference_pair_size() const;
  inline void clear_number_tracked_reference_pair();
  static const int kNumberTrackedReferencePairFieldNumber = 1;
  inline const ::TSCE::NumberTrackedReferencePairArchive& number_tracked_reference_pair(int index) const;
  inline ::TSCE::NumberTrackedReferencePairArchive* mutable_number_tracked_reference_pair(int index);
  inline ::TSCE::NumberTrackedReferencePairArchive* add_number_tracked_reference_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::NumberTrackedReferencePairArchive >&
      number_tracked_reference_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::NumberTrackedReferencePairArchive >*
      mutable_number_tracked_reference_pair();

  // @@protoc_insertion_point(class_scope:TSCE.NumberToTrackedReferenceMapArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCE::NumberTrackedReferencePairArchive > number_tracked_reference_pair_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static NumberToTrackedReferenceMapArchive* default_instance_;
};
// -------------------------------------------------------------------

class TrackedReferencesRewriteCommandArchive : public ::google::protobuf::Message {
 public:
  TrackedReferencesRewriteCommandArchive();
  virtual ~TrackedReferencesRewriteCommandArchive();

  TrackedReferencesRewriteCommandArchive(const TrackedReferencesRewriteCommandArchive& from);

  inline TrackedReferencesRewriteCommandArchive& operator=(const TrackedReferencesRewriteCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackedReferencesRewriteCommandArchive& default_instance();

  void Swap(TrackedReferencesRewriteCommandArchive* other);

  // implements Message ----------------------------------------------

  TrackedReferencesRewriteCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackedReferencesRewriteCommandArchive& from);
  void MergeFrom(const TrackedReferencesRewriteCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSCE.NumberToTrackedReferenceMapArchive references_in_reference_tracker = 1 [deprecated = true];
  inline bool has_references_in_reference_tracker() const PROTOBUF_DEPRECATED;
  inline void clear_references_in_reference_tracker() PROTOBUF_DEPRECATED;
  static const int kReferencesInReferenceTrackerFieldNumber = 1;
  inline const ::TSCE::NumberToTrackedReferenceMapArchive& references_in_reference_tracker() const PROTOBUF_DEPRECATED;
  inline ::TSCE::NumberToTrackedReferenceMapArchive* mutable_references_in_reference_tracker() PROTOBUF_DEPRECATED;
  inline ::TSCE::NumberToTrackedReferenceMapArchive* release_references_in_reference_tracker() PROTOBUF_DEPRECATED;
  inline void set_allocated_references_in_reference_tracker(::TSCE::NumberToTrackedReferenceMapArchive* references_in_reference_tracker) PROTOBUF_DEPRECATED;

  // optional .TSCE.NumberToTrackedReferenceMapArchive original_tracked_reference_copies = 2 [deprecated = true];
  inline bool has_original_tracked_reference_copies() const PROTOBUF_DEPRECATED;
  inline void clear_original_tracked_reference_copies() PROTOBUF_DEPRECATED;
  static const int kOriginalTrackedReferenceCopiesFieldNumber = 2;
  inline const ::TSCE::NumberToTrackedReferenceMapArchive& original_tracked_reference_copies() const PROTOBUF_DEPRECATED;
  inline ::TSCE::NumberToTrackedReferenceMapArchive* mutable_original_tracked_reference_copies() PROTOBUF_DEPRECATED;
  inline ::TSCE::NumberToTrackedReferenceMapArchive* release_original_tracked_reference_copies() PROTOBUF_DEPRECATED;
  inline void set_allocated_original_tracked_reference_copies(::TSCE::NumberToTrackedReferenceMapArchive* original_tracked_reference_copies) PROTOBUF_DEPRECATED;

  // optional .TSCE.FormulaRewriteSpecArchive rewrite_spec = 3;
  inline bool has_rewrite_spec() const;
  inline void clear_rewrite_spec();
  static const int kRewriteSpecFieldNumber = 3;
  inline const ::TSCE::FormulaRewriteSpecArchive& rewrite_spec() const;
  inline ::TSCE::FormulaRewriteSpecArchive* mutable_rewrite_spec();
  inline ::TSCE::FormulaRewriteSpecArchive* release_rewrite_spec();
  inline void set_allocated_rewrite_spec(::TSCE::FormulaRewriteSpecArchive* rewrite_spec);

  // required .TSP.Reference reference_tracker = 4;
  inline bool has_reference_tracker() const;
  inline void clear_reference_tracker();
  static const int kReferenceTrackerFieldNumber = 4;
  inline const ::TSP::Reference& reference_tracker() const;
  inline ::TSP::Reference* mutable_reference_tracker();
  inline ::TSP::Reference* release_reference_tracker();
  inline void set_allocated_reference_tracker(::TSP::Reference* reference_tracker);

  // required .TSK.CommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TSCE.TrackedReferencesRewriteCommandArchive)
 private:
  inline void set_has_references_in_reference_tracker();
  inline void clear_has_references_in_reference_tracker();
  inline void set_has_original_tracked_reference_copies();
  inline void clear_has_original_tracked_reference_copies();
  inline void set_has_rewrite_spec();
  inline void clear_has_rewrite_spec();
  inline void set_has_reference_tracker();
  inline void clear_has_reference_tracker();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::NumberToTrackedReferenceMapArchive* references_in_reference_tracker_;
  ::TSCE::NumberToTrackedReferenceMapArchive* original_tracked_reference_copies_;
  ::TSCE::FormulaRewriteSpecArchive* rewrite_spec_;
  ::TSP::Reference* reference_tracker_;
  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static TrackedReferencesRewriteCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class TrackedReferenceArchive : public ::google::protobuf::Message {
 public:
  TrackedReferenceArchive();
  virtual ~TrackedReferenceArchive();

  TrackedReferenceArchive(const TrackedReferenceArchive& from);

  inline TrackedReferenceArchive& operator=(const TrackedReferenceArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackedReferenceArchive& default_instance();

  void Swap(TrackedReferenceArchive* other);

  // implements Message ----------------------------------------------

  TrackedReferenceArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackedReferenceArchive& from);
  void MergeFrom(const TrackedReferenceArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.ASTNodeArrayArchive ast = 1;
  inline bool has_ast() const;
  inline void clear_ast();
  static const int kAstFieldNumber = 1;
  inline const ::TSCE::ASTNodeArrayArchive& ast() const;
  inline ::TSCE::ASTNodeArrayArchive* mutable_ast();
  inline ::TSCE::ASTNodeArrayArchive* release_ast();
  inline void set_allocated_ast(::TSCE::ASTNodeArrayArchive* ast);

  // required uint32 formula_id = 2;
  inline bool has_formula_id() const;
  inline void clear_formula_id();
  static const int kFormulaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 formula_id() const;
  inline void set_formula_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCE.TrackedReferenceArchive)
 private:
  inline void set_has_ast();
  inline void clear_has_ast();
  inline void set_has_formula_id();
  inline void clear_has_formula_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::ASTNodeArrayArchive* ast_;
  ::google::protobuf::uint32 formula_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static TrackedReferenceArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceTrackerArchive : public ::google::protobuf::Message {
 public:
  ReferenceTrackerArchive();
  virtual ~ReferenceTrackerArchive();

  ReferenceTrackerArchive(const ReferenceTrackerArchive& from);

  inline ReferenceTrackerArchive& operator=(const ReferenceTrackerArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceTrackerArchive& default_instance();

  void Swap(ReferenceTrackerArchive* other);

  // implements Message ----------------------------------------------

  ReferenceTrackerArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceTrackerArchive& from);
  void MergeFrom(const ReferenceTrackerArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCE.CFUUIDArchive uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::TSCE::CFUUIDArchive& uuid() const;
  inline ::TSCE::CFUUIDArchive* mutable_uuid();
  inline ::TSCE::CFUUIDArchive* release_uuid();
  inline void set_allocated_uuid(::TSCE::CFUUIDArchive* uuid);

  // repeated .TSP.Reference tracked_reference = 2 [deprecated = true];
  inline int tracked_reference_size() const PROTOBUF_DEPRECATED;
  inline void clear_tracked_reference() PROTOBUF_DEPRECATED;
  static const int kTrackedReferenceFieldNumber = 2;
  inline const ::TSP::Reference& tracked_reference(int index) const PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* mutable_tracked_reference(int index) PROTOBUF_DEPRECATED;
  inline ::TSP::Reference* add_tracked_reference() PROTOBUF_DEPRECATED;
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      tracked_reference() const PROTOBUF_DEPRECATED;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_tracked_reference() PROTOBUF_DEPRECATED;

  // repeated .TSCE.TrackedReferenceArchive contained_tracked_reference = 3;
  inline int contained_tracked_reference_size() const;
  inline void clear_contained_tracked_reference();
  static const int kContainedTrackedReferenceFieldNumber = 3;
  inline const ::TSCE::TrackedReferenceArchive& contained_tracked_reference(int index) const;
  inline ::TSCE::TrackedReferenceArchive* mutable_contained_tracked_reference(int index);
  inline ::TSCE::TrackedReferenceArchive* add_contained_tracked_reference();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCE::TrackedReferenceArchive >&
      contained_tracked_reference() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCE::TrackedReferenceArchive >*
      mutable_contained_tracked_reference();

  // @@protoc_insertion_point(class_scope:TSCE.ReferenceTrackerArchive)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::CFUUIDArchive* uuid_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > tracked_reference_;
  ::google::protobuf::RepeatedPtrField< ::TSCE::TrackedReferenceArchive > contained_tracked_reference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static ReferenceTrackerArchive* default_instance_;
};
// -------------------------------------------------------------------

class BooleanCellValueArchive : public ::google::protobuf::Message {
 public:
  BooleanCellValueArchive();
  virtual ~BooleanCellValueArchive();

  BooleanCellValueArchive(const BooleanCellValueArchive& from);

  inline BooleanCellValueArchive& operator=(const BooleanCellValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BooleanCellValueArchive& default_instance();

  void Swap(BooleanCellValueArchive* other);

  // implements Message ----------------------------------------------

  BooleanCellValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BooleanCellValueArchive& from);
  void MergeFrom(const BooleanCellValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.BooleanCellValueArchive)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static BooleanCellValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class DateCellValueArchive : public ::google::protobuf::Message {
 public:
  DateCellValueArchive();
  virtual ~DateCellValueArchive();

  DateCellValueArchive(const DateCellValueArchive& from);

  inline DateCellValueArchive& operator=(const DateCellValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateCellValueArchive& default_instance();

  void Swap(DateCellValueArchive* other);

  // implements Message ----------------------------------------------

  DateCellValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateCellValueArchive& from);
  void MergeFrom(const DateCellValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // required .TSK.FormatStructArchive format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline const ::TSK::FormatStructArchive& format() const;
  inline ::TSK::FormatStructArchive* mutable_format();
  inline ::TSK::FormatStructArchive* release_format();
  inline void set_allocated_format(::TSK::FormatStructArchive* format);

  // optional bool format_is_implicit = 3 [default = true];
  inline bool has_format_is_implicit() const;
  inline void clear_format_is_implicit();
  static const int kFormatIsImplicitFieldNumber = 3;
  inline bool format_is_implicit() const;
  inline void set_format_is_implicit(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.DateCellValueArchive)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_format_is_implicit();
  inline void clear_has_format_is_implicit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;
  ::TSK::FormatStructArchive* format_;
  bool format_is_implicit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static DateCellValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class NumberCellValueArchive : public ::google::protobuf::Message {
 public:
  NumberCellValueArchive();
  virtual ~NumberCellValueArchive();

  NumberCellValueArchive(const NumberCellValueArchive& from);

  inline NumberCellValueArchive& operator=(const NumberCellValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberCellValueArchive& default_instance();

  void Swap(NumberCellValueArchive* other);

  // implements Message ----------------------------------------------

  NumberCellValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NumberCellValueArchive& from);
  void MergeFrom(const NumberCellValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // optional int32 unit_index = 2;
  inline bool has_unit_index() const;
  inline void clear_unit_index();
  static const int kUnitIndexFieldNumber = 2;
  inline ::google::protobuf::int32 unit_index() const;
  inline void set_unit_index(::google::protobuf::int32 value);

  // optional string currency_code = 5;
  inline bool has_currency_code() const;
  inline void clear_currency_code();
  static const int kCurrencyCodeFieldNumber = 5;
  inline const ::std::string& currency_code() const;
  inline void set_currency_code(const ::std::string& value);
  inline void set_currency_code(const char* value);
  inline void set_currency_code(const char* value, size_t size);
  inline ::std::string* mutable_currency_code();
  inline ::std::string* release_currency_code();
  inline void set_allocated_currency_code(::std::string* currency_code);

  // required .TSK.FormatStructArchive format = 3;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 3;
  inline const ::TSK::FormatStructArchive& format() const;
  inline ::TSK::FormatStructArchive* mutable_format();
  inline ::TSK::FormatStructArchive* release_format();
  inline void set_allocated_format(::TSK::FormatStructArchive* format);

  // optional bool format_is_implicit = 4 [default = true];
  inline bool has_format_is_implicit() const;
  inline void clear_format_is_implicit();
  static const int kFormatIsImplicitFieldNumber = 4;
  inline bool format_is_implicit() const;
  inline void set_format_is_implicit(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.NumberCellValueArchive)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_unit_index();
  inline void clear_has_unit_index();
  inline void set_has_currency_code();
  inline void clear_has_currency_code();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_format_is_implicit();
  inline void clear_has_format_is_implicit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;
  ::std::string* currency_code_;
  ::google::protobuf::int32 unit_index_;
  bool format_is_implicit_;
  ::TSK::FormatStructArchive* format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static NumberCellValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class StringCellValueArchive : public ::google::protobuf::Message {
 public:
  StringCellValueArchive();
  virtual ~StringCellValueArchive();

  StringCellValueArchive(const StringCellValueArchive& from);

  inline StringCellValueArchive& operator=(const StringCellValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringCellValueArchive& default_instance();

  void Swap(StringCellValueArchive* other);

  // implements Message ----------------------------------------------

  StringCellValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringCellValueArchive& from);
  void MergeFrom(const StringCellValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // required .TSK.FormatStructArchive format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline const ::TSK::FormatStructArchive& format() const;
  inline ::TSK::FormatStructArchive* mutable_format();
  inline ::TSK::FormatStructArchive* release_format();
  inline void set_allocated_format(::TSK::FormatStructArchive* format);

  // optional bool format_is_implicit = 3 [default = true];
  inline bool has_format_is_implicit() const;
  inline void clear_format_is_implicit();
  static const int kFormatIsImplicitFieldNumber = 3;
  inline bool format_is_implicit() const;
  inline void set_format_is_implicit(bool value);

  // @@protoc_insertion_point(class_scope:TSCE.StringCellValueArchive)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_format_is_implicit();
  inline void clear_has_format_is_implicit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  ::TSK::FormatStructArchive* format_;
  bool format_is_implicit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static StringCellValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CellValueArchive : public ::google::protobuf::Message {
 public:
  CellValueArchive();
  virtual ~CellValueArchive();

  CellValueArchive(const CellValueArchive& from);

  inline CellValueArchive& operator=(const CellValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellValueArchive& default_instance();

  void Swap(CellValueArchive* other);

  // implements Message ----------------------------------------------

  CellValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellValueArchive& from);
  void MergeFrom(const CellValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CellValueArchive_CellValueType CellValueType;
  static const CellValueType NIL_TYPE = CellValueArchive_CellValueType_NIL_TYPE;
  static const CellValueType BOOLEAN_TYPE = CellValueArchive_CellValueType_BOOLEAN_TYPE;
  static const CellValueType DATE_TYPE = CellValueArchive_CellValueType_DATE_TYPE;
  static const CellValueType NUMBER_TYPE = CellValueArchive_CellValueType_NUMBER_TYPE;
  static const CellValueType STRING_TYPE = CellValueArchive_CellValueType_STRING_TYPE;
  static inline bool CellValueType_IsValid(int value) {
    return CellValueArchive_CellValueType_IsValid(value);
  }
  static const CellValueType CellValueType_MIN =
    CellValueArchive_CellValueType_CellValueType_MIN;
  static const CellValueType CellValueType_MAX =
    CellValueArchive_CellValueType_CellValueType_MAX;
  static const int CellValueType_ARRAYSIZE =
    CellValueArchive_CellValueType_CellValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CellValueType_descriptor() {
    return CellValueArchive_CellValueType_descriptor();
  }
  static inline const ::std::string& CellValueType_Name(CellValueType value) {
    return CellValueArchive_CellValueType_Name(value);
  }
  static inline bool CellValueType_Parse(const ::std::string& name,
      CellValueType* value) {
    return CellValueArchive_CellValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSCE.CellValueArchive.CellValueType cell_value_type = 1;
  inline bool has_cell_value_type() const;
  inline void clear_cell_value_type();
  static const int kCellValueTypeFieldNumber = 1;
  inline ::TSCE::CellValueArchive_CellValueType cell_value_type() const;
  inline void set_cell_value_type(::TSCE::CellValueArchive_CellValueType value);

  // optional .TSCE.BooleanCellValueArchive boolean_value = 2;
  inline bool has_boolean_value() const;
  inline void clear_boolean_value();
  static const int kBooleanValueFieldNumber = 2;
  inline const ::TSCE::BooleanCellValueArchive& boolean_value() const;
  inline ::TSCE::BooleanCellValueArchive* mutable_boolean_value();
  inline ::TSCE::BooleanCellValueArchive* release_boolean_value();
  inline void set_allocated_boolean_value(::TSCE::BooleanCellValueArchive* boolean_value);

  // optional .TSCE.DateCellValueArchive date_value = 3;
  inline bool has_date_value() const;
  inline void clear_date_value();
  static const int kDateValueFieldNumber = 3;
  inline const ::TSCE::DateCellValueArchive& date_value() const;
  inline ::TSCE::DateCellValueArchive* mutable_date_value();
  inline ::TSCE::DateCellValueArchive* release_date_value();
  inline void set_allocated_date_value(::TSCE::DateCellValueArchive* date_value);

  // optional .TSCE.NumberCellValueArchive number_value = 4;
  inline bool has_number_value() const;
  inline void clear_number_value();
  static const int kNumberValueFieldNumber = 4;
  inline const ::TSCE::NumberCellValueArchive& number_value() const;
  inline ::TSCE::NumberCellValueArchive* mutable_number_value();
  inline ::TSCE::NumberCellValueArchive* release_number_value();
  inline void set_allocated_number_value(::TSCE::NumberCellValueArchive* number_value);

  // optional .TSCE.StringCellValueArchive string_value = 5;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 5;
  inline const ::TSCE::StringCellValueArchive& string_value() const;
  inline ::TSCE::StringCellValueArchive* mutable_string_value();
  inline ::TSCE::StringCellValueArchive* release_string_value();
  inline void set_allocated_string_value(::TSCE::StringCellValueArchive* string_value);

  // @@protoc_insertion_point(class_scope:TSCE.CellValueArchive)
 private:
  inline void set_has_cell_value_type();
  inline void clear_has_cell_value_type();
  inline void set_has_boolean_value();
  inline void clear_has_boolean_value();
  inline void set_has_date_value();
  inline void clear_has_date_value();
  inline void set_has_number_value();
  inline void clear_has_number_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCE::BooleanCellValueArchive* boolean_value_;
  ::TSCE::DateCellValueArchive* date_value_;
  ::TSCE::NumberCellValueArchive* number_value_;
  ::TSCE::StringCellValueArchive* string_value_;
  int cell_value_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCEArchives_2eproto();
  friend void protobuf_AssignDesc_TSCEArchives_2eproto();
  friend void protobuf_ShutdownFile_TSCEArchives_2eproto();

  void InitAsDefaultInstance();
  static CellValueArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// CFUUIDArchive

// optional bytes uuid_bytes = 1;
inline bool CFUUIDArchive::has_uuid_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CFUUIDArchive::set_has_uuid_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CFUUIDArchive::clear_has_uuid_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CFUUIDArchive::clear_uuid_bytes() {
  if (uuid_bytes_ != &::google::protobuf::internal::kEmptyString) {
    uuid_bytes_->clear();
  }
  clear_has_uuid_bytes();
}
inline const ::std::string& CFUUIDArchive::uuid_bytes() const {
  return *uuid_bytes_;
}
inline void CFUUIDArchive::set_uuid_bytes(const ::std::string& value) {
  set_has_uuid_bytes();
  if (uuid_bytes_ == &::google::protobuf::internal::kEmptyString) {
    uuid_bytes_ = new ::std::string;
  }
  uuid_bytes_->assign(value);
}
inline void CFUUIDArchive::set_uuid_bytes(const char* value) {
  set_has_uuid_bytes();
  if (uuid_bytes_ == &::google::protobuf::internal::kEmptyString) {
    uuid_bytes_ = new ::std::string;
  }
  uuid_bytes_->assign(value);
}
inline void CFUUIDArchive::set_uuid_bytes(const void* value, size_t size) {
  set_has_uuid_bytes();
  if (uuid_bytes_ == &::google::protobuf::internal::kEmptyString) {
    uuid_bytes_ = new ::std::string;
  }
  uuid_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CFUUIDArchive::mutable_uuid_bytes() {
  set_has_uuid_bytes();
  if (uuid_bytes_ == &::google::protobuf::internal::kEmptyString) {
    uuid_bytes_ = new ::std::string;
  }
  return uuid_bytes_;
}
inline ::std::string* CFUUIDArchive::release_uuid_bytes() {
  clear_has_uuid_bytes();
  if (uuid_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_bytes_;
    uuid_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CFUUIDArchive::set_allocated_uuid_bytes(::std::string* uuid_bytes) {
  if (uuid_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_bytes_;
  }
  if (uuid_bytes) {
    set_has_uuid_bytes();
    uuid_bytes_ = uuid_bytes;
  } else {
    clear_has_uuid_bytes();
    uuid_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 uuid_w0 = 2;
inline bool CFUUIDArchive::has_uuid_w0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CFUUIDArchive::set_has_uuid_w0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CFUUIDArchive::clear_has_uuid_w0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CFUUIDArchive::clear_uuid_w0() {
  uuid_w0_ = 0u;
  clear_has_uuid_w0();
}
inline ::google::protobuf::uint32 CFUUIDArchive::uuid_w0() const {
  return uuid_w0_;
}
inline void CFUUIDArchive::set_uuid_w0(::google::protobuf::uint32 value) {
  set_has_uuid_w0();
  uuid_w0_ = value;
}

// optional uint32 uuid_w1 = 3;
inline bool CFUUIDArchive::has_uuid_w1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CFUUIDArchive::set_has_uuid_w1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CFUUIDArchive::clear_has_uuid_w1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CFUUIDArchive::clear_uuid_w1() {
  uuid_w1_ = 0u;
  clear_has_uuid_w1();
}
inline ::google::protobuf::uint32 CFUUIDArchive::uuid_w1() const {
  return uuid_w1_;
}
inline void CFUUIDArchive::set_uuid_w1(::google::protobuf::uint32 value) {
  set_has_uuid_w1();
  uuid_w1_ = value;
}

// optional uint32 uuid_w2 = 4;
inline bool CFUUIDArchive::has_uuid_w2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CFUUIDArchive::set_has_uuid_w2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CFUUIDArchive::clear_has_uuid_w2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CFUUIDArchive::clear_uuid_w2() {
  uuid_w2_ = 0u;
  clear_has_uuid_w2();
}
inline ::google::protobuf::uint32 CFUUIDArchive::uuid_w2() const {
  return uuid_w2_;
}
inline void CFUUIDArchive::set_uuid_w2(::google::protobuf::uint32 value) {
  set_has_uuid_w2();
  uuid_w2_ = value;
}

// optional uint32 uuid_w3 = 5;
inline bool CFUUIDArchive::has_uuid_w3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CFUUIDArchive::set_has_uuid_w3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CFUUIDArchive::clear_has_uuid_w3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CFUUIDArchive::clear_uuid_w3() {
  uuid_w3_ = 0u;
  clear_has_uuid_w3();
}
inline ::google::protobuf::uint32 CFUUIDArchive::uuid_w3() const {
  return uuid_w3_;
}
inline void CFUUIDArchive::set_uuid_w3(::google::protobuf::uint32 value) {
  set_has_uuid_w3();
  uuid_w3_ = value;
}

// -------------------------------------------------------------------

// CellReferenceArchive

// required uint32 column = 1;
inline bool CellReferenceArchive::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellReferenceArchive::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellReferenceArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellReferenceArchive::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 CellReferenceArchive::column() const {
  return column_;
}
inline void CellReferenceArchive::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// required uint32 row = 2;
inline bool CellReferenceArchive::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellReferenceArchive::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellReferenceArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellReferenceArchive::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 CellReferenceArchive::row() const {
  return row_;
}
inline void CellReferenceArchive::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// required .TSCE.CFUUIDArchive table_id = 3;
inline bool CellReferenceArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellReferenceArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellReferenceArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellReferenceArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& CellReferenceArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* CellReferenceArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* CellReferenceArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void CellReferenceArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// -------------------------------------------------------------------

// InternalCellReferenceArchive

// required .TSCE.CellCoordinateArchive coordinate = 1;
inline bool InternalCellReferenceArchive::has_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalCellReferenceArchive::set_has_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalCellReferenceArchive::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalCellReferenceArchive::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::TSCE::CellCoordinateArchive::Clear();
  clear_has_coordinate();
}
inline const ::TSCE::CellCoordinateArchive& InternalCellReferenceArchive::coordinate() const {
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
}
inline ::TSCE::CellCoordinateArchive* InternalCellReferenceArchive::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::TSCE::CellCoordinateArchive;
  return coordinate_;
}
inline ::TSCE::CellCoordinateArchive* InternalCellReferenceArchive::release_coordinate() {
  clear_has_coordinate();
  ::TSCE::CellCoordinateArchive* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void InternalCellReferenceArchive::set_allocated_coordinate(::TSCE::CellCoordinateArchive* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// required uint32 owner_id = 2;
inline bool InternalCellReferenceArchive::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalCellReferenceArchive::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalCellReferenceArchive::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalCellReferenceArchive::clear_owner_id() {
  owner_id_ = 0u;
  clear_has_owner_id();
}
inline ::google::protobuf::uint32 InternalCellReferenceArchive::owner_id() const {
  return owner_id_;
}
inline void InternalCellReferenceArchive::set_owner_id(::google::protobuf::uint32 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// -------------------------------------------------------------------

// RangeReferenceArchive

// required .TSCE.CFUUIDArchive table_id = 1;
inline bool RangeReferenceArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeReferenceArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeReferenceArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeReferenceArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& RangeReferenceArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* RangeReferenceArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* RangeReferenceArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void RangeReferenceArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// required uint32 top_left_column = 2;
inline bool RangeReferenceArchive::has_top_left_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeReferenceArchive::set_has_top_left_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeReferenceArchive::clear_has_top_left_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeReferenceArchive::clear_top_left_column() {
  top_left_column_ = 0u;
  clear_has_top_left_column();
}
inline ::google::protobuf::uint32 RangeReferenceArchive::top_left_column() const {
  return top_left_column_;
}
inline void RangeReferenceArchive::set_top_left_column(::google::protobuf::uint32 value) {
  set_has_top_left_column();
  top_left_column_ = value;
}

// required uint32 top_left_row = 3;
inline bool RangeReferenceArchive::has_top_left_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeReferenceArchive::set_has_top_left_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeReferenceArchive::clear_has_top_left_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeReferenceArchive::clear_top_left_row() {
  top_left_row_ = 0u;
  clear_has_top_left_row();
}
inline ::google::protobuf::uint32 RangeReferenceArchive::top_left_row() const {
  return top_left_row_;
}
inline void RangeReferenceArchive::set_top_left_row(::google::protobuf::uint32 value) {
  set_has_top_left_row();
  top_left_row_ = value;
}

// required uint32 bottom_right_column = 4;
inline bool RangeReferenceArchive::has_bottom_right_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RangeReferenceArchive::set_has_bottom_right_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RangeReferenceArchive::clear_has_bottom_right_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RangeReferenceArchive::clear_bottom_right_column() {
  bottom_right_column_ = 0u;
  clear_has_bottom_right_column();
}
inline ::google::protobuf::uint32 RangeReferenceArchive::bottom_right_column() const {
  return bottom_right_column_;
}
inline void RangeReferenceArchive::set_bottom_right_column(::google::protobuf::uint32 value) {
  set_has_bottom_right_column();
  bottom_right_column_ = value;
}

// required uint32 bottom_right_row = 5;
inline bool RangeReferenceArchive::has_bottom_right_row() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RangeReferenceArchive::set_has_bottom_right_row() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RangeReferenceArchive::clear_has_bottom_right_row() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RangeReferenceArchive::clear_bottom_right_row() {
  bottom_right_row_ = 0u;
  clear_has_bottom_right_row();
}
inline ::google::protobuf::uint32 RangeReferenceArchive::bottom_right_row() const {
  return bottom_right_row_;
}
inline void RangeReferenceArchive::set_bottom_right_row(::google::protobuf::uint32 value) {
  set_has_bottom_right_row();
  bottom_right_row_ = value;
}

// -------------------------------------------------------------------

// InternalRangeReferenceArchive

// required uint32 owner_id = 1;
inline bool InternalRangeReferenceArchive::has_owner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRangeReferenceArchive::set_has_owner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRangeReferenceArchive::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRangeReferenceArchive::clear_owner_id() {
  owner_id_ = 0u;
  clear_has_owner_id();
}
inline ::google::protobuf::uint32 InternalRangeReferenceArchive::owner_id() const {
  return owner_id_;
}
inline void InternalRangeReferenceArchive::set_owner_id(::google::protobuf::uint32 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// required .TSCE.RangeCoordinateArchive range = 2;
inline bool InternalRangeReferenceArchive::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalRangeReferenceArchive::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalRangeReferenceArchive::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalRangeReferenceArchive::clear_range() {
  if (range_ != NULL) range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_range();
}
inline const ::TSCE::RangeCoordinateArchive& InternalRangeReferenceArchive::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::TSCE::RangeCoordinateArchive* InternalRangeReferenceArchive::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::TSCE::RangeCoordinateArchive;
  return range_;
}
inline ::TSCE::RangeCoordinateArchive* InternalRangeReferenceArchive::release_range() {
  clear_has_range();
  ::TSCE::RangeCoordinateArchive* temp = range_;
  range_ = NULL;
  return temp;
}
inline void InternalRangeReferenceArchive::set_allocated_range(::TSCE::RangeCoordinateArchive* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
}

// -------------------------------------------------------------------

// ReferenceArchive

// required .TSCE.ReferenceArchive.ReferenceType reference_type = 1;
inline bool ReferenceArchive::has_reference_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceArchive::set_has_reference_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceArchive::clear_has_reference_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceArchive::clear_reference_type() {
  reference_type_ = 1;
  clear_has_reference_type();
}
inline ::TSCE::ReferenceArchive_ReferenceType ReferenceArchive::reference_type() const {
  return static_cast< ::TSCE::ReferenceArchive_ReferenceType >(reference_type_);
}
inline void ReferenceArchive::set_reference_type(::TSCE::ReferenceArchive_ReferenceType value) {
  assert(::TSCE::ReferenceArchive_ReferenceType_IsValid(value));
  set_has_reference_type();
  reference_type_ = value;
}

// optional .TSCE.CellReferenceArchive cell_reference = 2;
inline bool ReferenceArchive::has_cell_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceArchive::set_has_cell_reference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceArchive::clear_has_cell_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceArchive::clear_cell_reference() {
  if (cell_reference_ != NULL) cell_reference_->::TSCE::CellReferenceArchive::Clear();
  clear_has_cell_reference();
}
inline const ::TSCE::CellReferenceArchive& ReferenceArchive::cell_reference() const {
  return cell_reference_ != NULL ? *cell_reference_ : *default_instance_->cell_reference_;
}
inline ::TSCE::CellReferenceArchive* ReferenceArchive::mutable_cell_reference() {
  set_has_cell_reference();
  if (cell_reference_ == NULL) cell_reference_ = new ::TSCE::CellReferenceArchive;
  return cell_reference_;
}
inline ::TSCE::CellReferenceArchive* ReferenceArchive::release_cell_reference() {
  clear_has_cell_reference();
  ::TSCE::CellReferenceArchive* temp = cell_reference_;
  cell_reference_ = NULL;
  return temp;
}
inline void ReferenceArchive::set_allocated_cell_reference(::TSCE::CellReferenceArchive* cell_reference) {
  delete cell_reference_;
  cell_reference_ = cell_reference;
  if (cell_reference) {
    set_has_cell_reference();
  } else {
    clear_has_cell_reference();
  }
}

// optional .TSCE.RangeReferenceArchive range_reference = 3;
inline bool ReferenceArchive::has_range_reference() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReferenceArchive::set_has_range_reference() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReferenceArchive::clear_has_range_reference() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReferenceArchive::clear_range_reference() {
  if (range_reference_ != NULL) range_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_range_reference();
}
inline const ::TSCE::RangeReferenceArchive& ReferenceArchive::range_reference() const {
  return range_reference_ != NULL ? *range_reference_ : *default_instance_->range_reference_;
}
inline ::TSCE::RangeReferenceArchive* ReferenceArchive::mutable_range_reference() {
  set_has_range_reference();
  if (range_reference_ == NULL) range_reference_ = new ::TSCE::RangeReferenceArchive;
  return range_reference_;
}
inline ::TSCE::RangeReferenceArchive* ReferenceArchive::release_range_reference() {
  clear_has_range_reference();
  ::TSCE::RangeReferenceArchive* temp = range_reference_;
  range_reference_ = NULL;
  return temp;
}
inline void ReferenceArchive::set_allocated_range_reference(::TSCE::RangeReferenceArchive* range_reference) {
  delete range_reference_;
  range_reference_ = range_reference;
  if (range_reference) {
    set_has_range_reference();
  } else {
    clear_has_range_reference();
  }
}

// -------------------------------------------------------------------

// EdgeArchive

// required uint32 column = 1;
inline bool EdgeArchive::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeArchive::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeArchive::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 EdgeArchive::column() const {
  return column_;
}
inline void EdgeArchive::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// required uint32 row = 2;
inline bool EdgeArchive::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgeArchive::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgeArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgeArchive::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 EdgeArchive::row() const {
  return row_;
}
inline void EdgeArchive::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// required bool is_precedent = 3;
inline bool EdgeArchive::has_is_precedent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EdgeArchive::set_has_is_precedent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EdgeArchive::clear_has_is_precedent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EdgeArchive::clear_is_precedent() {
  is_precedent_ = false;
  clear_has_is_precedent();
}
inline bool EdgeArchive::is_precedent() const {
  return is_precedent_;
}
inline void EdgeArchive::set_is_precedent(bool value) {
  set_has_is_precedent();
  is_precedent_ = value;
}

// optional .TSCE.CFUUIDArchive owner_id = 4;
inline bool EdgeArchive::has_owner_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EdgeArchive::set_has_owner_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EdgeArchive::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EdgeArchive::clear_owner_id() {
  if (owner_id_ != NULL) owner_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_owner_id();
}
inline const ::TSCE::CFUUIDArchive& EdgeArchive::owner_id() const {
  return owner_id_ != NULL ? *owner_id_ : *default_instance_->owner_id_;
}
inline ::TSCE::CFUUIDArchive* EdgeArchive::mutable_owner_id() {
  set_has_owner_id();
  if (owner_id_ == NULL) owner_id_ = new ::TSCE::CFUUIDArchive;
  return owner_id_;
}
inline ::TSCE::CFUUIDArchive* EdgeArchive::release_owner_id() {
  clear_has_owner_id();
  ::TSCE::CFUUIDArchive* temp = owner_id_;
  owner_id_ = NULL;
  return temp;
}
inline void EdgeArchive::set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id) {
  delete owner_id_;
  owner_id_ = owner_id;
  if (owner_id) {
    set_has_owner_id();
  } else {
    clear_has_owner_id();
  }
}

// -------------------------------------------------------------------

// EdgesArchive

// repeated uint32 packed_edge_without_owner = 9;
inline int EdgesArchive::packed_edge_without_owner_size() const {
  return packed_edge_without_owner_.size();
}
inline void EdgesArchive::clear_packed_edge_without_owner() {
  packed_edge_without_owner_.Clear();
}
inline ::google::protobuf::uint32 EdgesArchive::packed_edge_without_owner(int index) const {
  return packed_edge_without_owner_.Get(index);
}
inline void EdgesArchive::set_packed_edge_without_owner(int index, ::google::protobuf::uint32 value) {
  packed_edge_without_owner_.Set(index, value);
}
inline void EdgesArchive::add_packed_edge_without_owner(::google::protobuf::uint32 value) {
  packed_edge_without_owner_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EdgesArchive::packed_edge_without_owner() const {
  return packed_edge_without_owner_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EdgesArchive::mutable_packed_edge_without_owner() {
  return &packed_edge_without_owner_;
}

// repeated uint32 packed_edge_with_owner = 10;
inline int EdgesArchive::packed_edge_with_owner_size() const {
  return packed_edge_with_owner_.size();
}
inline void EdgesArchive::clear_packed_edge_with_owner() {
  packed_edge_with_owner_.Clear();
}
inline ::google::protobuf::uint32 EdgesArchive::packed_edge_with_owner(int index) const {
  return packed_edge_with_owner_.Get(index);
}
inline void EdgesArchive::set_packed_edge_with_owner(int index, ::google::protobuf::uint32 value) {
  packed_edge_with_owner_.Set(index, value);
}
inline void EdgesArchive::add_packed_edge_with_owner(::google::protobuf::uint32 value) {
  packed_edge_with_owner_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EdgesArchive::packed_edge_with_owner() const {
  return packed_edge_with_owner_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EdgesArchive::mutable_packed_edge_with_owner() {
  return &packed_edge_with_owner_;
}

// repeated .TSCE.CFUUIDArchive owner_id_for_edge = 11;
inline int EdgesArchive::owner_id_for_edge_size() const {
  return owner_id_for_edge_.size();
}
inline void EdgesArchive::clear_owner_id_for_edge() {
  owner_id_for_edge_.Clear();
}
inline const ::TSCE::CFUUIDArchive& EdgesArchive::owner_id_for_edge(int index) const {
  return owner_id_for_edge_.Get(index);
}
inline ::TSCE::CFUUIDArchive* EdgesArchive::mutable_owner_id_for_edge(int index) {
  return owner_id_for_edge_.Mutable(index);
}
inline ::TSCE::CFUUIDArchive* EdgesArchive::add_owner_id_for_edge() {
  return owner_id_for_edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CFUUIDArchive >&
EdgesArchive::owner_id_for_edge() const {
  return owner_id_for_edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CFUUIDArchive >*
EdgesArchive::mutable_owner_id_for_edge() {
  return &owner_id_for_edge_;
}

// repeated uint32 internal_owner_id_for_edge = 12;
inline int EdgesArchive::internal_owner_id_for_edge_size() const {
  return internal_owner_id_for_edge_.size();
}
inline void EdgesArchive::clear_internal_owner_id_for_edge() {
  internal_owner_id_for_edge_.Clear();
}
inline ::google::protobuf::uint32 EdgesArchive::internal_owner_id_for_edge(int index) const {
  return internal_owner_id_for_edge_.Get(index);
}
inline void EdgesArchive::set_internal_owner_id_for_edge(int index, ::google::protobuf::uint32 value) {
  internal_owner_id_for_edge_.Set(index, value);
}
inline void EdgesArchive::add_internal_owner_id_for_edge(::google::protobuf::uint32 value) {
  internal_owner_id_for_edge_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EdgesArchive::internal_owner_id_for_edge() const {
  return internal_owner_id_for_edge_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EdgesArchive::mutable_internal_owner_id_for_edge() {
  return &internal_owner_id_for_edge_;
}

// -------------------------------------------------------------------

// CellRecordArchive

// required uint32 column = 1;
inline bool CellRecordArchive::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellRecordArchive::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellRecordArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellRecordArchive::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 CellRecordArchive::column() const {
  return column_;
}
inline void CellRecordArchive::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// required uint32 row = 2;
inline bool CellRecordArchive::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellRecordArchive::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellRecordArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellRecordArchive::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 CellRecordArchive::row() const {
  return row_;
}
inline void CellRecordArchive::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// optional uint32 dirty_self_plus_precedents_count = 3 [default = 0];
inline bool CellRecordArchive::has_dirty_self_plus_precedents_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellRecordArchive::set_has_dirty_self_plus_precedents_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellRecordArchive::clear_has_dirty_self_plus_precedents_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellRecordArchive::clear_dirty_self_plus_precedents_count() {
  dirty_self_plus_precedents_count_ = 0u;
  clear_has_dirty_self_plus_precedents_count();
}
inline ::google::protobuf::uint32 CellRecordArchive::dirty_self_plus_precedents_count() const {
  return dirty_self_plus_precedents_count_;
}
inline void CellRecordArchive::set_dirty_self_plus_precedents_count(::google::protobuf::uint32 value) {
  set_has_dirty_self_plus_precedents_count();
  dirty_self_plus_precedents_count_ = value;
}

// optional bool is_in_a_cycle = 4 [default = false];
inline bool CellRecordArchive::has_is_in_a_cycle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CellRecordArchive::set_has_is_in_a_cycle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CellRecordArchive::clear_has_is_in_a_cycle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CellRecordArchive::clear_is_in_a_cycle() {
  is_in_a_cycle_ = false;
  clear_has_is_in_a_cycle();
}
inline bool CellRecordArchive::is_in_a_cycle() const {
  return is_in_a_cycle_;
}
inline void CellRecordArchive::set_is_in_a_cycle(bool value) {
  set_has_is_in_a_cycle();
  is_in_a_cycle_ = value;
}

// repeated .TSCE.EdgeArchive edge = 5 [deprecated = true];
inline int CellRecordArchive::edge_size() const {
  return edge_.size();
}
inline void CellRecordArchive::clear_edge() {
  edge_.Clear();
}
inline const ::TSCE::EdgeArchive& CellRecordArchive::edge(int index) const {
  return edge_.Get(index);
}
inline ::TSCE::EdgeArchive* CellRecordArchive::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::TSCE::EdgeArchive* CellRecordArchive::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::EdgeArchive >&
CellRecordArchive::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::EdgeArchive >*
CellRecordArchive::mutable_edge() {
  return &edge_;
}

// optional bool contains_a_formula = 6 [default = true];
inline bool CellRecordArchive::has_contains_a_formula() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CellRecordArchive::set_has_contains_a_formula() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CellRecordArchive::clear_has_contains_a_formula() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CellRecordArchive::clear_contains_a_formula() {
  contains_a_formula_ = true;
  clear_has_contains_a_formula();
}
inline bool CellRecordArchive::contains_a_formula() const {
  return contains_a_formula_;
}
inline void CellRecordArchive::set_contains_a_formula(bool value) {
  set_has_contains_a_formula();
  contains_a_formula_ = value;
}

// optional bool has_calculated_precedents = 7 [default = false];
inline bool CellRecordArchive::has_has_calculated_precedents() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CellRecordArchive::set_has_has_calculated_precedents() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CellRecordArchive::clear_has_has_calculated_precedents() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CellRecordArchive::clear_has_calculated_precedents() {
  has_calculated_precedents_ = false;
  clear_has_has_calculated_precedents();
}
inline bool CellRecordArchive::has_calculated_precedents() const {
  return has_calculated_precedents_;
}
inline void CellRecordArchive::set_has_calculated_precedents(bool value) {
  set_has_has_calculated_precedents();
  has_calculated_precedents_ = value;
}

// optional bool calculate_precedents_on_next_recalc = 8 [default = false, deprecated = true];
inline bool CellRecordArchive::has_calculate_precedents_on_next_recalc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CellRecordArchive::set_has_calculate_precedents_on_next_recalc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CellRecordArchive::clear_has_calculate_precedents_on_next_recalc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CellRecordArchive::clear_calculate_precedents_on_next_recalc() {
  calculate_precedents_on_next_recalc_ = false;
  clear_has_calculate_precedents_on_next_recalc();
}
inline bool CellRecordArchive::calculate_precedents_on_next_recalc() const {
  return calculate_precedents_on_next_recalc_;
}
inline void CellRecordArchive::set_calculate_precedents_on_next_recalc(bool value) {
  set_has_calculate_precedents_on_next_recalc();
  calculate_precedents_on_next_recalc_ = value;
}

// optional bool translate_for_excel_import_on_next_recalc = 10 [default = false];
inline bool CellRecordArchive::has_translate_for_excel_import_on_next_recalc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CellRecordArchive::set_has_translate_for_excel_import_on_next_recalc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CellRecordArchive::clear_has_translate_for_excel_import_on_next_recalc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CellRecordArchive::clear_translate_for_excel_import_on_next_recalc() {
  translate_for_excel_import_on_next_recalc_ = false;
  clear_has_translate_for_excel_import_on_next_recalc();
}
inline bool CellRecordArchive::translate_for_excel_import_on_next_recalc() const {
  return translate_for_excel_import_on_next_recalc_;
}
inline void CellRecordArchive::set_translate_for_excel_import_on_next_recalc(bool value) {
  set_has_translate_for_excel_import_on_next_recalc();
  translate_for_excel_import_on_next_recalc_ = value;
}

// optional .TSCE.EdgesArchive edges = 9;
inline bool CellRecordArchive::has_edges() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CellRecordArchive::set_has_edges() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CellRecordArchive::clear_has_edges() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CellRecordArchive::clear_edges() {
  if (edges_ != NULL) edges_->::TSCE::EdgesArchive::Clear();
  clear_has_edges();
}
inline const ::TSCE::EdgesArchive& CellRecordArchive::edges() const {
  return edges_ != NULL ? *edges_ : *default_instance_->edges_;
}
inline ::TSCE::EdgesArchive* CellRecordArchive::mutable_edges() {
  set_has_edges();
  if (edges_ == NULL) edges_ = new ::TSCE::EdgesArchive;
  return edges_;
}
inline ::TSCE::EdgesArchive* CellRecordArchive::release_edges() {
  clear_has_edges();
  ::TSCE::EdgesArchive* temp = edges_;
  edges_ = NULL;
  return temp;
}
inline void CellRecordArchive::set_allocated_edges(::TSCE::EdgesArchive* edges) {
  delete edges_;
  edges_ = edges;
  if (edges) {
    set_has_edges();
  } else {
    clear_has_edges();
  }
}

// -------------------------------------------------------------------

// CellDependenciesArchive

// repeated .TSCE.CellRecordArchive cell_record = 1;
inline int CellDependenciesArchive::cell_record_size() const {
  return cell_record_.size();
}
inline void CellDependenciesArchive::clear_cell_record() {
  cell_record_.Clear();
}
inline const ::TSCE::CellRecordArchive& CellDependenciesArchive::cell_record(int index) const {
  return cell_record_.Get(index);
}
inline ::TSCE::CellRecordArchive* CellDependenciesArchive::mutable_cell_record(int index) {
  return cell_record_.Mutable(index);
}
inline ::TSCE::CellRecordArchive* CellDependenciesArchive::add_cell_record() {
  return cell_record_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellRecordArchive >&
CellDependenciesArchive::cell_record() const {
  return cell_record_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellRecordArchive >*
CellDependenciesArchive::mutable_cell_record() {
  return &cell_record_;
}

// optional uint32 num_dirty_cells = 2;
inline bool CellDependenciesArchive::has_num_dirty_cells() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellDependenciesArchive::set_has_num_dirty_cells() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellDependenciesArchive::clear_has_num_dirty_cells() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellDependenciesArchive::clear_num_dirty_cells() {
  num_dirty_cells_ = 0u;
  clear_has_num_dirty_cells();
}
inline ::google::protobuf::uint32 CellDependenciesArchive::num_dirty_cells() const {
  return num_dirty_cells_;
}
inline void CellDependenciesArchive::set_num_dirty_cells(::google::protobuf::uint32 value) {
  set_has_num_dirty_cells();
  num_dirty_cells_ = value;
}

// -------------------------------------------------------------------

// VolatileDependenciesArchive

// repeated uint32 volatile_time_cell_column = 1;
inline int VolatileDependenciesArchive::volatile_time_cell_column_size() const {
  return volatile_time_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_time_cell_column() {
  volatile_time_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_time_cell_column(int index) const {
  return volatile_time_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_time_cell_column(int index, ::google::protobuf::uint32 value) {
  volatile_time_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_time_cell_column(::google::protobuf::uint32 value) {
  volatile_time_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_time_cell_column() const {
  return volatile_time_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_time_cell_column() {
  return &volatile_time_cell_column_;
}

// repeated uint32 volatile_time_cell_row = 2;
inline int VolatileDependenciesArchive::volatile_time_cell_row_size() const {
  return volatile_time_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_time_cell_row() {
  volatile_time_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_time_cell_row(int index) const {
  return volatile_time_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_time_cell_row(int index, ::google::protobuf::uint32 value) {
  volatile_time_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_time_cell_row(::google::protobuf::uint32 value) {
  volatile_time_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_time_cell_row() const {
  return volatile_time_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_time_cell_row() {
  return &volatile_time_cell_row_;
}

// repeated uint32 volatile_random_cell_column = 3;
inline int VolatileDependenciesArchive::volatile_random_cell_column_size() const {
  return volatile_random_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_random_cell_column() {
  volatile_random_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_random_cell_column(int index) const {
  return volatile_random_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_random_cell_column(int index, ::google::protobuf::uint32 value) {
  volatile_random_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_random_cell_column(::google::protobuf::uint32 value) {
  volatile_random_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_random_cell_column() const {
  return volatile_random_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_random_cell_column() {
  return &volatile_random_cell_column_;
}

// repeated uint32 volatile_random_cell_row = 4;
inline int VolatileDependenciesArchive::volatile_random_cell_row_size() const {
  return volatile_random_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_random_cell_row() {
  volatile_random_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_random_cell_row(int index) const {
  return volatile_random_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_random_cell_row(int index, ::google::protobuf::uint32 value) {
  volatile_random_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_random_cell_row(::google::protobuf::uint32 value) {
  volatile_random_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_random_cell_row() const {
  return volatile_random_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_random_cell_row() {
  return &volatile_random_cell_row_;
}

// repeated uint32 volatile_locale_cell_column = 15;
inline int VolatileDependenciesArchive::volatile_locale_cell_column_size() const {
  return volatile_locale_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_locale_cell_column() {
  volatile_locale_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_locale_cell_column(int index) const {
  return volatile_locale_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_locale_cell_column(int index, ::google::protobuf::uint32 value) {
  volatile_locale_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_locale_cell_column(::google::protobuf::uint32 value) {
  volatile_locale_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_locale_cell_column() const {
  return volatile_locale_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_locale_cell_column() {
  return &volatile_locale_cell_column_;
}

// repeated uint32 volatile_locale_cell_row = 16;
inline int VolatileDependenciesArchive::volatile_locale_cell_row_size() const {
  return volatile_locale_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_locale_cell_row() {
  volatile_locale_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_locale_cell_row(int index) const {
  return volatile_locale_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_locale_cell_row(int index, ::google::protobuf::uint32 value) {
  volatile_locale_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_locale_cell_row(::google::protobuf::uint32 value) {
  volatile_locale_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_locale_cell_row() const {
  return volatile_locale_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_locale_cell_row() {
  return &volatile_locale_cell_row_;
}

// repeated uint32 volatile_location_cell_column = 5;
inline int VolatileDependenciesArchive::volatile_location_cell_column_size() const {
  return volatile_location_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_location_cell_column() {
  volatile_location_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_location_cell_column(int index) const {
  return volatile_location_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_location_cell_column(int index, ::google::protobuf::uint32 value) {
  volatile_location_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_location_cell_column(::google::protobuf::uint32 value) {
  volatile_location_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_location_cell_column() const {
  return volatile_location_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_location_cell_column() {
  return &volatile_location_cell_column_;
}

// repeated uint32 volatile_location_cell_row = 6;
inline int VolatileDependenciesArchive::volatile_location_cell_row_size() const {
  return volatile_location_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_location_cell_row() {
  volatile_location_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_location_cell_row(int index) const {
  return volatile_location_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_location_cell_row(int index, ::google::protobuf::uint32 value) {
  volatile_location_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_location_cell_row(::google::protobuf::uint32 value) {
  volatile_location_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_location_cell_row() const {
  return volatile_location_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_location_cell_row() {
  return &volatile_location_cell_row_;
}

// repeated uint32 volatile_compass_cell_column = 7;
inline int VolatileDependenciesArchive::volatile_compass_cell_column_size() const {
  return volatile_compass_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_compass_cell_column() {
  volatile_compass_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_compass_cell_column(int index) const {
  return volatile_compass_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_compass_cell_column(int index, ::google::protobuf::uint32 value) {
  volatile_compass_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_compass_cell_column(::google::protobuf::uint32 value) {
  volatile_compass_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_compass_cell_column() const {
  return volatile_compass_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_compass_cell_column() {
  return &volatile_compass_cell_column_;
}

// repeated uint32 volatile_compass_cell_row = 8;
inline int VolatileDependenciesArchive::volatile_compass_cell_row_size() const {
  return volatile_compass_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_compass_cell_row() {
  volatile_compass_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_compass_cell_row(int index) const {
  return volatile_compass_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_compass_cell_row(int index, ::google::protobuf::uint32 value) {
  volatile_compass_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_compass_cell_row(::google::protobuf::uint32 value) {
  volatile_compass_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_compass_cell_row() const {
  return volatile_compass_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_compass_cell_row() {
  return &volatile_compass_cell_row_;
}

// repeated uint32 volatile_sheet_table_name_cell_column = 17;
inline int VolatileDependenciesArchive::volatile_sheet_table_name_cell_column_size() const {
  return volatile_sheet_table_name_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_sheet_table_name_cell_column() {
  volatile_sheet_table_name_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_sheet_table_name_cell_column(int index) const {
  return volatile_sheet_table_name_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_sheet_table_name_cell_column(int index, ::google::protobuf::uint32 value) {
  volatile_sheet_table_name_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_sheet_table_name_cell_column(::google::protobuf::uint32 value) {
  volatile_sheet_table_name_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_sheet_table_name_cell_column() const {
  return volatile_sheet_table_name_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_sheet_table_name_cell_column() {
  return &volatile_sheet_table_name_cell_column_;
}

// repeated uint32 volatile_sheet_table_name_cell_row = 18;
inline int VolatileDependenciesArchive::volatile_sheet_table_name_cell_row_size() const {
  return volatile_sheet_table_name_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_sheet_table_name_cell_row() {
  volatile_sheet_table_name_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::volatile_sheet_table_name_cell_row(int index) const {
  return volatile_sheet_table_name_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_volatile_sheet_table_name_cell_row(int index, ::google::protobuf::uint32 value) {
  volatile_sheet_table_name_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_volatile_sheet_table_name_cell_row(::google::protobuf::uint32 value) {
  volatile_sheet_table_name_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::volatile_sheet_table_name_cell_row() const {
  return volatile_sheet_table_name_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_volatile_sheet_table_name_cell_row() {
  return &volatile_sheet_table_name_cell_row_;
}

// repeated uint32 calculated_dependency_cell_column = 9;
inline int VolatileDependenciesArchive::calculated_dependency_cell_column_size() const {
  return calculated_dependency_cell_column_.size();
}
inline void VolatileDependenciesArchive::clear_calculated_dependency_cell_column() {
  calculated_dependency_cell_column_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::calculated_dependency_cell_column(int index) const {
  return calculated_dependency_cell_column_.Get(index);
}
inline void VolatileDependenciesArchive::set_calculated_dependency_cell_column(int index, ::google::protobuf::uint32 value) {
  calculated_dependency_cell_column_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_calculated_dependency_cell_column(::google::protobuf::uint32 value) {
  calculated_dependency_cell_column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::calculated_dependency_cell_column() const {
  return calculated_dependency_cell_column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_calculated_dependency_cell_column() {
  return &calculated_dependency_cell_column_;
}

// repeated uint32 calculated_dependency_cell_row = 10;
inline int VolatileDependenciesArchive::calculated_dependency_cell_row_size() const {
  return calculated_dependency_cell_row_.size();
}
inline void VolatileDependenciesArchive::clear_calculated_dependency_cell_row() {
  calculated_dependency_cell_row_.Clear();
}
inline ::google::protobuf::uint32 VolatileDependenciesArchive::calculated_dependency_cell_row(int index) const {
  return calculated_dependency_cell_row_.Get(index);
}
inline void VolatileDependenciesArchive::set_calculated_dependency_cell_row(int index, ::google::protobuf::uint32 value) {
  calculated_dependency_cell_row_.Set(index, value);
}
inline void VolatileDependenciesArchive::add_calculated_dependency_cell_row(::google::protobuf::uint32 value) {
  calculated_dependency_cell_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VolatileDependenciesArchive::calculated_dependency_cell_row() const {
  return calculated_dependency_cell_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VolatileDependenciesArchive::mutable_calculated_dependency_cell_row() {
  return &calculated_dependency_cell_row_;
}

// repeated .TSCE.CellReferenceArchive volatile_geometry_cell_reference = 13;
inline int VolatileDependenciesArchive::volatile_geometry_cell_reference_size() const {
  return volatile_geometry_cell_reference_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_geometry_cell_reference() {
  volatile_geometry_cell_reference_.Clear();
}
inline const ::TSCE::CellReferenceArchive& VolatileDependenciesArchive::volatile_geometry_cell_reference(int index) const {
  return volatile_geometry_cell_reference_.Get(index);
}
inline ::TSCE::CellReferenceArchive* VolatileDependenciesArchive::mutable_volatile_geometry_cell_reference(int index) {
  return volatile_geometry_cell_reference_.Mutable(index);
}
inline ::TSCE::CellReferenceArchive* VolatileDependenciesArchive::add_volatile_geometry_cell_reference() {
  return volatile_geometry_cell_reference_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >&
VolatileDependenciesArchive::volatile_geometry_cell_reference() const {
  return volatile_geometry_cell_reference_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >*
VolatileDependenciesArchive::mutable_volatile_geometry_cell_reference() {
  return &volatile_geometry_cell_reference_;
}

// repeated .TSCE.CellCoordinateArchive volatile_geometry_cell = 11;
inline int VolatileDependenciesArchive::volatile_geometry_cell_size() const {
  return volatile_geometry_cell_.size();
}
inline void VolatileDependenciesArchive::clear_volatile_geometry_cell() {
  volatile_geometry_cell_.Clear();
}
inline const ::TSCE::CellCoordinateArchive& VolatileDependenciesArchive::volatile_geometry_cell(int index) const {
  return volatile_geometry_cell_.Get(index);
}
inline ::TSCE::CellCoordinateArchive* VolatileDependenciesArchive::mutable_volatile_geometry_cell(int index) {
  return volatile_geometry_cell_.Mutable(index);
}
inline ::TSCE::CellCoordinateArchive* VolatileDependenciesArchive::add_volatile_geometry_cell() {
  return volatile_geometry_cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >&
VolatileDependenciesArchive::volatile_geometry_cell() const {
  return volatile_geometry_cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >*
VolatileDependenciesArchive::mutable_volatile_geometry_cell() {
  return &volatile_geometry_cell_;
}

// -------------------------------------------------------------------

// RangeBackDependencyArchive

// required uint32 cell_coord_row = 1;
inline bool RangeBackDependencyArchive::has_cell_coord_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeBackDependencyArchive::set_has_cell_coord_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeBackDependencyArchive::clear_has_cell_coord_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeBackDependencyArchive::clear_cell_coord_row() {
  cell_coord_row_ = 0u;
  clear_has_cell_coord_row();
}
inline ::google::protobuf::uint32 RangeBackDependencyArchive::cell_coord_row() const {
  return cell_coord_row_;
}
inline void RangeBackDependencyArchive::set_cell_coord_row(::google::protobuf::uint32 value) {
  set_has_cell_coord_row();
  cell_coord_row_ = value;
}

// required uint32 cell_coord_column = 2;
inline bool RangeBackDependencyArchive::has_cell_coord_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeBackDependencyArchive::set_has_cell_coord_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeBackDependencyArchive::clear_has_cell_coord_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeBackDependencyArchive::clear_cell_coord_column() {
  cell_coord_column_ = 0u;
  clear_has_cell_coord_column();
}
inline ::google::protobuf::uint32 RangeBackDependencyArchive::cell_coord_column() const {
  return cell_coord_column_;
}
inline void RangeBackDependencyArchive::set_cell_coord_column(::google::protobuf::uint32 value) {
  set_has_cell_coord_column();
  cell_coord_column_ = value;
}

// optional .TSCE.RangeReferenceArchive range_reference = 3;
inline bool RangeBackDependencyArchive::has_range_reference() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeBackDependencyArchive::set_has_range_reference() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeBackDependencyArchive::clear_has_range_reference() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeBackDependencyArchive::clear_range_reference() {
  if (range_reference_ != NULL) range_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_range_reference();
}
inline const ::TSCE::RangeReferenceArchive& RangeBackDependencyArchive::range_reference() const {
  return range_reference_ != NULL ? *range_reference_ : *default_instance_->range_reference_;
}
inline ::TSCE::RangeReferenceArchive* RangeBackDependencyArchive::mutable_range_reference() {
  set_has_range_reference();
  if (range_reference_ == NULL) range_reference_ = new ::TSCE::RangeReferenceArchive;
  return range_reference_;
}
inline ::TSCE::RangeReferenceArchive* RangeBackDependencyArchive::release_range_reference() {
  clear_has_range_reference();
  ::TSCE::RangeReferenceArchive* temp = range_reference_;
  range_reference_ = NULL;
  return temp;
}
inline void RangeBackDependencyArchive::set_allocated_range_reference(::TSCE::RangeReferenceArchive* range_reference) {
  delete range_reference_;
  range_reference_ = range_reference;
  if (range_reference) {
    set_has_range_reference();
  } else {
    clear_has_range_reference();
  }
}

// optional .TSCE.InternalRangeReferenceArchive internal_range_reference = 4;
inline bool RangeBackDependencyArchive::has_internal_range_reference() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RangeBackDependencyArchive::set_has_internal_range_reference() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RangeBackDependencyArchive::clear_has_internal_range_reference() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RangeBackDependencyArchive::clear_internal_range_reference() {
  if (internal_range_reference_ != NULL) internal_range_reference_->::TSCE::InternalRangeReferenceArchive::Clear();
  clear_has_internal_range_reference();
}
inline const ::TSCE::InternalRangeReferenceArchive& RangeBackDependencyArchive::internal_range_reference() const {
  return internal_range_reference_ != NULL ? *internal_range_reference_ : *default_instance_->internal_range_reference_;
}
inline ::TSCE::InternalRangeReferenceArchive* RangeBackDependencyArchive::mutable_internal_range_reference() {
  set_has_internal_range_reference();
  if (internal_range_reference_ == NULL) internal_range_reference_ = new ::TSCE::InternalRangeReferenceArchive;
  return internal_range_reference_;
}
inline ::TSCE::InternalRangeReferenceArchive* RangeBackDependencyArchive::release_internal_range_reference() {
  clear_has_internal_range_reference();
  ::TSCE::InternalRangeReferenceArchive* temp = internal_range_reference_;
  internal_range_reference_ = NULL;
  return temp;
}
inline void RangeBackDependencyArchive::set_allocated_internal_range_reference(::TSCE::InternalRangeReferenceArchive* internal_range_reference) {
  delete internal_range_reference_;
  internal_range_reference_ = internal_range_reference;
  if (internal_range_reference) {
    set_has_internal_range_reference();
  } else {
    clear_has_internal_range_reference();
  }
}

// -------------------------------------------------------------------

// RTreeInternalNodeContentsArchive

// repeated uint32 min = 1;
inline int RTreeInternalNodeContentsArchive::min_size() const {
  return min_.size();
}
inline void RTreeInternalNodeContentsArchive::clear_min() {
  min_.Clear();
}
inline ::google::protobuf::uint32 RTreeInternalNodeContentsArchive::min(int index) const {
  return min_.Get(index);
}
inline void RTreeInternalNodeContentsArchive::set_min(int index, ::google::protobuf::uint32 value) {
  min_.Set(index, value);
}
inline void RTreeInternalNodeContentsArchive::add_min(::google::protobuf::uint32 value) {
  min_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RTreeInternalNodeContentsArchive::min() const {
  return min_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RTreeInternalNodeContentsArchive::mutable_min() {
  return &min_;
}

// repeated uint32 max = 2;
inline int RTreeInternalNodeContentsArchive::max_size() const {
  return max_.size();
}
inline void RTreeInternalNodeContentsArchive::clear_max() {
  max_.Clear();
}
inline ::google::protobuf::uint32 RTreeInternalNodeContentsArchive::max(int index) const {
  return max_.Get(index);
}
inline void RTreeInternalNodeContentsArchive::set_max(int index, ::google::protobuf::uint32 value) {
  max_.Set(index, value);
}
inline void RTreeInternalNodeContentsArchive::add_max(::google::protobuf::uint32 value) {
  max_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RTreeInternalNodeContentsArchive::max() const {
  return max_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RTreeInternalNodeContentsArchive::mutable_max() {
  return &max_;
}

// required .TSCE.RTreeNodeArchive child = 3;
inline bool RTreeInternalNodeContentsArchive::has_child() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTreeInternalNodeContentsArchive::set_has_child() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTreeInternalNodeContentsArchive::clear_has_child() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTreeInternalNodeContentsArchive::clear_child() {
  if (child_ != NULL) child_->::TSCE::RTreeNodeArchive::Clear();
  clear_has_child();
}
inline const ::TSCE::RTreeNodeArchive& RTreeInternalNodeContentsArchive::child() const {
  return child_ != NULL ? *child_ : *default_instance_->child_;
}
inline ::TSCE::RTreeNodeArchive* RTreeInternalNodeContentsArchive::mutable_child() {
  set_has_child();
  if (child_ == NULL) child_ = new ::TSCE::RTreeNodeArchive;
  return child_;
}
inline ::TSCE::RTreeNodeArchive* RTreeInternalNodeContentsArchive::release_child() {
  clear_has_child();
  ::TSCE::RTreeNodeArchive* temp = child_;
  child_ = NULL;
  return temp;
}
inline void RTreeInternalNodeContentsArchive::set_allocated_child(::TSCE::RTreeNodeArchive* child) {
  delete child_;
  child_ = child;
  if (child) {
    set_has_child();
  } else {
    clear_has_child();
  }
}

// -------------------------------------------------------------------

// RTreeLeafNodeContentsArchive

// repeated uint32 min = 1;
inline int RTreeLeafNodeContentsArchive::min_size() const {
  return min_.size();
}
inline void RTreeLeafNodeContentsArchive::clear_min() {
  min_.Clear();
}
inline ::google::protobuf::uint32 RTreeLeafNodeContentsArchive::min(int index) const {
  return min_.Get(index);
}
inline void RTreeLeafNodeContentsArchive::set_min(int index, ::google::protobuf::uint32 value) {
  min_.Set(index, value);
}
inline void RTreeLeafNodeContentsArchive::add_min(::google::protobuf::uint32 value) {
  min_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RTreeLeafNodeContentsArchive::min() const {
  return min_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RTreeLeafNodeContentsArchive::mutable_min() {
  return &min_;
}

// repeated uint32 max = 2;
inline int RTreeLeafNodeContentsArchive::max_size() const {
  return max_.size();
}
inline void RTreeLeafNodeContentsArchive::clear_max() {
  max_.Clear();
}
inline ::google::protobuf::uint32 RTreeLeafNodeContentsArchive::max(int index) const {
  return max_.Get(index);
}
inline void RTreeLeafNodeContentsArchive::set_max(int index, ::google::protobuf::uint32 value) {
  max_.Set(index, value);
}
inline void RTreeLeafNodeContentsArchive::add_max(::google::protobuf::uint32 value) {
  max_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RTreeLeafNodeContentsArchive::max() const {
  return max_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RTreeLeafNodeContentsArchive::mutable_max() {
  return &max_;
}

// required .TSCE.CellReferenceArchive cell_reference = 3;
inline bool RTreeLeafNodeContentsArchive::has_cell_reference() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTreeLeafNodeContentsArchive::set_has_cell_reference() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTreeLeafNodeContentsArchive::clear_has_cell_reference() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTreeLeafNodeContentsArchive::clear_cell_reference() {
  if (cell_reference_ != NULL) cell_reference_->::TSCE::CellReferenceArchive::Clear();
  clear_has_cell_reference();
}
inline const ::TSCE::CellReferenceArchive& RTreeLeafNodeContentsArchive::cell_reference() const {
  return cell_reference_ != NULL ? *cell_reference_ : *default_instance_->cell_reference_;
}
inline ::TSCE::CellReferenceArchive* RTreeLeafNodeContentsArchive::mutable_cell_reference() {
  set_has_cell_reference();
  if (cell_reference_ == NULL) cell_reference_ = new ::TSCE::CellReferenceArchive;
  return cell_reference_;
}
inline ::TSCE::CellReferenceArchive* RTreeLeafNodeContentsArchive::release_cell_reference() {
  clear_has_cell_reference();
  ::TSCE::CellReferenceArchive* temp = cell_reference_;
  cell_reference_ = NULL;
  return temp;
}
inline void RTreeLeafNodeContentsArchive::set_allocated_cell_reference(::TSCE::CellReferenceArchive* cell_reference) {
  delete cell_reference_;
  cell_reference_ = cell_reference;
  if (cell_reference) {
    set_has_cell_reference();
  } else {
    clear_has_cell_reference();
  }
}

// -------------------------------------------------------------------

// RTreeNodeArchive

// required uint32 level = 1;
inline bool RTreeNodeArchive::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTreeNodeArchive::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTreeNodeArchive::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTreeNodeArchive::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 RTreeNodeArchive::level() const {
  return level_;
}
inline void RTreeNodeArchive::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 count = 2;
inline bool RTreeNodeArchive::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTreeNodeArchive::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTreeNodeArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTreeNodeArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RTreeNodeArchive::count() const {
  return count_;
}
inline void RTreeNodeArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .TSCE.RTreeInternalNodeContentsArchive internal_node_contents = 3;
inline int RTreeNodeArchive::internal_node_contents_size() const {
  return internal_node_contents_.size();
}
inline void RTreeNodeArchive::clear_internal_node_contents() {
  internal_node_contents_.Clear();
}
inline const ::TSCE::RTreeInternalNodeContentsArchive& RTreeNodeArchive::internal_node_contents(int index) const {
  return internal_node_contents_.Get(index);
}
inline ::TSCE::RTreeInternalNodeContentsArchive* RTreeNodeArchive::mutable_internal_node_contents(int index) {
  return internal_node_contents_.Mutable(index);
}
inline ::TSCE::RTreeInternalNodeContentsArchive* RTreeNodeArchive::add_internal_node_contents() {
  return internal_node_contents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeInternalNodeContentsArchive >&
RTreeNodeArchive::internal_node_contents() const {
  return internal_node_contents_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeInternalNodeContentsArchive >*
RTreeNodeArchive::mutable_internal_node_contents() {
  return &internal_node_contents_;
}

// repeated .TSCE.RTreeLeafNodeContentsArchive leaf_node_contents = 4;
inline int RTreeNodeArchive::leaf_node_contents_size() const {
  return leaf_node_contents_.size();
}
inline void RTreeNodeArchive::clear_leaf_node_contents() {
  leaf_node_contents_.Clear();
}
inline const ::TSCE::RTreeLeafNodeContentsArchive& RTreeNodeArchive::leaf_node_contents(int index) const {
  return leaf_node_contents_.Get(index);
}
inline ::TSCE::RTreeLeafNodeContentsArchive* RTreeNodeArchive::mutable_leaf_node_contents(int index) {
  return leaf_node_contents_.Mutable(index);
}
inline ::TSCE::RTreeLeafNodeContentsArchive* RTreeNodeArchive::add_leaf_node_contents() {
  return leaf_node_contents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeLeafNodeContentsArchive >&
RTreeNodeArchive::leaf_node_contents() const {
  return leaf_node_contents_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::RTreeLeafNodeContentsArchive >*
RTreeNodeArchive::mutable_leaf_node_contents() {
  return &leaf_node_contents_;
}

// -------------------------------------------------------------------

// RTreeArchive

// required uint32 data_file_id = 1;
inline bool RTreeArchive::has_data_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTreeArchive::set_has_data_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTreeArchive::clear_has_data_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTreeArchive::clear_data_file_id() {
  data_file_id_ = 0u;
  clear_has_data_file_id();
}
inline ::google::protobuf::uint32 RTreeArchive::data_file_id() const {
  return data_file_id_;
}
inline void RTreeArchive::set_data_file_id(::google::protobuf::uint32 value) {
  set_has_data_file_id();
  data_file_id_ = value;
}

// required uint32 data_size = 2;
inline bool RTreeArchive::has_data_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTreeArchive::set_has_data_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTreeArchive::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTreeArchive::clear_data_size() {
  data_size_ = 0u;
  clear_has_data_size();
}
inline ::google::protobuf::uint32 RTreeArchive::data_size() const {
  return data_size_;
}
inline void RTreeArchive::set_data_size(::google::protobuf::uint32 value) {
  set_has_data_size();
  data_size_ = value;
}

// required uint32 data_num_dims = 3;
inline bool RTreeArchive::has_data_num_dims() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTreeArchive::set_has_data_num_dims() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTreeArchive::clear_has_data_num_dims() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTreeArchive::clear_data_num_dims() {
  data_num_dims_ = 0u;
  clear_has_data_num_dims();
}
inline ::google::protobuf::uint32 RTreeArchive::data_num_dims() const {
  return data_num_dims_;
}
inline void RTreeArchive::set_data_num_dims(::google::protobuf::uint32 value) {
  set_has_data_num_dims();
  data_num_dims_ = value;
}

// required uint32 data_elem_size = 4;
inline bool RTreeArchive::has_data_elem_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RTreeArchive::set_has_data_elem_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RTreeArchive::clear_has_data_elem_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RTreeArchive::clear_data_elem_size() {
  data_elem_size_ = 0u;
  clear_has_data_elem_size();
}
inline ::google::protobuf::uint32 RTreeArchive::data_elem_size() const {
  return data_elem_size_;
}
inline void RTreeArchive::set_data_elem_size(::google::protobuf::uint32 value) {
  set_has_data_elem_size();
  data_elem_size_ = value;
}

// required uint32 data_elem_real_size = 5;
inline bool RTreeArchive::has_data_elem_real_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RTreeArchive::set_has_data_elem_real_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RTreeArchive::clear_has_data_elem_real_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RTreeArchive::clear_data_elem_real_size() {
  data_elem_real_size_ = 0u;
  clear_has_data_elem_real_size();
}
inline ::google::protobuf::uint32 RTreeArchive::data_elem_real_size() const {
  return data_elem_real_size_;
}
inline void RTreeArchive::set_data_elem_real_size(::google::protobuf::uint32 value) {
  set_has_data_elem_real_size();
  data_elem_real_size_ = value;
}

// required uint32 data_max_nodes = 6;
inline bool RTreeArchive::has_data_max_nodes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RTreeArchive::set_has_data_max_nodes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RTreeArchive::clear_has_data_max_nodes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RTreeArchive::clear_data_max_nodes() {
  data_max_nodes_ = 0u;
  clear_has_data_max_nodes();
}
inline ::google::protobuf::uint32 RTreeArchive::data_max_nodes() const {
  return data_max_nodes_;
}
inline void RTreeArchive::set_data_max_nodes(::google::protobuf::uint32 value) {
  set_has_data_max_nodes();
  data_max_nodes_ = value;
}

// required uint32 data_min_nodes = 7;
inline bool RTreeArchive::has_data_min_nodes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RTreeArchive::set_has_data_min_nodes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RTreeArchive::clear_has_data_min_nodes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RTreeArchive::clear_data_min_nodes() {
  data_min_nodes_ = 0u;
  clear_has_data_min_nodes();
}
inline ::google::protobuf::uint32 RTreeArchive::data_min_nodes() const {
  return data_min_nodes_;
}
inline void RTreeArchive::set_data_min_nodes(::google::protobuf::uint32 value) {
  set_has_data_min_nodes();
  data_min_nodes_ = value;
}

// required .TSCE.RTreeNodeArchive root = 8;
inline bool RTreeArchive::has_root() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RTreeArchive::set_has_root() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RTreeArchive::clear_has_root() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RTreeArchive::clear_root() {
  if (root_ != NULL) root_->::TSCE::RTreeNodeArchive::Clear();
  clear_has_root();
}
inline const ::TSCE::RTreeNodeArchive& RTreeArchive::root() const {
  return root_ != NULL ? *root_ : *default_instance_->root_;
}
inline ::TSCE::RTreeNodeArchive* RTreeArchive::mutable_root() {
  set_has_root();
  if (root_ == NULL) root_ = new ::TSCE::RTreeNodeArchive;
  return root_;
}
inline ::TSCE::RTreeNodeArchive* RTreeArchive::release_root() {
  clear_has_root();
  ::TSCE::RTreeNodeArchive* temp = root_;
  root_ = NULL;
  return temp;
}
inline void RTreeArchive::set_allocated_root(::TSCE::RTreeNodeArchive* root) {
  delete root_;
  root_ = root;
  if (root) {
    set_has_root();
  } else {
    clear_has_root();
  }
}

// -------------------------------------------------------------------

// RangeDependenciesArchive

// optional .TSCE.RTreeArchive r_tree = 1;
inline bool RangeDependenciesArchive::has_r_tree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeDependenciesArchive::set_has_r_tree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeDependenciesArchive::clear_has_r_tree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeDependenciesArchive::clear_r_tree() {
  if (r_tree_ != NULL) r_tree_->::TSCE::RTreeArchive::Clear();
  clear_has_r_tree();
}
inline const ::TSCE::RTreeArchive& RangeDependenciesArchive::r_tree() const {
  return r_tree_ != NULL ? *r_tree_ : *default_instance_->r_tree_;
}
inline ::TSCE::RTreeArchive* RangeDependenciesArchive::mutable_r_tree() {
  set_has_r_tree();
  if (r_tree_ == NULL) r_tree_ = new ::TSCE::RTreeArchive;
  return r_tree_;
}
inline ::TSCE::RTreeArchive* RangeDependenciesArchive::release_r_tree() {
  clear_has_r_tree();
  ::TSCE::RTreeArchive* temp = r_tree_;
  r_tree_ = NULL;
  return temp;
}
inline void RangeDependenciesArchive::set_allocated_r_tree(::TSCE::RTreeArchive* r_tree) {
  delete r_tree_;
  r_tree_ = r_tree;
  if (r_tree) {
    set_has_r_tree();
  } else {
    clear_has_r_tree();
  }
}

// repeated .TSCE.RangeBackDependencyArchive back_dependency = 2;
inline int RangeDependenciesArchive::back_dependency_size() const {
  return back_dependency_.size();
}
inline void RangeDependenciesArchive::clear_back_dependency() {
  back_dependency_.Clear();
}
inline const ::TSCE::RangeBackDependencyArchive& RangeDependenciesArchive::back_dependency(int index) const {
  return back_dependency_.Get(index);
}
inline ::TSCE::RangeBackDependencyArchive* RangeDependenciesArchive::mutable_back_dependency(int index) {
  return back_dependency_.Mutable(index);
}
inline ::TSCE::RangeBackDependencyArchive* RangeDependenciesArchive::add_back_dependency() {
  return back_dependency_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::RangeBackDependencyArchive >&
RangeDependenciesArchive::back_dependency() const {
  return back_dependency_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::RangeBackDependencyArchive >*
RangeDependenciesArchive::mutable_back_dependency() {
  return &back_dependency_;
}

// -------------------------------------------------------------------

// SpanningDependenciesArchive_ReferringColumnToLocalCells

// required uint32 column = 1;
inline bool SpanningDependenciesArchive_ReferringColumnToLocalCells::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 SpanningDependenciesArchive_ReferringColumnToLocalCells::column() const {
  return column_;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// required .TSCE.SpanningDependenciesArchive.RangeContext range_context = 2;
inline bool SpanningDependenciesArchive_ReferringColumnToLocalCells::has_range_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::set_has_range_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::clear_has_range_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::clear_range_context() {
  range_context_ = 0;
  clear_has_range_context();
}
inline ::TSCE::SpanningDependenciesArchive_RangeContext SpanningDependenciesArchive_ReferringColumnToLocalCells::range_context() const {
  return static_cast< ::TSCE::SpanningDependenciesArchive_RangeContext >(range_context_);
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::set_range_context(::TSCE::SpanningDependenciesArchive_RangeContext value) {
  assert(::TSCE::SpanningDependenciesArchive_RangeContext_IsValid(value));
  set_has_range_context();
  range_context_ = value;
}

// repeated .TSCE.CellCoordinateArchive cell_coordinate = 3;
inline int SpanningDependenciesArchive_ReferringColumnToLocalCells::cell_coordinate_size() const {
  return cell_coordinate_.size();
}
inline void SpanningDependenciesArchive_ReferringColumnToLocalCells::clear_cell_coordinate() {
  cell_coordinate_.Clear();
}
inline const ::TSCE::CellCoordinateArchive& SpanningDependenciesArchive_ReferringColumnToLocalCells::cell_coordinate(int index) const {
  return cell_coordinate_.Get(index);
}
inline ::TSCE::CellCoordinateArchive* SpanningDependenciesArchive_ReferringColumnToLocalCells::mutable_cell_coordinate(int index) {
  return cell_coordinate_.Mutable(index);
}
inline ::TSCE::CellCoordinateArchive* SpanningDependenciesArchive_ReferringColumnToLocalCells::add_cell_coordinate() {
  return cell_coordinate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >&
SpanningDependenciesArchive_ReferringColumnToLocalCells::cell_coordinate() const {
  return cell_coordinate_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >*
SpanningDependenciesArchive_ReferringColumnToLocalCells::mutable_cell_coordinate() {
  return &cell_coordinate_;
}

// -------------------------------------------------------------------

// SpanningDependenciesArchive_ReferringColumnToRemoteCells

// required uint32 column = 1;
inline bool SpanningDependenciesArchive_ReferringColumnToRemoteCells::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 SpanningDependenciesArchive_ReferringColumnToRemoteCells::column() const {
  return column_;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// required .TSCE.SpanningDependenciesArchive.RangeContext range_context = 2;
inline bool SpanningDependenciesArchive_ReferringColumnToRemoteCells::has_range_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::set_has_range_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::clear_has_range_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::clear_range_context() {
  range_context_ = 0;
  clear_has_range_context();
}
inline ::TSCE::SpanningDependenciesArchive_RangeContext SpanningDependenciesArchive_ReferringColumnToRemoteCells::range_context() const {
  return static_cast< ::TSCE::SpanningDependenciesArchive_RangeContext >(range_context_);
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::set_range_context(::TSCE::SpanningDependenciesArchive_RangeContext value) {
  assert(::TSCE::SpanningDependenciesArchive_RangeContext_IsValid(value));
  set_has_range_context();
  range_context_ = value;
}

// repeated .TSCE.InternalCellReferenceArchive internal_cell_reference = 3;
inline int SpanningDependenciesArchive_ReferringColumnToRemoteCells::internal_cell_reference_size() const {
  return internal_cell_reference_.size();
}
inline void SpanningDependenciesArchive_ReferringColumnToRemoteCells::clear_internal_cell_reference() {
  internal_cell_reference_.Clear();
}
inline const ::TSCE::InternalCellReferenceArchive& SpanningDependenciesArchive_ReferringColumnToRemoteCells::internal_cell_reference(int index) const {
  return internal_cell_reference_.Get(index);
}
inline ::TSCE::InternalCellReferenceArchive* SpanningDependenciesArchive_ReferringColumnToRemoteCells::mutable_internal_cell_reference(int index) {
  return internal_cell_reference_.Mutable(index);
}
inline ::TSCE::InternalCellReferenceArchive* SpanningDependenciesArchive_ReferringColumnToRemoteCells::add_internal_cell_reference() {
  return internal_cell_reference_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >&
SpanningDependenciesArchive_ReferringColumnToRemoteCells::internal_cell_reference() const {
  return internal_cell_reference_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >*
SpanningDependenciesArchive_ReferringColumnToRemoteCells::mutable_internal_cell_reference() {
  return &internal_cell_reference_;
}

// -------------------------------------------------------------------

// SpanningDependenciesArchive

// repeated uint32 column = 1;
inline int SpanningDependenciesArchive::column_size() const {
  return column_.size();
}
inline void SpanningDependenciesArchive::clear_column() {
  column_.Clear();
}
inline ::google::protobuf::uint32 SpanningDependenciesArchive::column(int index) const {
  return column_.Get(index);
}
inline void SpanningDependenciesArchive::set_column(int index, ::google::protobuf::uint32 value) {
  column_.Set(index, value);
}
inline void SpanningDependenciesArchive::add_column(::google::protobuf::uint32 value) {
  column_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SpanningDependenciesArchive::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SpanningDependenciesArchive::mutable_column() {
  return &column_;
}

// repeated .TSCE.SpanningDependenciesArchive.RangeContext range_context = 2;
inline int SpanningDependenciesArchive::range_context_size() const {
  return range_context_.size();
}
inline void SpanningDependenciesArchive::clear_range_context() {
  range_context_.Clear();
}
inline ::TSCE::SpanningDependenciesArchive_RangeContext SpanningDependenciesArchive::range_context(int index) const {
  return static_cast< ::TSCE::SpanningDependenciesArchive_RangeContext >(range_context_.Get(index));
}
inline void SpanningDependenciesArchive::set_range_context(int index, ::TSCE::SpanningDependenciesArchive_RangeContext value) {
  assert(::TSCE::SpanningDependenciesArchive_RangeContext_IsValid(value));
  range_context_.Set(index, value);
}
inline void SpanningDependenciesArchive::add_range_context(::TSCE::SpanningDependenciesArchive_RangeContext value) {
  assert(::TSCE::SpanningDependenciesArchive_RangeContext_IsValid(value));
  range_context_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
SpanningDependenciesArchive::range_context() const {
  return range_context_;
}
inline ::google::protobuf::RepeatedField<int>*
SpanningDependenciesArchive::mutable_range_context() {
  return &range_context_;
}

// repeated .TSCE.CellReferenceArchive cell = 3;
inline int SpanningDependenciesArchive::cell_size() const {
  return cell_.size();
}
inline void SpanningDependenciesArchive::clear_cell() {
  cell_.Clear();
}
inline const ::TSCE::CellReferenceArchive& SpanningDependenciesArchive::cell(int index) const {
  return cell_.Get(index);
}
inline ::TSCE::CellReferenceArchive* SpanningDependenciesArchive::mutable_cell(int index) {
  return cell_.Mutable(index);
}
inline ::TSCE::CellReferenceArchive* SpanningDependenciesArchive::add_cell() {
  return cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >&
SpanningDependenciesArchive::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >*
SpanningDependenciesArchive::mutable_cell() {
  return &cell_;
}

// optional .TSCE.RangeCoordinateArchive total_range_for_deleted_table = 4;
inline bool SpanningDependenciesArchive::has_total_range_for_deleted_table() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpanningDependenciesArchive::set_has_total_range_for_deleted_table() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpanningDependenciesArchive::clear_has_total_range_for_deleted_table() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpanningDependenciesArchive::clear_total_range_for_deleted_table() {
  if (total_range_for_deleted_table_ != NULL) total_range_for_deleted_table_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_total_range_for_deleted_table();
}
inline const ::TSCE::RangeCoordinateArchive& SpanningDependenciesArchive::total_range_for_deleted_table() const {
  return total_range_for_deleted_table_ != NULL ? *total_range_for_deleted_table_ : *default_instance_->total_range_for_deleted_table_;
}
inline ::TSCE::RangeCoordinateArchive* SpanningDependenciesArchive::mutable_total_range_for_deleted_table() {
  set_has_total_range_for_deleted_table();
  if (total_range_for_deleted_table_ == NULL) total_range_for_deleted_table_ = new ::TSCE::RangeCoordinateArchive;
  return total_range_for_deleted_table_;
}
inline ::TSCE::RangeCoordinateArchive* SpanningDependenciesArchive::release_total_range_for_deleted_table() {
  clear_has_total_range_for_deleted_table();
  ::TSCE::RangeCoordinateArchive* temp = total_range_for_deleted_table_;
  total_range_for_deleted_table_ = NULL;
  return temp;
}
inline void SpanningDependenciesArchive::set_allocated_total_range_for_deleted_table(::TSCE::RangeCoordinateArchive* total_range_for_deleted_table) {
  delete total_range_for_deleted_table_;
  total_range_for_deleted_table_ = total_range_for_deleted_table;
  if (total_range_for_deleted_table) {
    set_has_total_range_for_deleted_table();
  } else {
    clear_has_total_range_for_deleted_table();
  }
}

// optional .TSCE.RangeCoordinateArchive body_range_for_deleted_table = 5;
inline bool SpanningDependenciesArchive::has_body_range_for_deleted_table() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpanningDependenciesArchive::set_has_body_range_for_deleted_table() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpanningDependenciesArchive::clear_has_body_range_for_deleted_table() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpanningDependenciesArchive::clear_body_range_for_deleted_table() {
  if (body_range_for_deleted_table_ != NULL) body_range_for_deleted_table_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_body_range_for_deleted_table();
}
inline const ::TSCE::RangeCoordinateArchive& SpanningDependenciesArchive::body_range_for_deleted_table() const {
  return body_range_for_deleted_table_ != NULL ? *body_range_for_deleted_table_ : *default_instance_->body_range_for_deleted_table_;
}
inline ::TSCE::RangeCoordinateArchive* SpanningDependenciesArchive::mutable_body_range_for_deleted_table() {
  set_has_body_range_for_deleted_table();
  if (body_range_for_deleted_table_ == NULL) body_range_for_deleted_table_ = new ::TSCE::RangeCoordinateArchive;
  return body_range_for_deleted_table_;
}
inline ::TSCE::RangeCoordinateArchive* SpanningDependenciesArchive::release_body_range_for_deleted_table() {
  clear_has_body_range_for_deleted_table();
  ::TSCE::RangeCoordinateArchive* temp = body_range_for_deleted_table_;
  body_range_for_deleted_table_ = NULL;
  return temp;
}
inline void SpanningDependenciesArchive::set_allocated_body_range_for_deleted_table(::TSCE::RangeCoordinateArchive* body_range_for_deleted_table) {
  delete body_range_for_deleted_table_;
  body_range_for_deleted_table_ = body_range_for_deleted_table;
  if (body_range_for_deleted_table) {
    set_has_body_range_for_deleted_table();
  } else {
    clear_has_body_range_for_deleted_table();
  }
}

// repeated .TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells referring_column_to_local_cells = 6;
inline int SpanningDependenciesArchive::referring_column_to_local_cells_size() const {
  return referring_column_to_local_cells_.size();
}
inline void SpanningDependenciesArchive::clear_referring_column_to_local_cells() {
  referring_column_to_local_cells_.Clear();
}
inline const ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells& SpanningDependenciesArchive::referring_column_to_local_cells(int index) const {
  return referring_column_to_local_cells_.Get(index);
}
inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells* SpanningDependenciesArchive::mutable_referring_column_to_local_cells(int index) {
  return referring_column_to_local_cells_.Mutable(index);
}
inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells* SpanningDependenciesArchive::add_referring_column_to_local_cells() {
  return referring_column_to_local_cells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells >&
SpanningDependenciesArchive::referring_column_to_local_cells() const {
  return referring_column_to_local_cells_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToLocalCells >*
SpanningDependenciesArchive::mutable_referring_column_to_local_cells() {
  return &referring_column_to_local_cells_;
}

// repeated .TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells referring_column_to_remote_cells = 7;
inline int SpanningDependenciesArchive::referring_column_to_remote_cells_size() const {
  return referring_column_to_remote_cells_.size();
}
inline void SpanningDependenciesArchive::clear_referring_column_to_remote_cells() {
  referring_column_to_remote_cells_.Clear();
}
inline const ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells& SpanningDependenciesArchive::referring_column_to_remote_cells(int index) const {
  return referring_column_to_remote_cells_.Get(index);
}
inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells* SpanningDependenciesArchive::mutable_referring_column_to_remote_cells(int index) {
  return referring_column_to_remote_cells_.Mutable(index);
}
inline ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells* SpanningDependenciesArchive::add_referring_column_to_remote_cells() {
  return referring_column_to_remote_cells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells >&
SpanningDependenciesArchive::referring_column_to_remote_cells() const {
  return referring_column_to_remote_cells_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::SpanningDependenciesArchive_ReferringColumnToRemoteCells >*
SpanningDependenciesArchive::mutable_referring_column_to_remote_cells() {
  return &referring_column_to_remote_cells_;
}

// -------------------------------------------------------------------

// WholeOwnerDependenciesArchive

// repeated .TSCE.InternalCellReferenceArchive dependent_cell = 1;
inline int WholeOwnerDependenciesArchive::dependent_cell_size() const {
  return dependent_cell_.size();
}
inline void WholeOwnerDependenciesArchive::clear_dependent_cell() {
  dependent_cell_.Clear();
}
inline const ::TSCE::InternalCellReferenceArchive& WholeOwnerDependenciesArchive::dependent_cell(int index) const {
  return dependent_cell_.Get(index);
}
inline ::TSCE::InternalCellReferenceArchive* WholeOwnerDependenciesArchive::mutable_dependent_cell(int index) {
  return dependent_cell_.Mutable(index);
}
inline ::TSCE::InternalCellReferenceArchive* WholeOwnerDependenciesArchive::add_dependent_cell() {
  return dependent_cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >&
WholeOwnerDependenciesArchive::dependent_cell() const {
  return dependent_cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >*
WholeOwnerDependenciesArchive::mutable_dependent_cell() {
  return &dependent_cell_;
}

// -------------------------------------------------------------------

// FormulaOwnerInfoArchive

// required .TSCE.CFUUIDArchive formula_owner_id = 1;
inline bool FormulaOwnerInfoArchive::has_formula_owner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_formula_owner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaOwnerInfoArchive::clear_has_formula_owner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaOwnerInfoArchive::clear_formula_owner_id() {
  if (formula_owner_id_ != NULL) formula_owner_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_formula_owner_id();
}
inline const ::TSCE::CFUUIDArchive& FormulaOwnerInfoArchive::formula_owner_id() const {
  return formula_owner_id_ != NULL ? *formula_owner_id_ : *default_instance_->formula_owner_id_;
}
inline ::TSCE::CFUUIDArchive* FormulaOwnerInfoArchive::mutable_formula_owner_id() {
  set_has_formula_owner_id();
  if (formula_owner_id_ == NULL) formula_owner_id_ = new ::TSCE::CFUUIDArchive;
  return formula_owner_id_;
}
inline ::TSCE::CFUUIDArchive* FormulaOwnerInfoArchive::release_formula_owner_id() {
  clear_has_formula_owner_id();
  ::TSCE::CFUUIDArchive* temp = formula_owner_id_;
  formula_owner_id_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_formula_owner_id(::TSCE::CFUUIDArchive* formula_owner_id) {
  delete formula_owner_id_;
  formula_owner_id_ = formula_owner_id;
  if (formula_owner_id) {
    set_has_formula_owner_id();
  } else {
    clear_has_formula_owner_id();
  }
}

// optional .TSCE.CellDependenciesArchive cell_dependencies = 2;
inline bool FormulaOwnerInfoArchive::has_cell_dependencies() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_cell_dependencies() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaOwnerInfoArchive::clear_has_cell_dependencies() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaOwnerInfoArchive::clear_cell_dependencies() {
  if (cell_dependencies_ != NULL) cell_dependencies_->::TSCE::CellDependenciesArchive::Clear();
  clear_has_cell_dependencies();
}
inline const ::TSCE::CellDependenciesArchive& FormulaOwnerInfoArchive::cell_dependencies() const {
  return cell_dependencies_ != NULL ? *cell_dependencies_ : *default_instance_->cell_dependencies_;
}
inline ::TSCE::CellDependenciesArchive* FormulaOwnerInfoArchive::mutable_cell_dependencies() {
  set_has_cell_dependencies();
  if (cell_dependencies_ == NULL) cell_dependencies_ = new ::TSCE::CellDependenciesArchive;
  return cell_dependencies_;
}
inline ::TSCE::CellDependenciesArchive* FormulaOwnerInfoArchive::release_cell_dependencies() {
  clear_has_cell_dependencies();
  ::TSCE::CellDependenciesArchive* temp = cell_dependencies_;
  cell_dependencies_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_cell_dependencies(::TSCE::CellDependenciesArchive* cell_dependencies) {
  delete cell_dependencies_;
  cell_dependencies_ = cell_dependencies;
  if (cell_dependencies) {
    set_has_cell_dependencies();
  } else {
    clear_has_cell_dependencies();
  }
}

// optional .TSCE.RangeDependenciesArchive range_dependencies = 3;
inline bool FormulaOwnerInfoArchive::has_range_dependencies() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_range_dependencies() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormulaOwnerInfoArchive::clear_has_range_dependencies() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormulaOwnerInfoArchive::clear_range_dependencies() {
  if (range_dependencies_ != NULL) range_dependencies_->::TSCE::RangeDependenciesArchive::Clear();
  clear_has_range_dependencies();
}
inline const ::TSCE::RangeDependenciesArchive& FormulaOwnerInfoArchive::range_dependencies() const {
  return range_dependencies_ != NULL ? *range_dependencies_ : *default_instance_->range_dependencies_;
}
inline ::TSCE::RangeDependenciesArchive* FormulaOwnerInfoArchive::mutable_range_dependencies() {
  set_has_range_dependencies();
  if (range_dependencies_ == NULL) range_dependencies_ = new ::TSCE::RangeDependenciesArchive;
  return range_dependencies_;
}
inline ::TSCE::RangeDependenciesArchive* FormulaOwnerInfoArchive::release_range_dependencies() {
  clear_has_range_dependencies();
  ::TSCE::RangeDependenciesArchive* temp = range_dependencies_;
  range_dependencies_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_range_dependencies(::TSCE::RangeDependenciesArchive* range_dependencies) {
  delete range_dependencies_;
  range_dependencies_ = range_dependencies;
  if (range_dependencies) {
    set_has_range_dependencies();
  } else {
    clear_has_range_dependencies();
  }
}

// optional .TSCE.VolatileDependenciesArchive volatile_dependencies = 4;
inline bool FormulaOwnerInfoArchive::has_volatile_dependencies() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_volatile_dependencies() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormulaOwnerInfoArchive::clear_has_volatile_dependencies() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormulaOwnerInfoArchive::clear_volatile_dependencies() {
  if (volatile_dependencies_ != NULL) volatile_dependencies_->::TSCE::VolatileDependenciesArchive::Clear();
  clear_has_volatile_dependencies();
}
inline const ::TSCE::VolatileDependenciesArchive& FormulaOwnerInfoArchive::volatile_dependencies() const {
  return volatile_dependencies_ != NULL ? *volatile_dependencies_ : *default_instance_->volatile_dependencies_;
}
inline ::TSCE::VolatileDependenciesArchive* FormulaOwnerInfoArchive::mutable_volatile_dependencies() {
  set_has_volatile_dependencies();
  if (volatile_dependencies_ == NULL) volatile_dependencies_ = new ::TSCE::VolatileDependenciesArchive;
  return volatile_dependencies_;
}
inline ::TSCE::VolatileDependenciesArchive* FormulaOwnerInfoArchive::release_volatile_dependencies() {
  clear_has_volatile_dependencies();
  ::TSCE::VolatileDependenciesArchive* temp = volatile_dependencies_;
  volatile_dependencies_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_volatile_dependencies(::TSCE::VolatileDependenciesArchive* volatile_dependencies) {
  delete volatile_dependencies_;
  volatile_dependencies_ = volatile_dependencies;
  if (volatile_dependencies) {
    set_has_volatile_dependencies();
  } else {
    clear_has_volatile_dependencies();
  }
}

// optional .TSCE.SpanningDependenciesArchive spanning_column_dependencies = 5;
inline bool FormulaOwnerInfoArchive::has_spanning_column_dependencies() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_spanning_column_dependencies() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormulaOwnerInfoArchive::clear_has_spanning_column_dependencies() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormulaOwnerInfoArchive::clear_spanning_column_dependencies() {
  if (spanning_column_dependencies_ != NULL) spanning_column_dependencies_->::TSCE::SpanningDependenciesArchive::Clear();
  clear_has_spanning_column_dependencies();
}
inline const ::TSCE::SpanningDependenciesArchive& FormulaOwnerInfoArchive::spanning_column_dependencies() const {
  return spanning_column_dependencies_ != NULL ? *spanning_column_dependencies_ : *default_instance_->spanning_column_dependencies_;
}
inline ::TSCE::SpanningDependenciesArchive* FormulaOwnerInfoArchive::mutable_spanning_column_dependencies() {
  set_has_spanning_column_dependencies();
  if (spanning_column_dependencies_ == NULL) spanning_column_dependencies_ = new ::TSCE::SpanningDependenciesArchive;
  return spanning_column_dependencies_;
}
inline ::TSCE::SpanningDependenciesArchive* FormulaOwnerInfoArchive::release_spanning_column_dependencies() {
  clear_has_spanning_column_dependencies();
  ::TSCE::SpanningDependenciesArchive* temp = spanning_column_dependencies_;
  spanning_column_dependencies_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_spanning_column_dependencies(::TSCE::SpanningDependenciesArchive* spanning_column_dependencies) {
  delete spanning_column_dependencies_;
  spanning_column_dependencies_ = spanning_column_dependencies;
  if (spanning_column_dependencies) {
    set_has_spanning_column_dependencies();
  } else {
    clear_has_spanning_column_dependencies();
  }
}

// optional .TSCE.SpanningDependenciesArchive spanning_row_dependencies = 6;
inline bool FormulaOwnerInfoArchive::has_spanning_row_dependencies() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_spanning_row_dependencies() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormulaOwnerInfoArchive::clear_has_spanning_row_dependencies() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormulaOwnerInfoArchive::clear_spanning_row_dependencies() {
  if (spanning_row_dependencies_ != NULL) spanning_row_dependencies_->::TSCE::SpanningDependenciesArchive::Clear();
  clear_has_spanning_row_dependencies();
}
inline const ::TSCE::SpanningDependenciesArchive& FormulaOwnerInfoArchive::spanning_row_dependencies() const {
  return spanning_row_dependencies_ != NULL ? *spanning_row_dependencies_ : *default_instance_->spanning_row_dependencies_;
}
inline ::TSCE::SpanningDependenciesArchive* FormulaOwnerInfoArchive::mutable_spanning_row_dependencies() {
  set_has_spanning_row_dependencies();
  if (spanning_row_dependencies_ == NULL) spanning_row_dependencies_ = new ::TSCE::SpanningDependenciesArchive;
  return spanning_row_dependencies_;
}
inline ::TSCE::SpanningDependenciesArchive* FormulaOwnerInfoArchive::release_spanning_row_dependencies() {
  clear_has_spanning_row_dependencies();
  ::TSCE::SpanningDependenciesArchive* temp = spanning_row_dependencies_;
  spanning_row_dependencies_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_spanning_row_dependencies(::TSCE::SpanningDependenciesArchive* spanning_row_dependencies) {
  delete spanning_row_dependencies_;
  spanning_row_dependencies_ = spanning_row_dependencies;
  if (spanning_row_dependencies) {
    set_has_spanning_row_dependencies();
  } else {
    clear_has_spanning_row_dependencies();
  }
}

// optional .TSCE.WholeOwnerDependenciesArchive whole_owner_dependencies = 8;
inline bool FormulaOwnerInfoArchive::has_whole_owner_dependencies() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_whole_owner_dependencies() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormulaOwnerInfoArchive::clear_has_whole_owner_dependencies() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormulaOwnerInfoArchive::clear_whole_owner_dependencies() {
  if (whole_owner_dependencies_ != NULL) whole_owner_dependencies_->::TSCE::WholeOwnerDependenciesArchive::Clear();
  clear_has_whole_owner_dependencies();
}
inline const ::TSCE::WholeOwnerDependenciesArchive& FormulaOwnerInfoArchive::whole_owner_dependencies() const {
  return whole_owner_dependencies_ != NULL ? *whole_owner_dependencies_ : *default_instance_->whole_owner_dependencies_;
}
inline ::TSCE::WholeOwnerDependenciesArchive* FormulaOwnerInfoArchive::mutable_whole_owner_dependencies() {
  set_has_whole_owner_dependencies();
  if (whole_owner_dependencies_ == NULL) whole_owner_dependencies_ = new ::TSCE::WholeOwnerDependenciesArchive;
  return whole_owner_dependencies_;
}
inline ::TSCE::WholeOwnerDependenciesArchive* FormulaOwnerInfoArchive::release_whole_owner_dependencies() {
  clear_has_whole_owner_dependencies();
  ::TSCE::WholeOwnerDependenciesArchive* temp = whole_owner_dependencies_;
  whole_owner_dependencies_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_whole_owner_dependencies(::TSCE::WholeOwnerDependenciesArchive* whole_owner_dependencies) {
  delete whole_owner_dependencies_;
  whole_owner_dependencies_ = whole_owner_dependencies;
  if (whole_owner_dependencies) {
    set_has_whole_owner_dependencies();
  } else {
    clear_has_whole_owner_dependencies();
  }
}

// optional .TSP.Reference formula_owner = 7;
inline bool FormulaOwnerInfoArchive::has_formula_owner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FormulaOwnerInfoArchive::set_has_formula_owner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FormulaOwnerInfoArchive::clear_has_formula_owner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FormulaOwnerInfoArchive::clear_formula_owner() {
  if (formula_owner_ != NULL) formula_owner_->::TSP::Reference::Clear();
  clear_has_formula_owner();
}
inline const ::TSP::Reference& FormulaOwnerInfoArchive::formula_owner() const {
  return formula_owner_ != NULL ? *formula_owner_ : *default_instance_->formula_owner_;
}
inline ::TSP::Reference* FormulaOwnerInfoArchive::mutable_formula_owner() {
  set_has_formula_owner();
  if (formula_owner_ == NULL) formula_owner_ = new ::TSP::Reference;
  return formula_owner_;
}
inline ::TSP::Reference* FormulaOwnerInfoArchive::release_formula_owner() {
  clear_has_formula_owner();
  ::TSP::Reference* temp = formula_owner_;
  formula_owner_ = NULL;
  return temp;
}
inline void FormulaOwnerInfoArchive::set_allocated_formula_owner(::TSP::Reference* formula_owner) {
  delete formula_owner_;
  formula_owner_ = formula_owner;
  if (formula_owner) {
    set_has_formula_owner();
  } else {
    clear_has_formula_owner();
  }
}

// -------------------------------------------------------------------

// OwnerIDMapArchive_OwnerIDMapArchiveEntry

// required uint32 internal_owner_id = 1;
inline bool OwnerIDMapArchive_OwnerIDMapArchiveEntry::has_internal_owner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::set_has_internal_owner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::clear_has_internal_owner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::clear_internal_owner_id() {
  internal_owner_id_ = 0u;
  clear_has_internal_owner_id();
}
inline ::google::protobuf::uint32 OwnerIDMapArchive_OwnerIDMapArchiveEntry::internal_owner_id() const {
  return internal_owner_id_;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::set_internal_owner_id(::google::protobuf::uint32 value) {
  set_has_internal_owner_id();
  internal_owner_id_ = value;
}

// required .TSCE.CFUUIDArchive owner_id = 2;
inline bool OwnerIDMapArchive_OwnerIDMapArchiveEntry::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::clear_owner_id() {
  if (owner_id_ != NULL) owner_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_owner_id();
}
inline const ::TSCE::CFUUIDArchive& OwnerIDMapArchive_OwnerIDMapArchiveEntry::owner_id() const {
  return owner_id_ != NULL ? *owner_id_ : *default_instance_->owner_id_;
}
inline ::TSCE::CFUUIDArchive* OwnerIDMapArchive_OwnerIDMapArchiveEntry::mutable_owner_id() {
  set_has_owner_id();
  if (owner_id_ == NULL) owner_id_ = new ::TSCE::CFUUIDArchive;
  return owner_id_;
}
inline ::TSCE::CFUUIDArchive* OwnerIDMapArchive_OwnerIDMapArchiveEntry::release_owner_id() {
  clear_has_owner_id();
  ::TSCE::CFUUIDArchive* temp = owner_id_;
  owner_id_ = NULL;
  return temp;
}
inline void OwnerIDMapArchive_OwnerIDMapArchiveEntry::set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id) {
  delete owner_id_;
  owner_id_ = owner_id;
  if (owner_id) {
    set_has_owner_id();
  } else {
    clear_has_owner_id();
  }
}

// -------------------------------------------------------------------

// OwnerIDMapArchive

// repeated .TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry map_entry = 1;
inline int OwnerIDMapArchive::map_entry_size() const {
  return map_entry_.size();
}
inline void OwnerIDMapArchive::clear_map_entry() {
  map_entry_.Clear();
}
inline const ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry& OwnerIDMapArchive::map_entry(int index) const {
  return map_entry_.Get(index);
}
inline ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry* OwnerIDMapArchive::mutable_map_entry(int index) {
  return map_entry_.Mutable(index);
}
inline ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry* OwnerIDMapArchive::add_map_entry() {
  return map_entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry >&
OwnerIDMapArchive::map_entry() const {
  return map_entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::OwnerIDMapArchive_OwnerIDMapArchiveEntry >*
OwnerIDMapArchive::mutable_map_entry() {
  return &map_entry_;
}

// -------------------------------------------------------------------

// DependencyTrackerArchive

// repeated .TSCE.FormulaOwnerInfoArchive formula_owner_info = 1;
inline int DependencyTrackerArchive::formula_owner_info_size() const {
  return formula_owner_info_.size();
}
inline void DependencyTrackerArchive::clear_formula_owner_info() {
  formula_owner_info_.Clear();
}
inline const ::TSCE::FormulaOwnerInfoArchive& DependencyTrackerArchive::formula_owner_info(int index) const {
  return formula_owner_info_.Get(index);
}
inline ::TSCE::FormulaOwnerInfoArchive* DependencyTrackerArchive::mutable_formula_owner_info(int index) {
  return formula_owner_info_.Mutable(index);
}
inline ::TSCE::FormulaOwnerInfoArchive* DependencyTrackerArchive::add_formula_owner_info() {
  return formula_owner_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::FormulaOwnerInfoArchive >&
DependencyTrackerArchive::formula_owner_info() const {
  return formula_owner_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::FormulaOwnerInfoArchive >*
DependencyTrackerArchive::mutable_formula_owner_info() {
  return &formula_owner_info_;
}

// repeated .TSCE.CellReferenceArchive dirty_leaf = 2 [deprecated = true];
inline int DependencyTrackerArchive::dirty_leaf_size() const {
  return dirty_leaf_.size();
}
inline void DependencyTrackerArchive::clear_dirty_leaf() {
  dirty_leaf_.Clear();
}
inline const ::TSCE::CellReferenceArchive& DependencyTrackerArchive::dirty_leaf(int index) const {
  return dirty_leaf_.Get(index);
}
inline ::TSCE::CellReferenceArchive* DependencyTrackerArchive::mutable_dirty_leaf(int index) {
  return dirty_leaf_.Mutable(index);
}
inline ::TSCE::CellReferenceArchive* DependencyTrackerArchive::add_dirty_leaf() {
  return dirty_leaf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >&
DependencyTrackerArchive::dirty_leaf() const {
  return dirty_leaf_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellReferenceArchive >*
DependencyTrackerArchive::mutable_dirty_leaf() {
  return &dirty_leaf_;
}

// repeated .TSCE.InternalCellReferenceArchive internal_dirty_leaf = 4 [deprecated = true];
inline int DependencyTrackerArchive::internal_dirty_leaf_size() const {
  return internal_dirty_leaf_.size();
}
inline void DependencyTrackerArchive::clear_internal_dirty_leaf() {
  internal_dirty_leaf_.Clear();
}
inline const ::TSCE::InternalCellReferenceArchive& DependencyTrackerArchive::internal_dirty_leaf(int index) const {
  return internal_dirty_leaf_.Get(index);
}
inline ::TSCE::InternalCellReferenceArchive* DependencyTrackerArchive::mutable_internal_dirty_leaf(int index) {
  return internal_dirty_leaf_.Mutable(index);
}
inline ::TSCE::InternalCellReferenceArchive* DependencyTrackerArchive::add_internal_dirty_leaf() {
  return internal_dirty_leaf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >&
DependencyTrackerArchive::internal_dirty_leaf() const {
  return internal_dirty_leaf_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::InternalCellReferenceArchive >*
DependencyTrackerArchive::mutable_internal_dirty_leaf() {
  return &internal_dirty_leaf_;
}

// optional .TSCE.OwnerIDMapArchive owner_id_map = 3;
inline bool DependencyTrackerArchive::has_owner_id_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DependencyTrackerArchive::set_has_owner_id_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DependencyTrackerArchive::clear_has_owner_id_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DependencyTrackerArchive::clear_owner_id_map() {
  if (owner_id_map_ != NULL) owner_id_map_->::TSCE::OwnerIDMapArchive::Clear();
  clear_has_owner_id_map();
}
inline const ::TSCE::OwnerIDMapArchive& DependencyTrackerArchive::owner_id_map() const {
  return owner_id_map_ != NULL ? *owner_id_map_ : *default_instance_->owner_id_map_;
}
inline ::TSCE::OwnerIDMapArchive* DependencyTrackerArchive::mutable_owner_id_map() {
  set_has_owner_id_map();
  if (owner_id_map_ == NULL) owner_id_map_ = new ::TSCE::OwnerIDMapArchive;
  return owner_id_map_;
}
inline ::TSCE::OwnerIDMapArchive* DependencyTrackerArchive::release_owner_id_map() {
  clear_has_owner_id_map();
  ::TSCE::OwnerIDMapArchive* temp = owner_id_map_;
  owner_id_map_ = NULL;
  return temp;
}
inline void DependencyTrackerArchive::set_allocated_owner_id_map(::TSCE::OwnerIDMapArchive* owner_id_map) {
  delete owner_id_map_;
  owner_id_map_ = owner_id_map;
  if (owner_id_map) {
    set_has_owner_id_map();
  } else {
    clear_has_owner_id_map();
  }
}

// -------------------------------------------------------------------

// NameTrackedReferencePair

// required string name = 1;
inline bool NameTrackedReferencePair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameTrackedReferencePair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameTrackedReferencePair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameTrackedReferencePair::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameTrackedReferencePair::name() const {
  return *name_;
}
inline void NameTrackedReferencePair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameTrackedReferencePair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameTrackedReferencePair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrackedReferencePair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameTrackedReferencePair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrackedReferencePair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference tracked_reference = 2;
inline bool NameTrackedReferencePair::has_tracked_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameTrackedReferencePair::set_has_tracked_reference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameTrackedReferencePair::clear_has_tracked_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameTrackedReferencePair::clear_tracked_reference() {
  if (tracked_reference_ != NULL) tracked_reference_->::TSP::Reference::Clear();
  clear_has_tracked_reference();
}
inline const ::TSP::Reference& NameTrackedReferencePair::tracked_reference() const {
  return tracked_reference_ != NULL ? *tracked_reference_ : *default_instance_->tracked_reference_;
}
inline ::TSP::Reference* NameTrackedReferencePair::mutable_tracked_reference() {
  set_has_tracked_reference();
  if (tracked_reference_ == NULL) tracked_reference_ = new ::TSP::Reference;
  return tracked_reference_;
}
inline ::TSP::Reference* NameTrackedReferencePair::release_tracked_reference() {
  clear_has_tracked_reference();
  ::TSP::Reference* temp = tracked_reference_;
  tracked_reference_ = NULL;
  return temp;
}
inline void NameTrackedReferencePair::set_allocated_tracked_reference(::TSP::Reference* tracked_reference) {
  delete tracked_reference_;
  tracked_reference_ = tracked_reference;
  if (tracked_reference) {
    set_has_tracked_reference();
  } else {
    clear_has_tracked_reference();
  }
}

// optional uint32 tracked_reference_id = 3;
inline bool NameTrackedReferencePair::has_tracked_reference_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameTrackedReferencePair::set_has_tracked_reference_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameTrackedReferencePair::clear_has_tracked_reference_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameTrackedReferencePair::clear_tracked_reference_id() {
  tracked_reference_id_ = 0u;
  clear_has_tracked_reference_id();
}
inline ::google::protobuf::uint32 NameTrackedReferencePair::tracked_reference_id() const {
  return tracked_reference_id_;
}
inline void NameTrackedReferencePair::set_tracked_reference_id(::google::protobuf::uint32 value) {
  set_has_tracked_reference_id();
  tracked_reference_id_ = value;
}

// -------------------------------------------------------------------

// NamesByTrackedReferenceArchive

// required .TSCE.CFUUIDArchive table_id = 1;
inline bool NamesByTrackedReferenceArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamesByTrackedReferenceArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NamesByTrackedReferenceArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NamesByTrackedReferenceArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& NamesByTrackedReferenceArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* NamesByTrackedReferenceArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* NamesByTrackedReferenceArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void NamesByTrackedReferenceArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// repeated .TSCE.NameTrackedReferencePair name_tracked_reference_pair = 2;
inline int NamesByTrackedReferenceArchive::name_tracked_reference_pair_size() const {
  return name_tracked_reference_pair_.size();
}
inline void NamesByTrackedReferenceArchive::clear_name_tracked_reference_pair() {
  name_tracked_reference_pair_.Clear();
}
inline const ::TSCE::NameTrackedReferencePair& NamesByTrackedReferenceArchive::name_tracked_reference_pair(int index) const {
  return name_tracked_reference_pair_.Get(index);
}
inline ::TSCE::NameTrackedReferencePair* NamesByTrackedReferenceArchive::mutable_name_tracked_reference_pair(int index) {
  return name_tracked_reference_pair_.Mutable(index);
}
inline ::TSCE::NameTrackedReferencePair* NamesByTrackedReferenceArchive::add_name_tracked_reference_pair() {
  return name_tracked_reference_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::NameTrackedReferencePair >&
NamesByTrackedReferenceArchive::name_tracked_reference_pair() const {
  return name_tracked_reference_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::NameTrackedReferencePair >*
NamesByTrackedReferenceArchive::mutable_name_tracked_reference_pair() {
  return &name_tracked_reference_pair_;
}

// -------------------------------------------------------------------

// NamedReferenceManagerArchive

// required .TSP.Reference reference_tracker = 1;
inline bool NamedReferenceManagerArchive::has_reference_tracker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamedReferenceManagerArchive::set_has_reference_tracker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NamedReferenceManagerArchive::clear_has_reference_tracker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NamedReferenceManagerArchive::clear_reference_tracker() {
  if (reference_tracker_ != NULL) reference_tracker_->::TSP::Reference::Clear();
  clear_has_reference_tracker();
}
inline const ::TSP::Reference& NamedReferenceManagerArchive::reference_tracker() const {
  return reference_tracker_ != NULL ? *reference_tracker_ : *default_instance_->reference_tracker_;
}
inline ::TSP::Reference* NamedReferenceManagerArchive::mutable_reference_tracker() {
  set_has_reference_tracker();
  if (reference_tracker_ == NULL) reference_tracker_ = new ::TSP::Reference;
  return reference_tracker_;
}
inline ::TSP::Reference* NamedReferenceManagerArchive::release_reference_tracker() {
  clear_has_reference_tracker();
  ::TSP::Reference* temp = reference_tracker_;
  reference_tracker_ = NULL;
  return temp;
}
inline void NamedReferenceManagerArchive::set_allocated_reference_tracker(::TSP::Reference* reference_tracker) {
  delete reference_tracker_;
  reference_tracker_ = reference_tracker;
  if (reference_tracker) {
    set_has_reference_tracker();
  } else {
    clear_has_reference_tracker();
  }
}

// repeated .TSCE.NamesByTrackedReferenceArchive names_by_tracked_reference_by_table = 2 [deprecated = true];
inline int NamedReferenceManagerArchive::names_by_tracked_reference_by_table_size() const {
  return names_by_tracked_reference_by_table_.size();
}
inline void NamedReferenceManagerArchive::clear_names_by_tracked_reference_by_table() {
  names_by_tracked_reference_by_table_.Clear();
}
inline const ::TSCE::NamesByTrackedReferenceArchive& NamedReferenceManagerArchive::names_by_tracked_reference_by_table(int index) const {
  return names_by_tracked_reference_by_table_.Get(index);
}
inline ::TSCE::NamesByTrackedReferenceArchive* NamedReferenceManagerArchive::mutable_names_by_tracked_reference_by_table(int index) {
  return names_by_tracked_reference_by_table_.Mutable(index);
}
inline ::TSCE::NamesByTrackedReferenceArchive* NamedReferenceManagerArchive::add_names_by_tracked_reference_by_table() {
  return names_by_tracked_reference_by_table_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::NamesByTrackedReferenceArchive >&
NamedReferenceManagerArchive::names_by_tracked_reference_by_table() const {
  return names_by_tracked_reference_by_table_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::NamesByTrackedReferenceArchive >*
NamedReferenceManagerArchive::mutable_names_by_tracked_reference_by_table() {
  return &names_by_tracked_reference_by_table_;
}

// -------------------------------------------------------------------

// CalculationEngineArchive

// optional bool base_date_1904 = 1;
inline bool CalculationEngineArchive::has_base_date_1904() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalculationEngineArchive::set_has_base_date_1904() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalculationEngineArchive::clear_has_base_date_1904() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalculationEngineArchive::clear_base_date_1904() {
  base_date_1904_ = false;
  clear_has_base_date_1904();
}
inline bool CalculationEngineArchive::base_date_1904() const {
  return base_date_1904_;
}
inline void CalculationEngineArchive::set_base_date_1904(bool value) {
  set_has_base_date_1904();
  base_date_1904_ = value;
}

// required .TSCE.DependencyTrackerArchive dependency_tracker = 2;
inline bool CalculationEngineArchive::has_dependency_tracker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalculationEngineArchive::set_has_dependency_tracker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalculationEngineArchive::clear_has_dependency_tracker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalculationEngineArchive::clear_dependency_tracker() {
  if (dependency_tracker_ != NULL) dependency_tracker_->::TSCE::DependencyTrackerArchive::Clear();
  clear_has_dependency_tracker();
}
inline const ::TSCE::DependencyTrackerArchive& CalculationEngineArchive::dependency_tracker() const {
  return dependency_tracker_ != NULL ? *dependency_tracker_ : *default_instance_->dependency_tracker_;
}
inline ::TSCE::DependencyTrackerArchive* CalculationEngineArchive::mutable_dependency_tracker() {
  set_has_dependency_tracker();
  if (dependency_tracker_ == NULL) dependency_tracker_ = new ::TSCE::DependencyTrackerArchive;
  return dependency_tracker_;
}
inline ::TSCE::DependencyTrackerArchive* CalculationEngineArchive::release_dependency_tracker() {
  clear_has_dependency_tracker();
  ::TSCE::DependencyTrackerArchive* temp = dependency_tracker_;
  dependency_tracker_ = NULL;
  return temp;
}
inline void CalculationEngineArchive::set_allocated_dependency_tracker(::TSCE::DependencyTrackerArchive* dependency_tracker) {
  delete dependency_tracker_;
  dependency_tracker_ = dependency_tracker;
  if (dependency_tracker) {
    set_has_dependency_tracker();
  } else {
    clear_has_dependency_tracker();
  }
}

// optional .TSP.Reference named_reference_manager = 3;
inline bool CalculationEngineArchive::has_named_reference_manager() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CalculationEngineArchive::set_has_named_reference_manager() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CalculationEngineArchive::clear_has_named_reference_manager() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CalculationEngineArchive::clear_named_reference_manager() {
  if (named_reference_manager_ != NULL) named_reference_manager_->::TSP::Reference::Clear();
  clear_has_named_reference_manager();
}
inline const ::TSP::Reference& CalculationEngineArchive::named_reference_manager() const {
  return named_reference_manager_ != NULL ? *named_reference_manager_ : *default_instance_->named_reference_manager_;
}
inline ::TSP::Reference* CalculationEngineArchive::mutable_named_reference_manager() {
  set_has_named_reference_manager();
  if (named_reference_manager_ == NULL) named_reference_manager_ = new ::TSP::Reference;
  return named_reference_manager_;
}
inline ::TSP::Reference* CalculationEngineArchive::release_named_reference_manager() {
  clear_has_named_reference_manager();
  ::TSP::Reference* temp = named_reference_manager_;
  named_reference_manager_ = NULL;
  return temp;
}
inline void CalculationEngineArchive::set_allocated_named_reference_manager(::TSP::Reference* named_reference_manager) {
  delete named_reference_manager_;
  named_reference_manager_ = named_reference_manager;
  if (named_reference_manager) {
    set_has_named_reference_manager();
  } else {
    clear_has_named_reference_manager();
  }
}

// optional .TSCE.CalculationEngineArchive.ExcelImportDateMode excel_import_date_mode = 4 [default = DATE_MODE_1900];
inline bool CalculationEngineArchive::has_excel_import_date_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CalculationEngineArchive::set_has_excel_import_date_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CalculationEngineArchive::clear_has_excel_import_date_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CalculationEngineArchive::clear_excel_import_date_mode() {
  excel_import_date_mode_ = 1;
  clear_has_excel_import_date_mode();
}
inline ::TSCE::CalculationEngineArchive_ExcelImportDateMode CalculationEngineArchive::excel_import_date_mode() const {
  return static_cast< ::TSCE::CalculationEngineArchive_ExcelImportDateMode >(excel_import_date_mode_);
}
inline void CalculationEngineArchive::set_excel_import_date_mode(::TSCE::CalculationEngineArchive_ExcelImportDateMode value) {
  assert(::TSCE::CalculationEngineArchive_ExcelImportDateMode_IsValid(value));
  set_has_excel_import_date_mode();
  excel_import_date_mode_ = value;
}

// optional string saved_locale_identifier = 5;
inline bool CalculationEngineArchive::has_saved_locale_identifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CalculationEngineArchive::set_has_saved_locale_identifier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CalculationEngineArchive::clear_has_saved_locale_identifier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CalculationEngineArchive::clear_saved_locale_identifier() {
  if (saved_locale_identifier_ != &::google::protobuf::internal::kEmptyString) {
    saved_locale_identifier_->clear();
  }
  clear_has_saved_locale_identifier();
}
inline const ::std::string& CalculationEngineArchive::saved_locale_identifier() const {
  return *saved_locale_identifier_;
}
inline void CalculationEngineArchive::set_saved_locale_identifier(const ::std::string& value) {
  set_has_saved_locale_identifier();
  if (saved_locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    saved_locale_identifier_ = new ::std::string;
  }
  saved_locale_identifier_->assign(value);
}
inline void CalculationEngineArchive::set_saved_locale_identifier(const char* value) {
  set_has_saved_locale_identifier();
  if (saved_locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    saved_locale_identifier_ = new ::std::string;
  }
  saved_locale_identifier_->assign(value);
}
inline void CalculationEngineArchive::set_saved_locale_identifier(const char* value, size_t size) {
  set_has_saved_locale_identifier();
  if (saved_locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    saved_locale_identifier_ = new ::std::string;
  }
  saved_locale_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CalculationEngineArchive::mutable_saved_locale_identifier() {
  set_has_saved_locale_identifier();
  if (saved_locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    saved_locale_identifier_ = new ::std::string;
  }
  return saved_locale_identifier_;
}
inline ::std::string* CalculationEngineArchive::release_saved_locale_identifier() {
  clear_has_saved_locale_identifier();
  if (saved_locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = saved_locale_identifier_;
    saved_locale_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CalculationEngineArchive::set_allocated_saved_locale_identifier(::std::string* saved_locale_identifier) {
  if (saved_locale_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete saved_locale_identifier_;
  }
  if (saved_locale_identifier) {
    set_has_saved_locale_identifier();
    saved_locale_identifier_ = saved_locale_identifier;
  } else {
    clear_has_saved_locale_identifier();
    saved_locale_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive

// required uint32 row_handle = 1;
inline bool ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::has_row_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_has_row_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_has_row_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_row_handle() {
  row_handle_ = 0u;
  clear_has_row_handle();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::row_handle() const {
  return row_handle_;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_row_handle(::google::protobuf::uint32 value) {
  set_has_row_handle();
  row_handle_ = value;
}

// required uint32 column_handle = 2;
inline bool ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::has_column_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_has_column_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_has_column_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_column_handle() {
  column_handle_ = 0u;
  clear_has_column_handle();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::column_handle() const {
  return column_handle_;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_column_handle(::google::protobuf::uint32 value) {
  set_has_column_handle();
  column_handle_ = value;
}

// required uint32 row_is_sticky = 3;
inline bool ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::has_row_is_sticky() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_has_row_is_sticky() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_has_row_is_sticky() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_row_is_sticky() {
  row_is_sticky_ = 0u;
  clear_has_row_is_sticky();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::row_is_sticky() const {
  return row_is_sticky_;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_row_is_sticky(::google::protobuf::uint32 value) {
  set_has_row_is_sticky();
  row_is_sticky_ = value;
}

// required uint32 column_is_sticky = 4;
inline bool ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::has_column_is_sticky() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_has_column_is_sticky() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_has_column_is_sticky() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::clear_column_is_sticky() {
  column_is_sticky_ = 0u;
  clear_has_column_is_sticky();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::column_is_sticky() const {
  return column_is_sticky_;
}
inline void ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::set_column_is_sticky(::google::protobuf::uint32 value) {
  set_has_column_is_sticky();
  column_is_sticky_ = value;
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive

// required uint32 row_handle = 1;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_row_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_row_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_row_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_row_handle() {
  row_handle_ = 0u;
  clear_has_row_handle();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::row_handle() const {
  return row_handle_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_row_handle(::google::protobuf::uint32 value) {
  set_has_row_handle();
  row_handle_ = value;
}

// required uint32 column_handle = 2;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_column_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_column_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_column_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_column_handle() {
  column_handle_ = 0u;
  clear_has_column_handle();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::column_handle() const {
  return column_handle_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_column_handle(::google::protobuf::uint32 value) {
  set_has_column_handle();
  column_handle_ = value;
}

// required uint32 row_is_sticky = 3;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_row_is_sticky() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_row_is_sticky() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_row_is_sticky() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_row_is_sticky() {
  row_is_sticky_ = 0u;
  clear_has_row_is_sticky();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::row_is_sticky() const {
  return row_is_sticky_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_row_is_sticky(::google::protobuf::uint32 value) {
  set_has_row_is_sticky();
  row_is_sticky_ = value;
}

// required uint32 column_is_sticky = 4;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_column_is_sticky() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_column_is_sticky() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_column_is_sticky() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_column_is_sticky() {
  column_is_sticky_ = 0u;
  clear_has_column_is_sticky();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::column_is_sticky() const {
  return column_is_sticky_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_column_is_sticky(::google::protobuf::uint32 value) {
  set_has_column_is_sticky();
  column_is_sticky_ = value;
}

// required .TSCE.CFUUIDArchive table_id = 5;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// optional string AST_reference_whitespace_after_sheet_name = 6;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_ast_reference_whitespace_after_sheet_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_ast_reference_whitespace_after_sheet_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_ast_reference_whitespace_after_sheet_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_ast_reference_whitespace_after_sheet_name() {
  if (ast_reference_whitespace_after_sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_->clear();
  }
  clear_has_ast_reference_whitespace_after_sheet_name();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::ast_reference_whitespace_after_sheet_name() const {
  return *ast_reference_whitespace_after_sheet_name_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_after_sheet_name(const ::std::string& value) {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_sheet_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_after_sheet_name(const char* value) {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_sheet_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_after_sheet_name(const char* value, size_t size) {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_sheet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::mutable_ast_reference_whitespace_after_sheet_name() {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  return ast_reference_whitespace_after_sheet_name_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::release_ast_reference_whitespace_after_sheet_name() {
  clear_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_after_sheet_name_;
    ast_reference_whitespace_after_sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_allocated_ast_reference_whitespace_after_sheet_name(::std::string* ast_reference_whitespace_after_sheet_name) {
  if (ast_reference_whitespace_after_sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_after_sheet_name_;
  }
  if (ast_reference_whitespace_after_sheet_name) {
    set_has_ast_reference_whitespace_after_sheet_name();
    ast_reference_whitespace_after_sheet_name_ = ast_reference_whitespace_after_sheet_name;
  } else {
    clear_has_ast_reference_whitespace_after_sheet_name();
    ast_reference_whitespace_after_sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AST_reference_whitespace_before_table_name = 7;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_ast_reference_whitespace_before_table_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_ast_reference_whitespace_before_table_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_ast_reference_whitespace_before_table_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_ast_reference_whitespace_before_table_name() {
  if (ast_reference_whitespace_before_table_name_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_->clear();
  }
  clear_has_ast_reference_whitespace_before_table_name();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::ast_reference_whitespace_before_table_name() const {
  return *ast_reference_whitespace_before_table_name_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_before_table_name(const ::std::string& value) {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_before_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_before_table_name(const char* value) {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_before_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_before_table_name(const char* value, size_t size) {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_before_table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::mutable_ast_reference_whitespace_before_table_name() {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  return ast_reference_whitespace_before_table_name_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::release_ast_reference_whitespace_before_table_name() {
  clear_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_before_table_name_;
    ast_reference_whitespace_before_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_allocated_ast_reference_whitespace_before_table_name(::std::string* ast_reference_whitespace_before_table_name) {
  if (ast_reference_whitespace_before_table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_before_table_name_;
  }
  if (ast_reference_whitespace_before_table_name) {
    set_has_ast_reference_whitespace_before_table_name();
    ast_reference_whitespace_before_table_name_ = ast_reference_whitespace_before_table_name;
  } else {
    clear_has_ast_reference_whitespace_before_table_name();
    ast_reference_whitespace_before_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AST_reference_whitespace_after_table_name = 8;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_ast_reference_whitespace_after_table_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_ast_reference_whitespace_after_table_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_ast_reference_whitespace_after_table_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_ast_reference_whitespace_after_table_name() {
  if (ast_reference_whitespace_after_table_name_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_->clear();
  }
  clear_has_ast_reference_whitespace_after_table_name();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::ast_reference_whitespace_after_table_name() const {
  return *ast_reference_whitespace_after_table_name_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_after_table_name(const ::std::string& value) {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_after_table_name(const char* value) {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_after_table_name(const char* value, size_t size) {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::mutable_ast_reference_whitespace_after_table_name() {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  return ast_reference_whitespace_after_table_name_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::release_ast_reference_whitespace_after_table_name() {
  clear_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_after_table_name_;
    ast_reference_whitespace_after_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_allocated_ast_reference_whitespace_after_table_name(::std::string* ast_reference_whitespace_after_table_name) {
  if (ast_reference_whitespace_after_table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_after_table_name_;
  }
  if (ast_reference_whitespace_after_table_name) {
    set_has_ast_reference_whitespace_after_table_name();
    ast_reference_whitespace_after_table_name_ = ast_reference_whitespace_after_table_name;
  } else {
    clear_has_ast_reference_whitespace_after_table_name();
    ast_reference_whitespace_after_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AST_reference_whitespace_before_cell_address = 9;
inline bool ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::has_ast_reference_whitespace_before_cell_address() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_has_ast_reference_whitespace_before_cell_address() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_has_ast_reference_whitespace_before_cell_address() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::clear_ast_reference_whitespace_before_cell_address() {
  if (ast_reference_whitespace_before_cell_address_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_->clear();
  }
  clear_has_ast_reference_whitespace_before_cell_address();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::ast_reference_whitespace_before_cell_address() const {
  return *ast_reference_whitespace_before_cell_address_;
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_before_cell_address(const ::std::string& value) {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  ast_reference_whitespace_before_cell_address_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_before_cell_address(const char* value) {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  ast_reference_whitespace_before_cell_address_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_ast_reference_whitespace_before_cell_address(const char* value, size_t size) {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  ast_reference_whitespace_before_cell_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::mutable_ast_reference_whitespace_before_cell_address() {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  return ast_reference_whitespace_before_cell_address_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::release_ast_reference_whitespace_before_cell_address() {
  clear_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_before_cell_address_;
    ast_reference_whitespace_before_cell_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::set_allocated_ast_reference_whitespace_before_cell_address(::std::string* ast_reference_whitespace_before_cell_address) {
  if (ast_reference_whitespace_before_cell_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_before_cell_address_;
  }
  if (ast_reference_whitespace_before_cell_address) {
    set_has_ast_reference_whitespace_before_cell_address();
    ast_reference_whitespace_before_cell_address_ = ast_reference_whitespace_before_cell_address;
  } else {
    clear_has_ast_reference_whitespace_before_cell_address();
    ast_reference_whitespace_before_cell_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive_ASTColumnCoordinateArchive

// required sint32 column = 1;
inline bool ASTNodeArrayArchive_ASTColumnCoordinateArchive::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::clear_column() {
  column_ = 0;
  clear_has_column();
}
inline ::google::protobuf::int32 ASTNodeArrayArchive_ASTColumnCoordinateArchive::column() const {
  return column_;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::set_column(::google::protobuf::int32 value) {
  set_has_column();
  column_ = value;
}

// optional bool absolute = 2 [default = false];
inline bool ASTNodeArrayArchive_ASTColumnCoordinateArchive::has_absolute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::set_has_absolute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::clear_has_absolute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::clear_absolute() {
  absolute_ = false;
  clear_has_absolute();
}
inline bool ASTNodeArrayArchive_ASTColumnCoordinateArchive::absolute() const {
  return absolute_;
}
inline void ASTNodeArrayArchive_ASTColumnCoordinateArchive::set_absolute(bool value) {
  set_has_absolute();
  absolute_ = value;
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive_ASTRowCoordinateArchive

// required sint32 row = 1;
inline bool ASTNodeArrayArchive_ASTRowCoordinateArchive::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 ASTNodeArrayArchive_ASTRowCoordinateArchive::row() const {
  return row_;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// optional bool absolute = 2 [default = false];
inline bool ASTNodeArrayArchive_ASTRowCoordinateArchive::has_absolute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::set_has_absolute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::clear_has_absolute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::clear_absolute() {
  absolute_ = false;
  clear_has_absolute();
}
inline bool ASTNodeArrayArchive_ASTRowCoordinateArchive::absolute() const {
  return absolute_;
}
inline void ASTNodeArrayArchive_ASTRowCoordinateArchive::set_absolute(bool value) {
  set_has_absolute();
  absolute_ = value;
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive

// required .TSCE.CFUUIDArchive table_id = 1;
inline bool ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// optional string AST_reference_whitespace_after_sheet_name = 2;
inline bool ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::has_ast_reference_whitespace_after_sheet_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_has_ast_reference_whitespace_after_sheet_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_has_ast_reference_whitespace_after_sheet_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_ast_reference_whitespace_after_sheet_name() {
  if (ast_reference_whitespace_after_sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_->clear();
  }
  clear_has_ast_reference_whitespace_after_sheet_name();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::ast_reference_whitespace_after_sheet_name() const {
  return *ast_reference_whitespace_after_sheet_name_;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_after_sheet_name(const ::std::string& value) {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_sheet_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_after_sheet_name(const char* value) {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_sheet_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_after_sheet_name(const char* value, size_t size) {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_sheet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::mutable_ast_reference_whitespace_after_sheet_name() {
  set_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_sheet_name_ = new ::std::string;
  }
  return ast_reference_whitespace_after_sheet_name_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::release_ast_reference_whitespace_after_sheet_name() {
  clear_has_ast_reference_whitespace_after_sheet_name();
  if (ast_reference_whitespace_after_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_after_sheet_name_;
    ast_reference_whitespace_after_sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_allocated_ast_reference_whitespace_after_sheet_name(::std::string* ast_reference_whitespace_after_sheet_name) {
  if (ast_reference_whitespace_after_sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_after_sheet_name_;
  }
  if (ast_reference_whitespace_after_sheet_name) {
    set_has_ast_reference_whitespace_after_sheet_name();
    ast_reference_whitespace_after_sheet_name_ = ast_reference_whitespace_after_sheet_name;
  } else {
    clear_has_ast_reference_whitespace_after_sheet_name();
    ast_reference_whitespace_after_sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AST_reference_whitespace_before_table_name = 3;
inline bool ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::has_ast_reference_whitespace_before_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_has_ast_reference_whitespace_before_table_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_has_ast_reference_whitespace_before_table_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_ast_reference_whitespace_before_table_name() {
  if (ast_reference_whitespace_before_table_name_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_->clear();
  }
  clear_has_ast_reference_whitespace_before_table_name();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::ast_reference_whitespace_before_table_name() const {
  return *ast_reference_whitespace_before_table_name_;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_before_table_name(const ::std::string& value) {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_before_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_before_table_name(const char* value) {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_before_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_before_table_name(const char* value, size_t size) {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_before_table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::mutable_ast_reference_whitespace_before_table_name() {
  set_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_table_name_ = new ::std::string;
  }
  return ast_reference_whitespace_before_table_name_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::release_ast_reference_whitespace_before_table_name() {
  clear_has_ast_reference_whitespace_before_table_name();
  if (ast_reference_whitespace_before_table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_before_table_name_;
    ast_reference_whitespace_before_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_allocated_ast_reference_whitespace_before_table_name(::std::string* ast_reference_whitespace_before_table_name) {
  if (ast_reference_whitespace_before_table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_before_table_name_;
  }
  if (ast_reference_whitespace_before_table_name) {
    set_has_ast_reference_whitespace_before_table_name();
    ast_reference_whitespace_before_table_name_ = ast_reference_whitespace_before_table_name;
  } else {
    clear_has_ast_reference_whitespace_before_table_name();
    ast_reference_whitespace_before_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AST_reference_whitespace_after_table_name = 4;
inline bool ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::has_ast_reference_whitespace_after_table_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_has_ast_reference_whitespace_after_table_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_has_ast_reference_whitespace_after_table_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_ast_reference_whitespace_after_table_name() {
  if (ast_reference_whitespace_after_table_name_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_->clear();
  }
  clear_has_ast_reference_whitespace_after_table_name();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::ast_reference_whitespace_after_table_name() const {
  return *ast_reference_whitespace_after_table_name_;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_after_table_name(const ::std::string& value) {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_after_table_name(const char* value) {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_table_name_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_after_table_name(const char* value, size_t size) {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  ast_reference_whitespace_after_table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::mutable_ast_reference_whitespace_after_table_name() {
  set_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_after_table_name_ = new ::std::string;
  }
  return ast_reference_whitespace_after_table_name_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::release_ast_reference_whitespace_after_table_name() {
  clear_has_ast_reference_whitespace_after_table_name();
  if (ast_reference_whitespace_after_table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_after_table_name_;
    ast_reference_whitespace_after_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_allocated_ast_reference_whitespace_after_table_name(::std::string* ast_reference_whitespace_after_table_name) {
  if (ast_reference_whitespace_after_table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_after_table_name_;
  }
  if (ast_reference_whitespace_after_table_name) {
    set_has_ast_reference_whitespace_after_table_name();
    ast_reference_whitespace_after_table_name_ = ast_reference_whitespace_after_table_name;
  } else {
    clear_has_ast_reference_whitespace_after_table_name();
    ast_reference_whitespace_after_table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AST_reference_whitespace_before_cell_address = 5;
inline bool ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::has_ast_reference_whitespace_before_cell_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_has_ast_reference_whitespace_before_cell_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_has_ast_reference_whitespace_before_cell_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::clear_ast_reference_whitespace_before_cell_address() {
  if (ast_reference_whitespace_before_cell_address_ != &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_->clear();
  }
  clear_has_ast_reference_whitespace_before_cell_address();
}
inline const ::std::string& ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::ast_reference_whitespace_before_cell_address() const {
  return *ast_reference_whitespace_before_cell_address_;
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_before_cell_address(const ::std::string& value) {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  ast_reference_whitespace_before_cell_address_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_before_cell_address(const char* value) {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  ast_reference_whitespace_before_cell_address_->assign(value);
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_ast_reference_whitespace_before_cell_address(const char* value, size_t size) {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  ast_reference_whitespace_before_cell_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::mutable_ast_reference_whitespace_before_cell_address() {
  set_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    ast_reference_whitespace_before_cell_address_ = new ::std::string;
  }
  return ast_reference_whitespace_before_cell_address_;
}
inline ::std::string* ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::release_ast_reference_whitespace_before_cell_address() {
  clear_has_ast_reference_whitespace_before_cell_address();
  if (ast_reference_whitespace_before_cell_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_reference_whitespace_before_cell_address_;
    ast_reference_whitespace_before_cell_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::set_allocated_ast_reference_whitespace_before_cell_address(::std::string* ast_reference_whitespace_before_cell_address) {
  if (ast_reference_whitespace_before_cell_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_reference_whitespace_before_cell_address_;
  }
  if (ast_reference_whitespace_before_cell_address) {
    set_has_ast_reference_whitespace_before_cell_address();
    ast_reference_whitespace_before_cell_address_ = ast_reference_whitespace_before_cell_address;
  } else {
    clear_has_ast_reference_whitespace_before_cell_address();
    ast_reference_whitespace_before_cell_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive_ASTNodeArchive

// required .TSCE.ASTNodeArrayArchive.ASTNodeType AST_node_type = 1;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_node_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_node_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_node_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_node_type() {
  ast_node_type_ = 1;
  clear_has_ast_node_type();
}
inline ::TSCE::ASTNodeArrayArchive_ASTNodeType ASTNodeArrayArchive_ASTNodeArchive::ast_node_type() const {
  return static_cast< ::TSCE::ASTNodeArrayArchive_ASTNodeType >(ast_node_type_);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_node_type(::TSCE::ASTNodeArrayArchive_ASTNodeType value) {
  assert(::TSCE::ASTNodeArrayArchive_ASTNodeType_IsValid(value));
  set_has_ast_node_type();
  ast_node_type_ = value;
}

// optional uint32 AST_function_node_index = 2;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_function_node_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_function_node_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_function_node_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_function_node_index() {
  ast_function_node_index_ = 0u;
  clear_has_ast_function_node_index();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_function_node_index() const {
  return ast_function_node_index_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_function_node_index(::google::protobuf::uint32 value) {
  set_has_ast_function_node_index();
  ast_function_node_index_ = value;
}

// optional uint32 AST_function_node_numArgs = 3;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_function_node_numargs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_function_node_numargs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_function_node_numargs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_function_node_numargs() {
  ast_function_node_numargs_ = 0u;
  clear_has_ast_function_node_numargs();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_function_node_numargs() const {
  return ast_function_node_numargs_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_function_node_numargs(::google::protobuf::uint32 value) {
  set_has_ast_function_node_numargs();
  ast_function_node_numargs_ = value;
}

// optional double AST_number_node_number = 4;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_number_node_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_number_node_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_number_node_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_number_node_number() {
  ast_number_node_number_ = 0;
  clear_has_ast_number_node_number();
}
inline double ASTNodeArrayArchive_ASTNodeArchive::ast_number_node_number() const {
  return ast_number_node_number_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_number_node_number(double value) {
  set_has_ast_number_node_number();
  ast_number_node_number_ = value;
}

// optional bool AST_boolean_node_boolean = 5;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_boolean_node_boolean() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_boolean_node_boolean() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_boolean_node_boolean() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_boolean_node_boolean() {
  ast_boolean_node_boolean_ = false;
  clear_has_ast_boolean_node_boolean();
}
inline bool ASTNodeArrayArchive_ASTNodeArchive::ast_boolean_node_boolean() const {
  return ast_boolean_node_boolean_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_boolean_node_boolean(bool value) {
  set_has_ast_boolean_node_boolean();
  ast_boolean_node_boolean_ = value;
}

// optional string AST_string_node_string = 6;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_string_node_string() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_string_node_string() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_string_node_string() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_string_node_string() {
  if (ast_string_node_string_ != &::google::protobuf::internal::kEmptyString) {
    ast_string_node_string_->clear();
  }
  clear_has_ast_string_node_string();
}
inline const ::std::string& ASTNodeArrayArchive_ASTNodeArchive::ast_string_node_string() const {
  return *ast_string_node_string_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_string_node_string(const ::std::string& value) {
  set_has_ast_string_node_string();
  if (ast_string_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_string_node_string_ = new ::std::string;
  }
  ast_string_node_string_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_string_node_string(const char* value) {
  set_has_ast_string_node_string();
  if (ast_string_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_string_node_string_ = new ::std::string;
  }
  ast_string_node_string_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_string_node_string(const char* value, size_t size) {
  set_has_ast_string_node_string();
  if (ast_string_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_string_node_string_ = new ::std::string;
  }
  ast_string_node_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_string_node_string() {
  set_has_ast_string_node_string();
  if (ast_string_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_string_node_string_ = new ::std::string;
  }
  return ast_string_node_string_;
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::release_ast_string_node_string() {
  clear_has_ast_string_node_string();
  if (ast_string_node_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_string_node_string_;
    ast_string_node_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_string_node_string(::std::string* ast_string_node_string) {
  if (ast_string_node_string_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_string_node_string_;
  }
  if (ast_string_node_string) {
    set_has_ast_string_node_string();
    ast_string_node_string_ = ast_string_node_string;
  } else {
    clear_has_ast_string_node_string();
    ast_string_node_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double AST_date_node_dateNum = 7;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_date_node_datenum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_date_node_datenum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_date_node_datenum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_date_node_datenum() {
  ast_date_node_datenum_ = 0;
  clear_has_ast_date_node_datenum();
}
inline double ASTNodeArrayArchive_ASTNodeArchive::ast_date_node_datenum() const {
  return ast_date_node_datenum_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_date_node_datenum(double value) {
  set_has_ast_date_node_datenum();
  ast_date_node_datenum_ = value;
}

// optional bool AST_date_node_suppress_date_format = 19;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_date_node_suppress_date_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_date_node_suppress_date_format() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_date_node_suppress_date_format() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_date_node_suppress_date_format() {
  ast_date_node_suppress_date_format_ = false;
  clear_has_ast_date_node_suppress_date_format();
}
inline bool ASTNodeArrayArchive_ASTNodeArchive::ast_date_node_suppress_date_format() const {
  return ast_date_node_suppress_date_format_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_date_node_suppress_date_format(bool value) {
  set_has_ast_date_node_suppress_date_format();
  ast_date_node_suppress_date_format_ = value;
}

// optional bool AST_date_node_suppress_time_format = 20;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_date_node_suppress_time_format() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_date_node_suppress_time_format() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_date_node_suppress_time_format() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_date_node_suppress_time_format() {
  ast_date_node_suppress_time_format_ = false;
  clear_has_ast_date_node_suppress_time_format();
}
inline bool ASTNodeArrayArchive_ASTNodeArchive::ast_date_node_suppress_time_format() const {
  return ast_date_node_suppress_time_format_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_date_node_suppress_time_format(bool value) {
  set_has_ast_date_node_suppress_time_format();
  ast_date_node_suppress_time_format_ = value;
}

// optional string AST_date_node_date_time_format = 21;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_date_node_date_time_format() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_date_node_date_time_format() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_date_node_date_time_format() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_date_node_date_time_format() {
  if (ast_date_node_date_time_format_ != &::google::protobuf::internal::kEmptyString) {
    ast_date_node_date_time_format_->clear();
  }
  clear_has_ast_date_node_date_time_format();
}
inline const ::std::string& ASTNodeArrayArchive_ASTNodeArchive::ast_date_node_date_time_format() const {
  return *ast_date_node_date_time_format_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_date_node_date_time_format(const ::std::string& value) {
  set_has_ast_date_node_date_time_format();
  if (ast_date_node_date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    ast_date_node_date_time_format_ = new ::std::string;
  }
  ast_date_node_date_time_format_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_date_node_date_time_format(const char* value) {
  set_has_ast_date_node_date_time_format();
  if (ast_date_node_date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    ast_date_node_date_time_format_ = new ::std::string;
  }
  ast_date_node_date_time_format_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_date_node_date_time_format(const char* value, size_t size) {
  set_has_ast_date_node_date_time_format();
  if (ast_date_node_date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    ast_date_node_date_time_format_ = new ::std::string;
  }
  ast_date_node_date_time_format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_date_node_date_time_format() {
  set_has_ast_date_node_date_time_format();
  if (ast_date_node_date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    ast_date_node_date_time_format_ = new ::std::string;
  }
  return ast_date_node_date_time_format_;
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::release_ast_date_node_date_time_format() {
  clear_has_ast_date_node_date_time_format();
  if (ast_date_node_date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_date_node_date_time_format_;
    ast_date_node_date_time_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_date_node_date_time_format(::std::string* ast_date_node_date_time_format) {
  if (ast_date_node_date_time_format_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_date_node_date_time_format_;
  }
  if (ast_date_node_date_time_format) {
    set_has_ast_date_node_date_time_format();
    ast_date_node_date_time_format_ = ast_date_node_date_time_format;
  } else {
    clear_has_ast_date_node_date_time_format();
    ast_date_node_date_time_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double AST_duration_node_unitNum = 8;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_duration_node_unitnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_duration_node_unitnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_duration_node_unitnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_duration_node_unitnum() {
  ast_duration_node_unitnum_ = 0;
  clear_has_ast_duration_node_unitnum();
}
inline double ASTNodeArrayArchive_ASTNodeArchive::ast_duration_node_unitnum() const {
  return ast_duration_node_unitnum_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_duration_node_unitnum(double value) {
  set_has_ast_duration_node_unitnum();
  ast_duration_node_unitnum_ = value;
}

// optional int32 AST_duration_node_unit = 9;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_duration_node_unit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_duration_node_unit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_duration_node_unit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_duration_node_unit() {
  ast_duration_node_unit_ = 0;
  clear_has_ast_duration_node_unit();
}
inline ::google::protobuf::int32 ASTNodeArrayArchive_ASTNodeArchive::ast_duration_node_unit() const {
  return ast_duration_node_unit_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_duration_node_unit(::google::protobuf::int32 value) {
  set_has_ast_duration_node_unit();
  ast_duration_node_unit_ = value;
}

// optional uint32 AST_duration_node_style = 22;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_duration_node_style() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_duration_node_style() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_duration_node_style() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_duration_node_style() {
  ast_duration_node_style_ = 0u;
  clear_has_ast_duration_node_style();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_duration_node_style() const {
  return ast_duration_node_style_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_duration_node_style(::google::protobuf::uint32 value) {
  set_has_ast_duration_node_style();
  ast_duration_node_style_ = value;
}

// optional uint32 AST_duration_node_duration_unit_largest = 23;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_duration_node_duration_unit_largest() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_duration_node_duration_unit_largest() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_duration_node_duration_unit_largest() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_duration_node_duration_unit_largest() {
  ast_duration_node_duration_unit_largest_ = 0u;
  clear_has_ast_duration_node_duration_unit_largest();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_duration_node_duration_unit_largest() const {
  return ast_duration_node_duration_unit_largest_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_duration_node_duration_unit_largest(::google::protobuf::uint32 value) {
  set_has_ast_duration_node_duration_unit_largest();
  ast_duration_node_duration_unit_largest_ = value;
}

// optional uint32 AST_duration_node_duration_unit_smallest = 24;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_duration_node_duration_unit_smallest() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_duration_node_duration_unit_smallest() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_duration_node_duration_unit_smallest() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_duration_node_duration_unit_smallest() {
  ast_duration_node_duration_unit_smallest_ = 0u;
  clear_has_ast_duration_node_duration_unit_smallest();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_duration_node_duration_unit_smallest() const {
  return ast_duration_node_duration_unit_smallest_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_duration_node_duration_unit_smallest(::google::protobuf::uint32 value) {
  set_has_ast_duration_node_duration_unit_smallest();
  ast_duration_node_duration_unit_smallest_ = value;
}

// optional bool AST_duration_node_use_automatic_units = 29;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_duration_node_use_automatic_units() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_duration_node_use_automatic_units() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_duration_node_use_automatic_units() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_duration_node_use_automatic_units() {
  ast_duration_node_use_automatic_units_ = false;
  clear_has_ast_duration_node_use_automatic_units();
}
inline bool ASTNodeArrayArchive_ASTNodeArchive::ast_duration_node_use_automatic_units() const {
  return ast_duration_node_use_automatic_units_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_duration_node_use_automatic_units(bool value) {
  set_has_ast_duration_node_use_automatic_units();
  ast_duration_node_use_automatic_units_ = value;
}

// optional bool AST_token_node_boolean = 10;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_token_node_boolean() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_token_node_boolean() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_token_node_boolean() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_token_node_boolean() {
  ast_token_node_boolean_ = false;
  clear_has_ast_token_node_boolean();
}
inline bool ASTNodeArrayArchive_ASTNodeArchive::ast_token_node_boolean() const {
  return ast_token_node_boolean_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_token_node_boolean(bool value) {
  set_has_ast_token_node_boolean();
  ast_token_node_boolean_ = value;
}

// optional uint32 AST_array_node_numCol = 11;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_array_node_numcol() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_array_node_numcol() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_array_node_numcol() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_array_node_numcol() {
  ast_array_node_numcol_ = 0u;
  clear_has_ast_array_node_numcol();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_array_node_numcol() const {
  return ast_array_node_numcol_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_array_node_numcol(::google::protobuf::uint32 value) {
  set_has_ast_array_node_numcol();
  ast_array_node_numcol_ = value;
}

// optional uint32 AST_array_node_numRow = 12;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_array_node_numrow() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_array_node_numrow() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_array_node_numrow() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_array_node_numrow() {
  ast_array_node_numrow_ = 0u;
  clear_has_ast_array_node_numrow();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_array_node_numrow() const {
  return ast_array_node_numrow_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_array_node_numrow(::google::protobuf::uint32 value) {
  set_has_ast_array_node_numrow();
  ast_array_node_numrow_ = value;
}

// optional uint32 AST_list_node_numArgs = 13;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_list_node_numargs() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_list_node_numargs() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_list_node_numargs() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_list_node_numargs() {
  ast_list_node_numargs_ = 0u;
  clear_has_ast_list_node_numargs();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_list_node_numargs() const {
  return ast_list_node_numargs_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_list_node_numargs(::google::protobuf::uint32 value) {
  set_has_ast_list_node_numargs();
  ast_list_node_numargs_ = value;
}

// optional .TSCE.ASTNodeArrayArchive AST_thunk_node_array = 14;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_thunk_node_array() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_thunk_node_array() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_thunk_node_array() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_thunk_node_array() {
  if (ast_thunk_node_array_ != NULL) ast_thunk_node_array_->::TSCE::ASTNodeArrayArchive::Clear();
  clear_has_ast_thunk_node_array();
}
inline const ::TSCE::ASTNodeArrayArchive& ASTNodeArrayArchive_ASTNodeArchive::ast_thunk_node_array() const {
  return ast_thunk_node_array_ != NULL ? *ast_thunk_node_array_ : *default_instance_->ast_thunk_node_array_;
}
inline ::TSCE::ASTNodeArrayArchive* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_thunk_node_array() {
  set_has_ast_thunk_node_array();
  if (ast_thunk_node_array_ == NULL) ast_thunk_node_array_ = new ::TSCE::ASTNodeArrayArchive;
  return ast_thunk_node_array_;
}
inline ::TSCE::ASTNodeArrayArchive* ASTNodeArrayArchive_ASTNodeArchive::release_ast_thunk_node_array() {
  clear_has_ast_thunk_node_array();
  ::TSCE::ASTNodeArrayArchive* temp = ast_thunk_node_array_;
  ast_thunk_node_array_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_thunk_node_array(::TSCE::ASTNodeArrayArchive* ast_thunk_node_array) {
  delete ast_thunk_node_array_;
  ast_thunk_node_array_ = ast_thunk_node_array;
  if (ast_thunk_node_array) {
    set_has_ast_thunk_node_array();
  } else {
    clear_has_ast_thunk_node_array();
  }
}

// optional .TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive AST_local_cell_reference_node_reference = 15;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_local_cell_reference_node_reference() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_local_cell_reference_node_reference() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_local_cell_reference_node_reference() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_local_cell_reference_node_reference() {
  if (ast_local_cell_reference_node_reference_ != NULL) ast_local_cell_reference_node_reference_->::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive::Clear();
  clear_has_ast_local_cell_reference_node_reference();
}
inline const ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive& ASTNodeArrayArchive_ASTNodeArchive::ast_local_cell_reference_node_reference() const {
  return ast_local_cell_reference_node_reference_ != NULL ? *ast_local_cell_reference_node_reference_ : *default_instance_->ast_local_cell_reference_node_reference_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_local_cell_reference_node_reference() {
  set_has_ast_local_cell_reference_node_reference();
  if (ast_local_cell_reference_node_reference_ == NULL) ast_local_cell_reference_node_reference_ = new ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive;
  return ast_local_cell_reference_node_reference_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* ASTNodeArrayArchive_ASTNodeArchive::release_ast_local_cell_reference_node_reference() {
  clear_has_ast_local_cell_reference_node_reference();
  ::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* temp = ast_local_cell_reference_node_reference_;
  ast_local_cell_reference_node_reference_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_local_cell_reference_node_reference(::TSCE::ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive* ast_local_cell_reference_node_reference) {
  delete ast_local_cell_reference_node_reference_;
  ast_local_cell_reference_node_reference_ = ast_local_cell_reference_node_reference;
  if (ast_local_cell_reference_node_reference) {
    set_has_ast_local_cell_reference_node_reference();
  } else {
    clear_has_ast_local_cell_reference_node_reference();
  }
}

// optional .TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive AST_cross_table_cell_reference_node_reference = 16;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_cross_table_cell_reference_node_reference() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_cross_table_cell_reference_node_reference() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_cross_table_cell_reference_node_reference() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_cross_table_cell_reference_node_reference() {
  if (ast_cross_table_cell_reference_node_reference_ != NULL) ast_cross_table_cell_reference_node_reference_->::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive::Clear();
  clear_has_ast_cross_table_cell_reference_node_reference();
}
inline const ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive& ASTNodeArrayArchive_ASTNodeArchive::ast_cross_table_cell_reference_node_reference() const {
  return ast_cross_table_cell_reference_node_reference_ != NULL ? *ast_cross_table_cell_reference_node_reference_ : *default_instance_->ast_cross_table_cell_reference_node_reference_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_cross_table_cell_reference_node_reference() {
  set_has_ast_cross_table_cell_reference_node_reference();
  if (ast_cross_table_cell_reference_node_reference_ == NULL) ast_cross_table_cell_reference_node_reference_ = new ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive;
  return ast_cross_table_cell_reference_node_reference_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* ASTNodeArrayArchive_ASTNodeArchive::release_ast_cross_table_cell_reference_node_reference() {
  clear_has_ast_cross_table_cell_reference_node_reference();
  ::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* temp = ast_cross_table_cell_reference_node_reference_;
  ast_cross_table_cell_reference_node_reference_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_cross_table_cell_reference_node_reference(::TSCE::ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive* ast_cross_table_cell_reference_node_reference) {
  delete ast_cross_table_cell_reference_node_reference_;
  ast_cross_table_cell_reference_node_reference_ = ast_cross_table_cell_reference_node_reference;
  if (ast_cross_table_cell_reference_node_reference) {
    set_has_ast_cross_table_cell_reference_node_reference();
  } else {
    clear_has_ast_cross_table_cell_reference_node_reference();
  }
}

// optional string AST_unknown_function_node_string = 17;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_unknown_function_node_string() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_unknown_function_node_string() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_unknown_function_node_string() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_unknown_function_node_string() {
  if (ast_unknown_function_node_string_ != &::google::protobuf::internal::kEmptyString) {
    ast_unknown_function_node_string_->clear();
  }
  clear_has_ast_unknown_function_node_string();
}
inline const ::std::string& ASTNodeArrayArchive_ASTNodeArchive::ast_unknown_function_node_string() const {
  return *ast_unknown_function_node_string_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_unknown_function_node_string(const ::std::string& value) {
  set_has_ast_unknown_function_node_string();
  if (ast_unknown_function_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_unknown_function_node_string_ = new ::std::string;
  }
  ast_unknown_function_node_string_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_unknown_function_node_string(const char* value) {
  set_has_ast_unknown_function_node_string();
  if (ast_unknown_function_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_unknown_function_node_string_ = new ::std::string;
  }
  ast_unknown_function_node_string_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_unknown_function_node_string(const char* value, size_t size) {
  set_has_ast_unknown_function_node_string();
  if (ast_unknown_function_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_unknown_function_node_string_ = new ::std::string;
  }
  ast_unknown_function_node_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_unknown_function_node_string() {
  set_has_ast_unknown_function_node_string();
  if (ast_unknown_function_node_string_ == &::google::protobuf::internal::kEmptyString) {
    ast_unknown_function_node_string_ = new ::std::string;
  }
  return ast_unknown_function_node_string_;
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::release_ast_unknown_function_node_string() {
  clear_has_ast_unknown_function_node_string();
  if (ast_unknown_function_node_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_unknown_function_node_string_;
    ast_unknown_function_node_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_unknown_function_node_string(::std::string* ast_unknown_function_node_string) {
  if (ast_unknown_function_node_string_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_unknown_function_node_string_;
  }
  if (ast_unknown_function_node_string) {
    set_has_ast_unknown_function_node_string();
    ast_unknown_function_node_string_ = ast_unknown_function_node_string;
  } else {
    clear_has_ast_unknown_function_node_string();
    ast_unknown_function_node_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 AST_unknown_function_node_numArgs = 18;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_unknown_function_node_numargs() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_unknown_function_node_numargs() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_unknown_function_node_numargs() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_unknown_function_node_numargs() {
  ast_unknown_function_node_numargs_ = 0u;
  clear_has_ast_unknown_function_node_numargs();
}
inline ::google::protobuf::uint32 ASTNodeArrayArchive_ASTNodeArchive::ast_unknown_function_node_numargs() const {
  return ast_unknown_function_node_numargs_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_unknown_function_node_numargs(::google::protobuf::uint32 value) {
  set_has_ast_unknown_function_node_numargs();
  ast_unknown_function_node_numargs_ = value;
}

// optional string AST_whitespace = 25;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_whitespace() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_whitespace() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_whitespace() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_whitespace() {
  if (ast_whitespace_ != &::google::protobuf::internal::kEmptyString) {
    ast_whitespace_->clear();
  }
  clear_has_ast_whitespace();
}
inline const ::std::string& ASTNodeArrayArchive_ASTNodeArchive::ast_whitespace() const {
  return *ast_whitespace_;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_whitespace(const ::std::string& value) {
  set_has_ast_whitespace();
  if (ast_whitespace_ == &::google::protobuf::internal::kEmptyString) {
    ast_whitespace_ = new ::std::string;
  }
  ast_whitespace_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_whitespace(const char* value) {
  set_has_ast_whitespace();
  if (ast_whitespace_ == &::google::protobuf::internal::kEmptyString) {
    ast_whitespace_ = new ::std::string;
  }
  ast_whitespace_->assign(value);
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_ast_whitespace(const char* value, size_t size) {
  set_has_ast_whitespace();
  if (ast_whitespace_ == &::google::protobuf::internal::kEmptyString) {
    ast_whitespace_ = new ::std::string;
  }
  ast_whitespace_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_whitespace() {
  set_has_ast_whitespace();
  if (ast_whitespace_ == &::google::protobuf::internal::kEmptyString) {
    ast_whitespace_ = new ::std::string;
  }
  return ast_whitespace_;
}
inline ::std::string* ASTNodeArrayArchive_ASTNodeArchive::release_ast_whitespace() {
  clear_has_ast_whitespace();
  if (ast_whitespace_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ast_whitespace_;
    ast_whitespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_whitespace(::std::string* ast_whitespace) {
  if (ast_whitespace_ != &::google::protobuf::internal::kEmptyString) {
    delete ast_whitespace_;
  }
  if (ast_whitespace) {
    set_has_ast_whitespace();
    ast_whitespace_ = ast_whitespace;
  } else {
    clear_has_ast_whitespace();
    ast_whitespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive AST_column = 26;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_column() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_column() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_column() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_column() {
  if (ast_column_ != NULL) ast_column_->::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive::Clear();
  clear_has_ast_column();
}
inline const ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive& ASTNodeArrayArchive_ASTNodeArchive::ast_column() const {
  return ast_column_ != NULL ? *ast_column_ : *default_instance_->ast_column_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_column() {
  set_has_ast_column();
  if (ast_column_ == NULL) ast_column_ = new ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive;
  return ast_column_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* ASTNodeArrayArchive_ASTNodeArchive::release_ast_column() {
  clear_has_ast_column();
  ::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* temp = ast_column_;
  ast_column_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_column(::TSCE::ASTNodeArrayArchive_ASTColumnCoordinateArchive* ast_column) {
  delete ast_column_;
  ast_column_ = ast_column;
  if (ast_column) {
    set_has_ast_column();
  } else {
    clear_has_ast_column();
  }
}

// optional .TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive AST_row = 27;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_row() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_row() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_row() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_row() {
  if (ast_row_ != NULL) ast_row_->::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive::Clear();
  clear_has_ast_row();
}
inline const ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive& ASTNodeArrayArchive_ASTNodeArchive::ast_row() const {
  return ast_row_ != NULL ? *ast_row_ : *default_instance_->ast_row_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_row() {
  set_has_ast_row();
  if (ast_row_ == NULL) ast_row_ = new ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive;
  return ast_row_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* ASTNodeArrayArchive_ASTNodeArchive::release_ast_row() {
  clear_has_ast_row();
  ::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* temp = ast_row_;
  ast_row_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_row(::TSCE::ASTNodeArrayArchive_ASTRowCoordinateArchive* ast_row) {
  delete ast_row_;
  ast_row_ = ast_row;
  if (ast_row) {
    set_has_ast_row();
  } else {
    clear_has_ast_row();
  }
}

// optional .TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive AST_cross_table_reference_extra_info = 28;
inline bool ASTNodeArrayArchive_ASTNodeArchive::has_ast_cross_table_reference_extra_info() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_has_ast_cross_table_reference_extra_info() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_has_ast_cross_table_reference_extra_info() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::clear_ast_cross_table_reference_extra_info() {
  if (ast_cross_table_reference_extra_info_ != NULL) ast_cross_table_reference_extra_info_->::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive::Clear();
  clear_has_ast_cross_table_reference_extra_info();
}
inline const ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive& ASTNodeArrayArchive_ASTNodeArchive::ast_cross_table_reference_extra_info() const {
  return ast_cross_table_reference_extra_info_ != NULL ? *ast_cross_table_reference_extra_info_ : *default_instance_->ast_cross_table_reference_extra_info_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* ASTNodeArrayArchive_ASTNodeArchive::mutable_ast_cross_table_reference_extra_info() {
  set_has_ast_cross_table_reference_extra_info();
  if (ast_cross_table_reference_extra_info_ == NULL) ast_cross_table_reference_extra_info_ = new ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive;
  return ast_cross_table_reference_extra_info_;
}
inline ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* ASTNodeArrayArchive_ASTNodeArchive::release_ast_cross_table_reference_extra_info() {
  clear_has_ast_cross_table_reference_extra_info();
  ::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* temp = ast_cross_table_reference_extra_info_;
  ast_cross_table_reference_extra_info_ = NULL;
  return temp;
}
inline void ASTNodeArrayArchive_ASTNodeArchive::set_allocated_ast_cross_table_reference_extra_info(::TSCE::ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive* ast_cross_table_reference_extra_info) {
  delete ast_cross_table_reference_extra_info_;
  ast_cross_table_reference_extra_info_ = ast_cross_table_reference_extra_info;
  if (ast_cross_table_reference_extra_info) {
    set_has_ast_cross_table_reference_extra_info();
  } else {
    clear_has_ast_cross_table_reference_extra_info();
  }
}

// -------------------------------------------------------------------

// ASTNodeArrayArchive

// repeated .TSCE.ASTNodeArrayArchive.ASTNodeArchive AST_node = 1;
inline int ASTNodeArrayArchive::ast_node_size() const {
  return ast_node_.size();
}
inline void ASTNodeArrayArchive::clear_ast_node() {
  ast_node_.Clear();
}
inline const ::TSCE::ASTNodeArrayArchive_ASTNodeArchive& ASTNodeArrayArchive::ast_node(int index) const {
  return ast_node_.Get(index);
}
inline ::TSCE::ASTNodeArrayArchive_ASTNodeArchive* ASTNodeArrayArchive::mutable_ast_node(int index) {
  return ast_node_.Mutable(index);
}
inline ::TSCE::ASTNodeArrayArchive_ASTNodeArchive* ASTNodeArrayArchive::add_ast_node() {
  return ast_node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::ASTNodeArrayArchive_ASTNodeArchive >&
ASTNodeArrayArchive::ast_node() const {
  return ast_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::ASTNodeArrayArchive_ASTNodeArchive >*
ASTNodeArrayArchive::mutable_ast_node() {
  return &ast_node_;
}

// -------------------------------------------------------------------

// FormulaTranslationFlagsArchive

// optional bool excel_import_translation = 1 [default = false];
inline bool FormulaTranslationFlagsArchive::has_excel_import_translation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaTranslationFlagsArchive::set_has_excel_import_translation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaTranslationFlagsArchive::clear_has_excel_import_translation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaTranslationFlagsArchive::clear_excel_import_translation() {
  excel_import_translation_ = false;
  clear_has_excel_import_translation();
}
inline bool FormulaTranslationFlagsArchive::excel_import_translation() const {
  return excel_import_translation_;
}
inline void FormulaTranslationFlagsArchive::set_excel_import_translation(bool value) {
  set_has_excel_import_translation();
  excel_import_translation_ = value;
}

// optional bool number_to_date_coercion_removal_translation = 2 [default = false];
inline bool FormulaTranslationFlagsArchive::has_number_to_date_coercion_removal_translation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaTranslationFlagsArchive::set_has_number_to_date_coercion_removal_translation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaTranslationFlagsArchive::clear_has_number_to_date_coercion_removal_translation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaTranslationFlagsArchive::clear_number_to_date_coercion_removal_translation() {
  number_to_date_coercion_removal_translation_ = false;
  clear_has_number_to_date_coercion_removal_translation();
}
inline bool FormulaTranslationFlagsArchive::number_to_date_coercion_removal_translation() const {
  return number_to_date_coercion_removal_translation_;
}
inline void FormulaTranslationFlagsArchive::set_number_to_date_coercion_removal_translation(bool value) {
  set_has_number_to_date_coercion_removal_translation();
  number_to_date_coercion_removal_translation_ = value;
}

// -------------------------------------------------------------------

// FormulaArchive

// required .TSCE.ASTNodeArrayArchive AST_node_array = 1;
inline bool FormulaArchive::has_ast_node_array() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaArchive::set_has_ast_node_array() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaArchive::clear_has_ast_node_array() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaArchive::clear_ast_node_array() {
  if (ast_node_array_ != NULL) ast_node_array_->::TSCE::ASTNodeArrayArchive::Clear();
  clear_has_ast_node_array();
}
inline const ::TSCE::ASTNodeArrayArchive& FormulaArchive::ast_node_array() const {
  return ast_node_array_ != NULL ? *ast_node_array_ : *default_instance_->ast_node_array_;
}
inline ::TSCE::ASTNodeArrayArchive* FormulaArchive::mutable_ast_node_array() {
  set_has_ast_node_array();
  if (ast_node_array_ == NULL) ast_node_array_ = new ::TSCE::ASTNodeArrayArchive;
  return ast_node_array_;
}
inline ::TSCE::ASTNodeArrayArchive* FormulaArchive::release_ast_node_array() {
  clear_has_ast_node_array();
  ::TSCE::ASTNodeArrayArchive* temp = ast_node_array_;
  ast_node_array_ = NULL;
  return temp;
}
inline void FormulaArchive::set_allocated_ast_node_array(::TSCE::ASTNodeArrayArchive* ast_node_array) {
  delete ast_node_array_;
  ast_node_array_ = ast_node_array;
  if (ast_node_array) {
    set_has_ast_node_array();
  } else {
    clear_has_ast_node_array();
  }
}

// optional uint32 host_column = 2;
inline bool FormulaArchive::has_host_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaArchive::set_has_host_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaArchive::clear_has_host_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaArchive::clear_host_column() {
  host_column_ = 0u;
  clear_has_host_column();
}
inline ::google::protobuf::uint32 FormulaArchive::host_column() const {
  return host_column_;
}
inline void FormulaArchive::set_host_column(::google::protobuf::uint32 value) {
  set_has_host_column();
  host_column_ = value;
}

// optional uint32 host_row = 3;
inline bool FormulaArchive::has_host_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormulaArchive::set_has_host_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormulaArchive::clear_has_host_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormulaArchive::clear_host_row() {
  host_row_ = 0u;
  clear_has_host_row();
}
inline ::google::protobuf::uint32 FormulaArchive::host_row() const {
  return host_row_;
}
inline void FormulaArchive::set_host_row(::google::protobuf::uint32 value) {
  set_has_host_row();
  host_row_ = value;
}

// optional bool host_column_is_negative = 4 [default = false];
inline bool FormulaArchive::has_host_column_is_negative() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormulaArchive::set_has_host_column_is_negative() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormulaArchive::clear_has_host_column_is_negative() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormulaArchive::clear_host_column_is_negative() {
  host_column_is_negative_ = false;
  clear_has_host_column_is_negative();
}
inline bool FormulaArchive::host_column_is_negative() const {
  return host_column_is_negative_;
}
inline void FormulaArchive::set_host_column_is_negative(bool value) {
  set_has_host_column_is_negative();
  host_column_is_negative_ = value;
}

// optional bool host_row_is_negative = 5 [default = false];
inline bool FormulaArchive::has_host_row_is_negative() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormulaArchive::set_has_host_row_is_negative() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormulaArchive::clear_has_host_row_is_negative() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormulaArchive::clear_host_row_is_negative() {
  host_row_is_negative_ = false;
  clear_has_host_row_is_negative();
}
inline bool FormulaArchive::host_row_is_negative() const {
  return host_row_is_negative_;
}
inline void FormulaArchive::set_host_row_is_negative(bool value) {
  set_has_host_row_is_negative();
  host_row_is_negative_ = value;
}

// optional .TSCE.FormulaTranslationFlagsArchive translation_flags = 6;
inline bool FormulaArchive::has_translation_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormulaArchive::set_has_translation_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormulaArchive::clear_has_translation_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormulaArchive::clear_translation_flags() {
  if (translation_flags_ != NULL) translation_flags_->::TSCE::FormulaTranslationFlagsArchive::Clear();
  clear_has_translation_flags();
}
inline const ::TSCE::FormulaTranslationFlagsArchive& FormulaArchive::translation_flags() const {
  return translation_flags_ != NULL ? *translation_flags_ : *default_instance_->translation_flags_;
}
inline ::TSCE::FormulaTranslationFlagsArchive* FormulaArchive::mutable_translation_flags() {
  set_has_translation_flags();
  if (translation_flags_ == NULL) translation_flags_ = new ::TSCE::FormulaTranslationFlagsArchive;
  return translation_flags_;
}
inline ::TSCE::FormulaTranslationFlagsArchive* FormulaArchive::release_translation_flags() {
  clear_has_translation_flags();
  ::TSCE::FormulaTranslationFlagsArchive* temp = translation_flags_;
  translation_flags_ = NULL;
  return temp;
}
inline void FormulaArchive::set_allocated_translation_flags(::TSCE::FormulaTranslationFlagsArchive* translation_flags) {
  delete translation_flags_;
  translation_flags_ = translation_flags;
  if (translation_flags) {
    set_has_translation_flags();
  } else {
    clear_has_translation_flags();
  }
}

// -------------------------------------------------------------------

// FormatStructArchive

// required uint32 format_type = 1;
inline bool FormatStructArchive::has_format_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatStructArchive::set_has_format_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatStructArchive::clear_has_format_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatStructArchive::clear_format_type() {
  format_type_ = 0u;
  clear_has_format_type();
}
inline ::google::protobuf::uint32 FormatStructArchive::format_type() const {
  return format_type_;
}
inline void FormatStructArchive::set_format_type(::google::protobuf::uint32 value) {
  set_has_format_type();
  format_type_ = value;
}

// optional uint32 decimal_places = 2;
inline bool FormatStructArchive::has_decimal_places() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormatStructArchive::set_has_decimal_places() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormatStructArchive::clear_has_decimal_places() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormatStructArchive::clear_decimal_places() {
  decimal_places_ = 0u;
  clear_has_decimal_places();
}
inline ::google::protobuf::uint32 FormatStructArchive::decimal_places() const {
  return decimal_places_;
}
inline void FormatStructArchive::set_decimal_places(::google::protobuf::uint32 value) {
  set_has_decimal_places();
  decimal_places_ = value;
}

// optional string currency_code = 3;
inline bool FormatStructArchive::has_currency_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormatStructArchive::set_has_currency_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormatStructArchive::clear_has_currency_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormatStructArchive::clear_currency_code() {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    currency_code_->clear();
  }
  clear_has_currency_code();
}
inline const ::std::string& FormatStructArchive::currency_code() const {
  return *currency_code_;
}
inline void FormatStructArchive::set_currency_code(const ::std::string& value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void FormatStructArchive::set_currency_code(const char* value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void FormatStructArchive::set_currency_code(const char* value, size_t size) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatStructArchive::mutable_currency_code() {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  return currency_code_;
}
inline ::std::string* FormatStructArchive::release_currency_code() {
  clear_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_code_;
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FormatStructArchive::set_allocated_currency_code(::std::string* currency_code) {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_code_;
  }
  if (currency_code) {
    set_has_currency_code();
    currency_code_ = currency_code;
  } else {
    clear_has_currency_code();
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 negative_style = 4;
inline bool FormatStructArchive::has_negative_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormatStructArchive::set_has_negative_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormatStructArchive::clear_has_negative_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormatStructArchive::clear_negative_style() {
  negative_style_ = 0u;
  clear_has_negative_style();
}
inline ::google::protobuf::uint32 FormatStructArchive::negative_style() const {
  return negative_style_;
}
inline void FormatStructArchive::set_negative_style(::google::protobuf::uint32 value) {
  set_has_negative_style();
  negative_style_ = value;
}

// optional bool show_thousands_separator = 5;
inline bool FormatStructArchive::has_show_thousands_separator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormatStructArchive::set_has_show_thousands_separator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormatStructArchive::clear_has_show_thousands_separator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormatStructArchive::clear_show_thousands_separator() {
  show_thousands_separator_ = false;
  clear_has_show_thousands_separator();
}
inline bool FormatStructArchive::show_thousands_separator() const {
  return show_thousands_separator_;
}
inline void FormatStructArchive::set_show_thousands_separator(bool value) {
  set_has_show_thousands_separator();
  show_thousands_separator_ = value;
}

// optional bool use_accounting_style = 6;
inline bool FormatStructArchive::has_use_accounting_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormatStructArchive::set_has_use_accounting_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormatStructArchive::clear_has_use_accounting_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormatStructArchive::clear_use_accounting_style() {
  use_accounting_style_ = false;
  clear_has_use_accounting_style();
}
inline bool FormatStructArchive::use_accounting_style() const {
  return use_accounting_style_;
}
inline void FormatStructArchive::set_use_accounting_style(bool value) {
  set_has_use_accounting_style();
  use_accounting_style_ = value;
}

// optional uint32 duration_style = 7;
inline bool FormatStructArchive::has_duration_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormatStructArchive::set_has_duration_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormatStructArchive::clear_has_duration_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormatStructArchive::clear_duration_style() {
  duration_style_ = 0u;
  clear_has_duration_style();
}
inline ::google::protobuf::uint32 FormatStructArchive::duration_style() const {
  return duration_style_;
}
inline void FormatStructArchive::set_duration_style(::google::protobuf::uint32 value) {
  set_has_duration_style();
  duration_style_ = value;
}

// optional uint32 base = 8;
inline bool FormatStructArchive::has_base() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FormatStructArchive::set_has_base() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FormatStructArchive::clear_has_base() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FormatStructArchive::clear_base() {
  base_ = 0u;
  clear_has_base();
}
inline ::google::protobuf::uint32 FormatStructArchive::base() const {
  return base_;
}
inline void FormatStructArchive::set_base(::google::protobuf::uint32 value) {
  set_has_base();
  base_ = value;
}

// optional uint32 base_places = 9;
inline bool FormatStructArchive::has_base_places() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FormatStructArchive::set_has_base_places() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FormatStructArchive::clear_has_base_places() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FormatStructArchive::clear_base_places() {
  base_places_ = 0u;
  clear_has_base_places();
}
inline ::google::protobuf::uint32 FormatStructArchive::base_places() const {
  return base_places_;
}
inline void FormatStructArchive::set_base_places(::google::protobuf::uint32 value) {
  set_has_base_places();
  base_places_ = value;
}

// optional bool base_use_minus_sign = 10;
inline bool FormatStructArchive::has_base_use_minus_sign() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FormatStructArchive::set_has_base_use_minus_sign() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FormatStructArchive::clear_has_base_use_minus_sign() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FormatStructArchive::clear_base_use_minus_sign() {
  base_use_minus_sign_ = false;
  clear_has_base_use_minus_sign();
}
inline bool FormatStructArchive::base_use_minus_sign() const {
  return base_use_minus_sign_;
}
inline void FormatStructArchive::set_base_use_minus_sign(bool value) {
  set_has_base_use_minus_sign();
  base_use_minus_sign_ = value;
}

// optional uint32 fraction_accuracy = 11;
inline bool FormatStructArchive::has_fraction_accuracy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FormatStructArchive::set_has_fraction_accuracy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FormatStructArchive::clear_has_fraction_accuracy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FormatStructArchive::clear_fraction_accuracy() {
  fraction_accuracy_ = 0u;
  clear_has_fraction_accuracy();
}
inline ::google::protobuf::uint32 FormatStructArchive::fraction_accuracy() const {
  return fraction_accuracy_;
}
inline void FormatStructArchive::set_fraction_accuracy(::google::protobuf::uint32 value) {
  set_has_fraction_accuracy();
  fraction_accuracy_ = value;
}

// optional bool suppress_date_format = 12;
inline bool FormatStructArchive::has_suppress_date_format() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FormatStructArchive::set_has_suppress_date_format() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FormatStructArchive::clear_has_suppress_date_format() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FormatStructArchive::clear_suppress_date_format() {
  suppress_date_format_ = false;
  clear_has_suppress_date_format();
}
inline bool FormatStructArchive::suppress_date_format() const {
  return suppress_date_format_;
}
inline void FormatStructArchive::set_suppress_date_format(bool value) {
  set_has_suppress_date_format();
  suppress_date_format_ = value;
}

// optional bool suppress_time_format = 13;
inline bool FormatStructArchive::has_suppress_time_format() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FormatStructArchive::set_has_suppress_time_format() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FormatStructArchive::clear_has_suppress_time_format() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FormatStructArchive::clear_suppress_time_format() {
  suppress_time_format_ = false;
  clear_has_suppress_time_format();
}
inline bool FormatStructArchive::suppress_time_format() const {
  return suppress_time_format_;
}
inline void FormatStructArchive::set_suppress_time_format(bool value) {
  set_has_suppress_time_format();
  suppress_time_format_ = value;
}

// optional string date_time_format = 14;
inline bool FormatStructArchive::has_date_time_format() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FormatStructArchive::set_has_date_time_format() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FormatStructArchive::clear_has_date_time_format() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FormatStructArchive::clear_date_time_format() {
  if (date_time_format_ != &::google::protobuf::internal::kEmptyString) {
    date_time_format_->clear();
  }
  clear_has_date_time_format();
}
inline const ::std::string& FormatStructArchive::date_time_format() const {
  return *date_time_format_;
}
inline void FormatStructArchive::set_date_time_format(const ::std::string& value) {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  date_time_format_->assign(value);
}
inline void FormatStructArchive::set_date_time_format(const char* value) {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  date_time_format_->assign(value);
}
inline void FormatStructArchive::set_date_time_format(const char* value, size_t size) {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  date_time_format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatStructArchive::mutable_date_time_format() {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  return date_time_format_;
}
inline ::std::string* FormatStructArchive::release_date_time_format() {
  clear_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_format_;
    date_time_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FormatStructArchive::set_allocated_date_time_format(::std::string* date_time_format) {
  if (date_time_format_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_format_;
  }
  if (date_time_format) {
    set_has_date_time_format();
    date_time_format_ = date_time_format;
  } else {
    clear_has_date_time_format();
    date_time_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration_unit_largest = 15;
inline bool FormatStructArchive::has_duration_unit_largest() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FormatStructArchive::set_has_duration_unit_largest() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FormatStructArchive::clear_has_duration_unit_largest() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FormatStructArchive::clear_duration_unit_largest() {
  duration_unit_largest_ = 0u;
  clear_has_duration_unit_largest();
}
inline ::google::protobuf::uint32 FormatStructArchive::duration_unit_largest() const {
  return duration_unit_largest_;
}
inline void FormatStructArchive::set_duration_unit_largest(::google::protobuf::uint32 value) {
  set_has_duration_unit_largest();
  duration_unit_largest_ = value;
}

// optional uint32 duration_unit_smallest = 16;
inline bool FormatStructArchive::has_duration_unit_smallest() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FormatStructArchive::set_has_duration_unit_smallest() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FormatStructArchive::clear_has_duration_unit_smallest() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FormatStructArchive::clear_duration_unit_smallest() {
  duration_unit_smallest_ = 0u;
  clear_has_duration_unit_smallest();
}
inline ::google::protobuf::uint32 FormatStructArchive::duration_unit_smallest() const {
  return duration_unit_smallest_;
}
inline void FormatStructArchive::set_duration_unit_smallest(::google::protobuf::uint32 value) {
  set_has_duration_unit_smallest();
  duration_unit_smallest_ = value;
}

// -------------------------------------------------------------------

// RangeCoordinateArchive

// required uint32 top_left_column = 1;
inline bool RangeCoordinateArchive::has_top_left_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeCoordinateArchive::set_has_top_left_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeCoordinateArchive::clear_has_top_left_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeCoordinateArchive::clear_top_left_column() {
  top_left_column_ = 0u;
  clear_has_top_left_column();
}
inline ::google::protobuf::uint32 RangeCoordinateArchive::top_left_column() const {
  return top_left_column_;
}
inline void RangeCoordinateArchive::set_top_left_column(::google::protobuf::uint32 value) {
  set_has_top_left_column();
  top_left_column_ = value;
}

// required uint32 top_left_row = 2;
inline bool RangeCoordinateArchive::has_top_left_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeCoordinateArchive::set_has_top_left_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeCoordinateArchive::clear_has_top_left_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeCoordinateArchive::clear_top_left_row() {
  top_left_row_ = 0u;
  clear_has_top_left_row();
}
inline ::google::protobuf::uint32 RangeCoordinateArchive::top_left_row() const {
  return top_left_row_;
}
inline void RangeCoordinateArchive::set_top_left_row(::google::protobuf::uint32 value) {
  set_has_top_left_row();
  top_left_row_ = value;
}

// required uint32 bottom_right_column = 3;
inline bool RangeCoordinateArchive::has_bottom_right_column() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeCoordinateArchive::set_has_bottom_right_column() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeCoordinateArchive::clear_has_bottom_right_column() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeCoordinateArchive::clear_bottom_right_column() {
  bottom_right_column_ = 0u;
  clear_has_bottom_right_column();
}
inline ::google::protobuf::uint32 RangeCoordinateArchive::bottom_right_column() const {
  return bottom_right_column_;
}
inline void RangeCoordinateArchive::set_bottom_right_column(::google::protobuf::uint32 value) {
  set_has_bottom_right_column();
  bottom_right_column_ = value;
}

// required uint32 bottom_right_row = 4;
inline bool RangeCoordinateArchive::has_bottom_right_row() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RangeCoordinateArchive::set_has_bottom_right_row() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RangeCoordinateArchive::clear_has_bottom_right_row() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RangeCoordinateArchive::clear_bottom_right_row() {
  bottom_right_row_ = 0u;
  clear_has_bottom_right_row();
}
inline ::google::protobuf::uint32 RangeCoordinateArchive::bottom_right_row() const {
  return bottom_right_row_;
}
inline void RangeCoordinateArchive::set_bottom_right_row(::google::protobuf::uint32 value) {
  set_has_bottom_right_row();
  bottom_right_row_ = value;
}

// -------------------------------------------------------------------

// TectonicShiftArchive

// required uint32 grid_coordinate_offset_x = 1;
inline bool TectonicShiftArchive::has_grid_coordinate_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TectonicShiftArchive::set_has_grid_coordinate_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TectonicShiftArchive::clear_has_grid_coordinate_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TectonicShiftArchive::clear_grid_coordinate_offset_x() {
  grid_coordinate_offset_x_ = 0u;
  clear_has_grid_coordinate_offset_x();
}
inline ::google::protobuf::uint32 TectonicShiftArchive::grid_coordinate_offset_x() const {
  return grid_coordinate_offset_x_;
}
inline void TectonicShiftArchive::set_grid_coordinate_offset_x(::google::protobuf::uint32 value) {
  set_has_grid_coordinate_offset_x();
  grid_coordinate_offset_x_ = value;
}

// required uint32 grid_coordinate_offset_y = 2;
inline bool TectonicShiftArchive::has_grid_coordinate_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TectonicShiftArchive::set_has_grid_coordinate_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TectonicShiftArchive::clear_has_grid_coordinate_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TectonicShiftArchive::clear_grid_coordinate_offset_y() {
  grid_coordinate_offset_y_ = 0u;
  clear_has_grid_coordinate_offset_y();
}
inline ::google::protobuf::uint32 TectonicShiftArchive::grid_coordinate_offset_y() const {
  return grid_coordinate_offset_y_;
}
inline void TectonicShiftArchive::set_grid_coordinate_offset_y(::google::protobuf::uint32 value) {
  set_has_grid_coordinate_offset_y();
  grid_coordinate_offset_y_ = value;
}

// required bool grid_coordinate_offset_x_is_negative = 3;
inline bool TectonicShiftArchive::has_grid_coordinate_offset_x_is_negative() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TectonicShiftArchive::set_has_grid_coordinate_offset_x_is_negative() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TectonicShiftArchive::clear_has_grid_coordinate_offset_x_is_negative() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TectonicShiftArchive::clear_grid_coordinate_offset_x_is_negative() {
  grid_coordinate_offset_x_is_negative_ = false;
  clear_has_grid_coordinate_offset_x_is_negative();
}
inline bool TectonicShiftArchive::grid_coordinate_offset_x_is_negative() const {
  return grid_coordinate_offset_x_is_negative_;
}
inline void TectonicShiftArchive::set_grid_coordinate_offset_x_is_negative(bool value) {
  set_has_grid_coordinate_offset_x_is_negative();
  grid_coordinate_offset_x_is_negative_ = value;
}

// required bool grid_coordinate_offset_y_is_negative = 4;
inline bool TectonicShiftArchive::has_grid_coordinate_offset_y_is_negative() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TectonicShiftArchive::set_has_grid_coordinate_offset_y_is_negative() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TectonicShiftArchive::clear_has_grid_coordinate_offset_y_is_negative() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TectonicShiftArchive::clear_grid_coordinate_offset_y_is_negative() {
  grid_coordinate_offset_y_is_negative_ = false;
  clear_has_grid_coordinate_offset_y_is_negative();
}
inline bool TectonicShiftArchive::grid_coordinate_offset_y_is_negative() const {
  return grid_coordinate_offset_y_is_negative_;
}
inline void TectonicShiftArchive::set_grid_coordinate_offset_y_is_negative(bool value) {
  set_has_grid_coordinate_offset_y_is_negative();
  grid_coordinate_offset_y_is_negative_ = value;
}

// optional .TSCE.RangeCoordinateArchive range_for_shift = 5;
inline bool TectonicShiftArchive::has_range_for_shift() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TectonicShiftArchive::set_has_range_for_shift() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TectonicShiftArchive::clear_has_range_for_shift() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TectonicShiftArchive::clear_range_for_shift() {
  if (range_for_shift_ != NULL) range_for_shift_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_range_for_shift();
}
inline const ::TSCE::RangeCoordinateArchive& TectonicShiftArchive::range_for_shift() const {
  return range_for_shift_ != NULL ? *range_for_shift_ : *default_instance_->range_for_shift_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::mutable_range_for_shift() {
  set_has_range_for_shift();
  if (range_for_shift_ == NULL) range_for_shift_ = new ::TSCE::RangeCoordinateArchive;
  return range_for_shift_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::release_range_for_shift() {
  clear_has_range_for_shift();
  ::TSCE::RangeCoordinateArchive* temp = range_for_shift_;
  range_for_shift_ = NULL;
  return temp;
}
inline void TectonicShiftArchive::set_allocated_range_for_shift(::TSCE::RangeCoordinateArchive* range_for_shift) {
  delete range_for_shift_;
  range_for_shift_ = range_for_shift;
  if (range_for_shift) {
    set_has_range_for_shift();
  } else {
    clear_has_range_for_shift();
  }
}

// optional .TSCE.RangeCoordinateArchive range_for_deletion = 6;
inline bool TectonicShiftArchive::has_range_for_deletion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TectonicShiftArchive::set_has_range_for_deletion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TectonicShiftArchive::clear_has_range_for_deletion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TectonicShiftArchive::clear_range_for_deletion() {
  if (range_for_deletion_ != NULL) range_for_deletion_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_range_for_deletion();
}
inline const ::TSCE::RangeCoordinateArchive& TectonicShiftArchive::range_for_deletion() const {
  return range_for_deletion_ != NULL ? *range_for_deletion_ : *default_instance_->range_for_deletion_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::mutable_range_for_deletion() {
  set_has_range_for_deletion();
  if (range_for_deletion_ == NULL) range_for_deletion_ = new ::TSCE::RangeCoordinateArchive;
  return range_for_deletion_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::release_range_for_deletion() {
  clear_has_range_for_deletion();
  ::TSCE::RangeCoordinateArchive* temp = range_for_deletion_;
  range_for_deletion_ = NULL;
  return temp;
}
inline void TectonicShiftArchive::set_allocated_range_for_deletion(::TSCE::RangeCoordinateArchive* range_for_deletion) {
  delete range_for_deletion_;
  range_for_deletion_ = range_for_deletion;
  if (range_for_deletion) {
    set_has_range_for_deletion();
  } else {
    clear_has_range_for_deletion();
  }
}

// optional .TSCE.RangeCoordinateArchive inserted_range = 7;
inline bool TectonicShiftArchive::has_inserted_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TectonicShiftArchive::set_has_inserted_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TectonicShiftArchive::clear_has_inserted_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TectonicShiftArchive::clear_inserted_range() {
  if (inserted_range_ != NULL) inserted_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_inserted_range();
}
inline const ::TSCE::RangeCoordinateArchive& TectonicShiftArchive::inserted_range() const {
  return inserted_range_ != NULL ? *inserted_range_ : *default_instance_->inserted_range_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::mutable_inserted_range() {
  set_has_inserted_range();
  if (inserted_range_ == NULL) inserted_range_ = new ::TSCE::RangeCoordinateArchive;
  return inserted_range_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::release_inserted_range() {
  clear_has_inserted_range();
  ::TSCE::RangeCoordinateArchive* temp = inserted_range_;
  inserted_range_ = NULL;
  return temp;
}
inline void TectonicShiftArchive::set_allocated_inserted_range(::TSCE::RangeCoordinateArchive* inserted_range) {
  delete inserted_range_;
  inserted_range_ = inserted_range;
  if (inserted_range) {
    set_has_inserted_range();
  } else {
    clear_has_inserted_range();
  }
}

// required bool apply_to_absolute = 8;
inline bool TectonicShiftArchive::has_apply_to_absolute() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TectonicShiftArchive::set_has_apply_to_absolute() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TectonicShiftArchive::clear_has_apply_to_absolute() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TectonicShiftArchive::clear_apply_to_absolute() {
  apply_to_absolute_ = false;
  clear_has_apply_to_absolute();
}
inline bool TectonicShiftArchive::apply_to_absolute() const {
  return apply_to_absolute_;
}
inline void TectonicShiftArchive::set_apply_to_absolute(bool value) {
  set_has_apply_to_absolute();
  apply_to_absolute_ = value;
}

// required bool inserting_after = 9;
inline bool TectonicShiftArchive::has_inserting_after() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TectonicShiftArchive::set_has_inserting_after() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TectonicShiftArchive::clear_has_inserting_after() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TectonicShiftArchive::clear_inserting_after() {
  inserting_after_ = false;
  clear_has_inserting_after();
}
inline bool TectonicShiftArchive::inserting_after() const {
  return inserting_after_;
}
inline void TectonicShiftArchive::set_inserting_after(bool value) {
  set_has_inserting_after();
  inserting_after_ = value;
}

// required bool ignore_sticky_bits = 10;
inline bool TectonicShiftArchive::has_ignore_sticky_bits() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TectonicShiftArchive::set_has_ignore_sticky_bits() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TectonicShiftArchive::clear_has_ignore_sticky_bits() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TectonicShiftArchive::clear_ignore_sticky_bits() {
  ignore_sticky_bits_ = false;
  clear_has_ignore_sticky_bits();
}
inline bool TectonicShiftArchive::ignore_sticky_bits() const {
  return ignore_sticky_bits_;
}
inline void TectonicShiftArchive::set_ignore_sticky_bits(bool value) {
  set_has_ignore_sticky_bits();
  ignore_sticky_bits_ = value;
}

// optional .TSCE.RangeCoordinateArchive table_range = 11;
inline bool TectonicShiftArchive::has_table_range() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TectonicShiftArchive::set_has_table_range() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TectonicShiftArchive::clear_has_table_range() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TectonicShiftArchive::clear_table_range() {
  if (table_range_ != NULL) table_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_table_range();
}
inline const ::TSCE::RangeCoordinateArchive& TectonicShiftArchive::table_range() const {
  return table_range_ != NULL ? *table_range_ : *default_instance_->table_range_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::mutable_table_range() {
  set_has_table_range();
  if (table_range_ == NULL) table_range_ = new ::TSCE::RangeCoordinateArchive;
  return table_range_;
}
inline ::TSCE::RangeCoordinateArchive* TectonicShiftArchive::release_table_range() {
  clear_has_table_range();
  ::TSCE::RangeCoordinateArchive* temp = table_range_;
  table_range_ = NULL;
  return temp;
}
inline void TectonicShiftArchive::set_allocated_table_range(::TSCE::RangeCoordinateArchive* table_range) {
  delete table_range_;
  table_range_ = table_range;
  if (table_range) {
    set_has_table_range();
  } else {
    clear_has_table_range();
  }
}

// optional .TSCE.CFUUIDArchive table_id = 12;
inline bool TectonicShiftArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TectonicShiftArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TectonicShiftArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TectonicShiftArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& TectonicShiftArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* TectonicShiftArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* TectonicShiftArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void TectonicShiftArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// -------------------------------------------------------------------

// RewriteSortMappingArchive

// required .TSCE.CFUUIDArchive table_id = 1;
inline bool RewriteSortMappingArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewriteSortMappingArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewriteSortMappingArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewriteSortMappingArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& RewriteSortMappingArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* RewriteSortMappingArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* RewriteSortMappingArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void RewriteSortMappingArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// required .TSK.ShuffleMappingArchive shuffle_mapping = 2;
inline bool RewriteSortMappingArchive::has_shuffle_mapping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewriteSortMappingArchive::set_has_shuffle_mapping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewriteSortMappingArchive::clear_has_shuffle_mapping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewriteSortMappingArchive::clear_shuffle_mapping() {
  if (shuffle_mapping_ != NULL) shuffle_mapping_->::TSK::ShuffleMappingArchive::Clear();
  clear_has_shuffle_mapping();
}
inline const ::TSK::ShuffleMappingArchive& RewriteSortMappingArchive::shuffle_mapping() const {
  return shuffle_mapping_ != NULL ? *shuffle_mapping_ : *default_instance_->shuffle_mapping_;
}
inline ::TSK::ShuffleMappingArchive* RewriteSortMappingArchive::mutable_shuffle_mapping() {
  set_has_shuffle_mapping();
  if (shuffle_mapping_ == NULL) shuffle_mapping_ = new ::TSK::ShuffleMappingArchive;
  return shuffle_mapping_;
}
inline ::TSK::ShuffleMappingArchive* RewriteSortMappingArchive::release_shuffle_mapping() {
  clear_has_shuffle_mapping();
  ::TSK::ShuffleMappingArchive* temp = shuffle_mapping_;
  shuffle_mapping_ = NULL;
  return temp;
}
inline void RewriteSortMappingArchive::set_allocated_shuffle_mapping(::TSK::ShuffleMappingArchive* shuffle_mapping) {
  delete shuffle_mapping_;
  shuffle_mapping_ = shuffle_mapping;
  if (shuffle_mapping) {
    set_has_shuffle_mapping();
  } else {
    clear_has_shuffle_mapping();
  }
}

// required bool explode_ranges = 3;
inline bool RewriteSortMappingArchive::has_explode_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewriteSortMappingArchive::set_has_explode_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewriteSortMappingArchive::clear_has_explode_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewriteSortMappingArchive::clear_explode_ranges() {
  explode_ranges_ = false;
  clear_has_explode_ranges();
}
inline bool RewriteSortMappingArchive::explode_ranges() const {
  return explode_ranges_;
}
inline void RewriteSortMappingArchive::set_explode_ranges(bool value) {
  set_has_explode_ranges();
  explode_ranges_ = value;
}

// -------------------------------------------------------------------

// RangeMovedInfoArchive

// optional .TSCE.CFUUIDArchive table_id = 1;
inline bool RangeMovedInfoArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeMovedInfoArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeMovedInfoArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeMovedInfoArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& RangeMovedInfoArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* RangeMovedInfoArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* RangeMovedInfoArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void RangeMovedInfoArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// optional .TSCE.RangeCoordinateArchive from_range = 2;
inline bool RangeMovedInfoArchive::has_from_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeMovedInfoArchive::set_has_from_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeMovedInfoArchive::clear_has_from_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeMovedInfoArchive::clear_from_range() {
  if (from_range_ != NULL) from_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_from_range();
}
inline const ::TSCE::RangeCoordinateArchive& RangeMovedInfoArchive::from_range() const {
  return from_range_ != NULL ? *from_range_ : *default_instance_->from_range_;
}
inline ::TSCE::RangeCoordinateArchive* RangeMovedInfoArchive::mutable_from_range() {
  set_has_from_range();
  if (from_range_ == NULL) from_range_ = new ::TSCE::RangeCoordinateArchive;
  return from_range_;
}
inline ::TSCE::RangeCoordinateArchive* RangeMovedInfoArchive::release_from_range() {
  clear_has_from_range();
  ::TSCE::RangeCoordinateArchive* temp = from_range_;
  from_range_ = NULL;
  return temp;
}
inline void RangeMovedInfoArchive::set_allocated_from_range(::TSCE::RangeCoordinateArchive* from_range) {
  delete from_range_;
  from_range_ = from_range;
  if (from_range) {
    set_has_from_range();
  } else {
    clear_has_from_range();
  }
}

// optional .TSCE.RangeCoordinateArchive to_range = 3;
inline bool RangeMovedInfoArchive::has_to_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeMovedInfoArchive::set_has_to_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeMovedInfoArchive::clear_has_to_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeMovedInfoArchive::clear_to_range() {
  if (to_range_ != NULL) to_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_to_range();
}
inline const ::TSCE::RangeCoordinateArchive& RangeMovedInfoArchive::to_range() const {
  return to_range_ != NULL ? *to_range_ : *default_instance_->to_range_;
}
inline ::TSCE::RangeCoordinateArchive* RangeMovedInfoArchive::mutable_to_range() {
  set_has_to_range();
  if (to_range_ == NULL) to_range_ = new ::TSCE::RangeCoordinateArchive;
  return to_range_;
}
inline ::TSCE::RangeCoordinateArchive* RangeMovedInfoArchive::release_to_range() {
  clear_has_to_range();
  ::TSCE::RangeCoordinateArchive* temp = to_range_;
  to_range_ = NULL;
  return temp;
}
inline void RangeMovedInfoArchive::set_allocated_to_range(::TSCE::RangeCoordinateArchive* to_range) {
  delete to_range_;
  to_range_ = to_range;
  if (to_range) {
    set_has_to_range();
  } else {
    clear_has_to_range();
  }
}

// optional .TSCE.RangeReferenceArchive from_range_reference = 4;
inline bool RangeMovedInfoArchive::has_from_range_reference() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RangeMovedInfoArchive::set_has_from_range_reference() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RangeMovedInfoArchive::clear_has_from_range_reference() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RangeMovedInfoArchive::clear_from_range_reference() {
  if (from_range_reference_ != NULL) from_range_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_from_range_reference();
}
inline const ::TSCE::RangeReferenceArchive& RangeMovedInfoArchive::from_range_reference() const {
  return from_range_reference_ != NULL ? *from_range_reference_ : *default_instance_->from_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* RangeMovedInfoArchive::mutable_from_range_reference() {
  set_has_from_range_reference();
  if (from_range_reference_ == NULL) from_range_reference_ = new ::TSCE::RangeReferenceArchive;
  return from_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* RangeMovedInfoArchive::release_from_range_reference() {
  clear_has_from_range_reference();
  ::TSCE::RangeReferenceArchive* temp = from_range_reference_;
  from_range_reference_ = NULL;
  return temp;
}
inline void RangeMovedInfoArchive::set_allocated_from_range_reference(::TSCE::RangeReferenceArchive* from_range_reference) {
  delete from_range_reference_;
  from_range_reference_ = from_range_reference;
  if (from_range_reference) {
    set_has_from_range_reference();
  } else {
    clear_has_from_range_reference();
  }
}

// optional .TSCE.RangeReferenceArchive to_range_reference = 5;
inline bool RangeMovedInfoArchive::has_to_range_reference() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RangeMovedInfoArchive::set_has_to_range_reference() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RangeMovedInfoArchive::clear_has_to_range_reference() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RangeMovedInfoArchive::clear_to_range_reference() {
  if (to_range_reference_ != NULL) to_range_reference_->::TSCE::RangeReferenceArchive::Clear();
  clear_has_to_range_reference();
}
inline const ::TSCE::RangeReferenceArchive& RangeMovedInfoArchive::to_range_reference() const {
  return to_range_reference_ != NULL ? *to_range_reference_ : *default_instance_->to_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* RangeMovedInfoArchive::mutable_to_range_reference() {
  set_has_to_range_reference();
  if (to_range_reference_ == NULL) to_range_reference_ = new ::TSCE::RangeReferenceArchive;
  return to_range_reference_;
}
inline ::TSCE::RangeReferenceArchive* RangeMovedInfoArchive::release_to_range_reference() {
  clear_has_to_range_reference();
  ::TSCE::RangeReferenceArchive* temp = to_range_reference_;
  to_range_reference_ = NULL;
  return temp;
}
inline void RangeMovedInfoArchive::set_allocated_to_range_reference(::TSCE::RangeReferenceArchive* to_range_reference) {
  delete to_range_reference_;
  to_range_reference_ = to_range_reference;
  if (to_range_reference) {
    set_has_to_range_reference();
  } else {
    clear_has_to_range_reference();
  }
}

// -------------------------------------------------------------------

// TableResizedInfoArchive

// required .TSCE.CFUUIDArchive table_id = 1;
inline bool TableResizedInfoArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableResizedInfoArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableResizedInfoArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableResizedInfoArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& TableResizedInfoArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* TableResizedInfoArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* TableResizedInfoArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void TableResizedInfoArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// required .TSCE.RangeCoordinateArchive new_table_size = 2;
inline bool TableResizedInfoArchive::has_new_table_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableResizedInfoArchive::set_has_new_table_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableResizedInfoArchive::clear_has_new_table_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableResizedInfoArchive::clear_new_table_size() {
  if (new_table_size_ != NULL) new_table_size_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_new_table_size();
}
inline const ::TSCE::RangeCoordinateArchive& TableResizedInfoArchive::new_table_size() const {
  return new_table_size_ != NULL ? *new_table_size_ : *default_instance_->new_table_size_;
}
inline ::TSCE::RangeCoordinateArchive* TableResizedInfoArchive::mutable_new_table_size() {
  set_has_new_table_size();
  if (new_table_size_ == NULL) new_table_size_ = new ::TSCE::RangeCoordinateArchive;
  return new_table_size_;
}
inline ::TSCE::RangeCoordinateArchive* TableResizedInfoArchive::release_new_table_size() {
  clear_has_new_table_size();
  ::TSCE::RangeCoordinateArchive* temp = new_table_size_;
  new_table_size_ = NULL;
  return temp;
}
inline void TableResizedInfoArchive::set_allocated_new_table_size(::TSCE::RangeCoordinateArchive* new_table_size) {
  delete new_table_size_;
  new_table_size_ = new_table_size;
  if (new_table_size) {
    set_has_new_table_size();
  } else {
    clear_has_new_table_size();
  }
}

// optional .TSCE.RangeCoordinateArchive old_table_size = 3;
inline bool TableResizedInfoArchive::has_old_table_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableResizedInfoArchive::set_has_old_table_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableResizedInfoArchive::clear_has_old_table_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableResizedInfoArchive::clear_old_table_size() {
  if (old_table_size_ != NULL) old_table_size_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_old_table_size();
}
inline const ::TSCE::RangeCoordinateArchive& TableResizedInfoArchive::old_table_size() const {
  return old_table_size_ != NULL ? *old_table_size_ : *default_instance_->old_table_size_;
}
inline ::TSCE::RangeCoordinateArchive* TableResizedInfoArchive::mutable_old_table_size() {
  set_has_old_table_size();
  if (old_table_size_ == NULL) old_table_size_ = new ::TSCE::RangeCoordinateArchive;
  return old_table_size_;
}
inline ::TSCE::RangeCoordinateArchive* TableResizedInfoArchive::release_old_table_size() {
  clear_has_old_table_size();
  ::TSCE::RangeCoordinateArchive* temp = old_table_size_;
  old_table_size_ = NULL;
  return temp;
}
inline void TableResizedInfoArchive::set_allocated_old_table_size(::TSCE::RangeCoordinateArchive* old_table_size) {
  delete old_table_size_;
  old_table_size_ = old_table_size;
  if (old_table_size) {
    set_has_old_table_size();
  } else {
    clear_has_old_table_size();
  }
}

// -------------------------------------------------------------------

// CellMergeInfoArchive

// required .TSCE.CFUUIDArchive table_id = 1;
inline bool CellMergeInfoArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellMergeInfoArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellMergeInfoArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellMergeInfoArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& CellMergeInfoArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* CellMergeInfoArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* CellMergeInfoArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void CellMergeInfoArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// required .TSCE.RangeCoordinateArchive merged_range = 2;
inline bool CellMergeInfoArchive::has_merged_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellMergeInfoArchive::set_has_merged_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellMergeInfoArchive::clear_has_merged_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellMergeInfoArchive::clear_merged_range() {
  if (merged_range_ != NULL) merged_range_->::TSCE::RangeCoordinateArchive::Clear();
  clear_has_merged_range();
}
inline const ::TSCE::RangeCoordinateArchive& CellMergeInfoArchive::merged_range() const {
  return merged_range_ != NULL ? *merged_range_ : *default_instance_->merged_range_;
}
inline ::TSCE::RangeCoordinateArchive* CellMergeInfoArchive::mutable_merged_range() {
  set_has_merged_range();
  if (merged_range_ == NULL) merged_range_ = new ::TSCE::RangeCoordinateArchive;
  return merged_range_;
}
inline ::TSCE::RangeCoordinateArchive* CellMergeInfoArchive::release_merged_range() {
  clear_has_merged_range();
  ::TSCE::RangeCoordinateArchive* temp = merged_range_;
  merged_range_ = NULL;
  return temp;
}
inline void CellMergeInfoArchive::set_allocated_merged_range(::TSCE::RangeCoordinateArchive* merged_range) {
  delete merged_range_;
  merged_range_ = merged_range;
  if (merged_range) {
    set_has_merged_range();
  } else {
    clear_has_merged_range();
  }
}

// -------------------------------------------------------------------

// FormulaRewriteSpecArchive

// required .TSCE.FormulaRewriteSpecArchive.RewriteType rewrite_type = 1;
inline bool FormulaRewriteSpecArchive::has_rewrite_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_rewrite_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaRewriteSpecArchive::clear_has_rewrite_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaRewriteSpecArchive::clear_rewrite_type() {
  rewrite_type_ = 1;
  clear_has_rewrite_type();
}
inline ::TSCE::FormulaRewriteSpecArchive_RewriteType FormulaRewriteSpecArchive::rewrite_type() const {
  return static_cast< ::TSCE::FormulaRewriteSpecArchive_RewriteType >(rewrite_type_);
}
inline void FormulaRewriteSpecArchive::set_rewrite_type(::TSCE::FormulaRewriteSpecArchive_RewriteType value) {
  assert(::TSCE::FormulaRewriteSpecArchive_RewriteType_IsValid(value));
  set_has_rewrite_type();
  rewrite_type_ = value;
}

// optional .TSCE.TectonicShiftArchive tectonic_shift = 2;
inline bool FormulaRewriteSpecArchive::has_tectonic_shift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_tectonic_shift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaRewriteSpecArchive::clear_has_tectonic_shift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaRewriteSpecArchive::clear_tectonic_shift() {
  if (tectonic_shift_ != NULL) tectonic_shift_->::TSCE::TectonicShiftArchive::Clear();
  clear_has_tectonic_shift();
}
inline const ::TSCE::TectonicShiftArchive& FormulaRewriteSpecArchive::tectonic_shift() const {
  return tectonic_shift_ != NULL ? *tectonic_shift_ : *default_instance_->tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* FormulaRewriteSpecArchive::mutable_tectonic_shift() {
  set_has_tectonic_shift();
  if (tectonic_shift_ == NULL) tectonic_shift_ = new ::TSCE::TectonicShiftArchive;
  return tectonic_shift_;
}
inline ::TSCE::TectonicShiftArchive* FormulaRewriteSpecArchive::release_tectonic_shift() {
  clear_has_tectonic_shift();
  ::TSCE::TectonicShiftArchive* temp = tectonic_shift_;
  tectonic_shift_ = NULL;
  return temp;
}
inline void FormulaRewriteSpecArchive::set_allocated_tectonic_shift(::TSCE::TectonicShiftArchive* tectonic_shift) {
  delete tectonic_shift_;
  tectonic_shift_ = tectonic_shift;
  if (tectonic_shift) {
    set_has_tectonic_shift();
  } else {
    clear_has_tectonic_shift();
  }
}

// optional .TSCE.RewriteSortMappingArchive sort_mapping = 3;
inline bool FormulaRewriteSpecArchive::has_sort_mapping() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_sort_mapping() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormulaRewriteSpecArchive::clear_has_sort_mapping() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormulaRewriteSpecArchive::clear_sort_mapping() {
  if (sort_mapping_ != NULL) sort_mapping_->::TSCE::RewriteSortMappingArchive::Clear();
  clear_has_sort_mapping();
}
inline const ::TSCE::RewriteSortMappingArchive& FormulaRewriteSpecArchive::sort_mapping() const {
  return sort_mapping_ != NULL ? *sort_mapping_ : *default_instance_->sort_mapping_;
}
inline ::TSCE::RewriteSortMappingArchive* FormulaRewriteSpecArchive::mutable_sort_mapping() {
  set_has_sort_mapping();
  if (sort_mapping_ == NULL) sort_mapping_ = new ::TSCE::RewriteSortMappingArchive;
  return sort_mapping_;
}
inline ::TSCE::RewriteSortMappingArchive* FormulaRewriteSpecArchive::release_sort_mapping() {
  clear_has_sort_mapping();
  ::TSCE::RewriteSortMappingArchive* temp = sort_mapping_;
  sort_mapping_ = NULL;
  return temp;
}
inline void FormulaRewriteSpecArchive::set_allocated_sort_mapping(::TSCE::RewriteSortMappingArchive* sort_mapping) {
  delete sort_mapping_;
  sort_mapping_ = sort_mapping;
  if (sort_mapping) {
    set_has_sort_mapping();
  } else {
    clear_has_sort_mapping();
  }
}

// optional .TSCE.RangeMovedInfoArchive range_moved_info = 4;
inline bool FormulaRewriteSpecArchive::has_range_moved_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_range_moved_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormulaRewriteSpecArchive::clear_has_range_moved_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormulaRewriteSpecArchive::clear_range_moved_info() {
  if (range_moved_info_ != NULL) range_moved_info_->::TSCE::RangeMovedInfoArchive::Clear();
  clear_has_range_moved_info();
}
inline const ::TSCE::RangeMovedInfoArchive& FormulaRewriteSpecArchive::range_moved_info() const {
  return range_moved_info_ != NULL ? *range_moved_info_ : *default_instance_->range_moved_info_;
}
inline ::TSCE::RangeMovedInfoArchive* FormulaRewriteSpecArchive::mutable_range_moved_info() {
  set_has_range_moved_info();
  if (range_moved_info_ == NULL) range_moved_info_ = new ::TSCE::RangeMovedInfoArchive;
  return range_moved_info_;
}
inline ::TSCE::RangeMovedInfoArchive* FormulaRewriteSpecArchive::release_range_moved_info() {
  clear_has_range_moved_info();
  ::TSCE::RangeMovedInfoArchive* temp = range_moved_info_;
  range_moved_info_ = NULL;
  return temp;
}
inline void FormulaRewriteSpecArchive::set_allocated_range_moved_info(::TSCE::RangeMovedInfoArchive* range_moved_info) {
  delete range_moved_info_;
  range_moved_info_ = range_moved_info;
  if (range_moved_info) {
    set_has_range_moved_info();
  } else {
    clear_has_range_moved_info();
  }
}

// optional .TSCE.CFUUIDArchive deleted_owner_id = 5;
inline bool FormulaRewriteSpecArchive::has_deleted_owner_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_deleted_owner_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormulaRewriteSpecArchive::clear_has_deleted_owner_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormulaRewriteSpecArchive::clear_deleted_owner_id() {
  if (deleted_owner_id_ != NULL) deleted_owner_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_deleted_owner_id();
}
inline const ::TSCE::CFUUIDArchive& FormulaRewriteSpecArchive::deleted_owner_id() const {
  return deleted_owner_id_ != NULL ? *deleted_owner_id_ : *default_instance_->deleted_owner_id_;
}
inline ::TSCE::CFUUIDArchive* FormulaRewriteSpecArchive::mutable_deleted_owner_id() {
  set_has_deleted_owner_id();
  if (deleted_owner_id_ == NULL) deleted_owner_id_ = new ::TSCE::CFUUIDArchive;
  return deleted_owner_id_;
}
inline ::TSCE::CFUUIDArchive* FormulaRewriteSpecArchive::release_deleted_owner_id() {
  clear_has_deleted_owner_id();
  ::TSCE::CFUUIDArchive* temp = deleted_owner_id_;
  deleted_owner_id_ = NULL;
  return temp;
}
inline void FormulaRewriteSpecArchive::set_allocated_deleted_owner_id(::TSCE::CFUUIDArchive* deleted_owner_id) {
  delete deleted_owner_id_;
  deleted_owner_id_ = deleted_owner_id;
  if (deleted_owner_id) {
    set_has_deleted_owner_id();
  } else {
    clear_has_deleted_owner_id();
  }
}

// optional .TSCE.TableResizedInfoArchive table_resized_info = 6;
inline bool FormulaRewriteSpecArchive::has_table_resized_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_table_resized_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormulaRewriteSpecArchive::clear_has_table_resized_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormulaRewriteSpecArchive::clear_table_resized_info() {
  if (table_resized_info_ != NULL) table_resized_info_->::TSCE::TableResizedInfoArchive::Clear();
  clear_has_table_resized_info();
}
inline const ::TSCE::TableResizedInfoArchive& FormulaRewriteSpecArchive::table_resized_info() const {
  return table_resized_info_ != NULL ? *table_resized_info_ : *default_instance_->table_resized_info_;
}
inline ::TSCE::TableResizedInfoArchive* FormulaRewriteSpecArchive::mutable_table_resized_info() {
  set_has_table_resized_info();
  if (table_resized_info_ == NULL) table_resized_info_ = new ::TSCE::TableResizedInfoArchive;
  return table_resized_info_;
}
inline ::TSCE::TableResizedInfoArchive* FormulaRewriteSpecArchive::release_table_resized_info() {
  clear_has_table_resized_info();
  ::TSCE::TableResizedInfoArchive* temp = table_resized_info_;
  table_resized_info_ = NULL;
  return temp;
}
inline void FormulaRewriteSpecArchive::set_allocated_table_resized_info(::TSCE::TableResizedInfoArchive* table_resized_info) {
  delete table_resized_info_;
  table_resized_info_ = table_resized_info;
  if (table_resized_info) {
    set_has_table_resized_info();
  } else {
    clear_has_table_resized_info();
  }
}

// optional .TSCE.CellMergeInfoArchive cell_merge_info = 7;
inline bool FormulaRewriteSpecArchive::has_cell_merge_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormulaRewriteSpecArchive::set_has_cell_merge_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormulaRewriteSpecArchive::clear_has_cell_merge_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormulaRewriteSpecArchive::clear_cell_merge_info() {
  if (cell_merge_info_ != NULL) cell_merge_info_->::TSCE::CellMergeInfoArchive::Clear();
  clear_has_cell_merge_info();
}
inline const ::TSCE::CellMergeInfoArchive& FormulaRewriteSpecArchive::cell_merge_info() const {
  return cell_merge_info_ != NULL ? *cell_merge_info_ : *default_instance_->cell_merge_info_;
}
inline ::TSCE::CellMergeInfoArchive* FormulaRewriteSpecArchive::mutable_cell_merge_info() {
  set_has_cell_merge_info();
  if (cell_merge_info_ == NULL) cell_merge_info_ = new ::TSCE::CellMergeInfoArchive;
  return cell_merge_info_;
}
inline ::TSCE::CellMergeInfoArchive* FormulaRewriteSpecArchive::release_cell_merge_info() {
  clear_has_cell_merge_info();
  ::TSCE::CellMergeInfoArchive* temp = cell_merge_info_;
  cell_merge_info_ = NULL;
  return temp;
}
inline void FormulaRewriteSpecArchive::set_allocated_cell_merge_info(::TSCE::CellMergeInfoArchive* cell_merge_info) {
  delete cell_merge_info_;
  cell_merge_info_ = cell_merge_info;
  if (cell_merge_info) {
    set_has_cell_merge_info();
  } else {
    clear_has_cell_merge_info();
  }
}

// -------------------------------------------------------------------

// CellCoordinateFormulaPairArchive

// required uint32 column = 1;
inline bool CellCoordinateFormulaPairArchive::has_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellCoordinateFormulaPairArchive::set_has_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellCoordinateFormulaPairArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellCoordinateFormulaPairArchive::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 CellCoordinateFormulaPairArchive::column() const {
  return column_;
}
inline void CellCoordinateFormulaPairArchive::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// required uint32 row = 2;
inline bool CellCoordinateFormulaPairArchive::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellCoordinateFormulaPairArchive::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellCoordinateFormulaPairArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellCoordinateFormulaPairArchive::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 CellCoordinateFormulaPairArchive::row() const {
  return row_;
}
inline void CellCoordinateFormulaPairArchive::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// optional .TSCE.FormulaArchive formula = 3;
inline bool CellCoordinateFormulaPairArchive::has_formula() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellCoordinateFormulaPairArchive::set_has_formula() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellCoordinateFormulaPairArchive::clear_has_formula() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellCoordinateFormulaPairArchive::clear_formula() {
  if (formula_ != NULL) formula_->::TSCE::FormulaArchive::Clear();
  clear_has_formula();
}
inline const ::TSCE::FormulaArchive& CellCoordinateFormulaPairArchive::formula() const {
  return formula_ != NULL ? *formula_ : *default_instance_->formula_;
}
inline ::TSCE::FormulaArchive* CellCoordinateFormulaPairArchive::mutable_formula() {
  set_has_formula();
  if (formula_ == NULL) formula_ = new ::TSCE::FormulaArchive;
  return formula_;
}
inline ::TSCE::FormulaArchive* CellCoordinateFormulaPairArchive::release_formula() {
  clear_has_formula();
  ::TSCE::FormulaArchive* temp = formula_;
  formula_ = NULL;
  return temp;
}
inline void CellCoordinateFormulaPairArchive::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  delete formula_;
  formula_ = formula;
  if (formula) {
    set_has_formula();
  } else {
    clear_has_formula();
  }
}

// -------------------------------------------------------------------

// CellCoordinateArchive

// optional fixed32 packedData = 1;
inline bool CellCoordinateArchive::has_packeddata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellCoordinateArchive::set_has_packeddata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellCoordinateArchive::clear_has_packeddata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellCoordinateArchive::clear_packeddata() {
  packeddata_ = 0u;
  clear_has_packeddata();
}
inline ::google::protobuf::uint32 CellCoordinateArchive::packeddata() const {
  return packeddata_;
}
inline void CellCoordinateArchive::set_packeddata(::google::protobuf::uint32 value) {
  set_has_packeddata();
  packeddata_ = value;
}

// optional uint32 column = 2;
inline bool CellCoordinateArchive::has_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellCoordinateArchive::set_has_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellCoordinateArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellCoordinateArchive::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 CellCoordinateArchive::column() const {
  return column_;
}
inline void CellCoordinateArchive::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// optional uint32 row = 3;
inline bool CellCoordinateArchive::has_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellCoordinateArchive::set_has_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellCoordinateArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellCoordinateArchive::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 CellCoordinateArchive::row() const {
  return row_;
}
inline void CellCoordinateArchive::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// -------------------------------------------------------------------

// CellCoordinateVectorArchive

// repeated .TSCE.CellCoordinateArchive cell_coordinate = 1;
inline int CellCoordinateVectorArchive::cell_coordinate_size() const {
  return cell_coordinate_.size();
}
inline void CellCoordinateVectorArchive::clear_cell_coordinate() {
  cell_coordinate_.Clear();
}
inline const ::TSCE::CellCoordinateArchive& CellCoordinateVectorArchive::cell_coordinate(int index) const {
  return cell_coordinate_.Get(index);
}
inline ::TSCE::CellCoordinateArchive* CellCoordinateVectorArchive::mutable_cell_coordinate(int index) {
  return cell_coordinate_.Mutable(index);
}
inline ::TSCE::CellCoordinateArchive* CellCoordinateVectorArchive::add_cell_coordinate() {
  return cell_coordinate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >&
CellCoordinateVectorArchive::cell_coordinate() const {
  return cell_coordinate_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateArchive >*
CellCoordinateVectorArchive::mutable_cell_coordinate() {
  return &cell_coordinate_;
}

// -------------------------------------------------------------------

// CellCoordinateObjectPairArchive

// required .TSCE.CellCoordinateArchive cell_coordinate = 1;
inline bool CellCoordinateObjectPairArchive::has_cell_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellCoordinateObjectPairArchive::set_has_cell_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellCoordinateObjectPairArchive::clear_has_cell_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellCoordinateObjectPairArchive::clear_cell_coordinate() {
  if (cell_coordinate_ != NULL) cell_coordinate_->::TSCE::CellCoordinateArchive::Clear();
  clear_has_cell_coordinate();
}
inline const ::TSCE::CellCoordinateArchive& CellCoordinateObjectPairArchive::cell_coordinate() const {
  return cell_coordinate_ != NULL ? *cell_coordinate_ : *default_instance_->cell_coordinate_;
}
inline ::TSCE::CellCoordinateArchive* CellCoordinateObjectPairArchive::mutable_cell_coordinate() {
  set_has_cell_coordinate();
  if (cell_coordinate_ == NULL) cell_coordinate_ = new ::TSCE::CellCoordinateArchive;
  return cell_coordinate_;
}
inline ::TSCE::CellCoordinateArchive* CellCoordinateObjectPairArchive::release_cell_coordinate() {
  clear_has_cell_coordinate();
  ::TSCE::CellCoordinateArchive* temp = cell_coordinate_;
  cell_coordinate_ = NULL;
  return temp;
}
inline void CellCoordinateObjectPairArchive::set_allocated_cell_coordinate(::TSCE::CellCoordinateArchive* cell_coordinate) {
  delete cell_coordinate_;
  cell_coordinate_ = cell_coordinate;
  if (cell_coordinate) {
    set_has_cell_coordinate();
  } else {
    clear_has_cell_coordinate();
  }
}

// required .TSP.Reference object = 2;
inline bool CellCoordinateObjectPairArchive::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellCoordinateObjectPairArchive::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellCoordinateObjectPairArchive::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellCoordinateObjectPairArchive::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& CellCoordinateObjectPairArchive::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* CellCoordinateObjectPairArchive::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* CellCoordinateObjectPairArchive::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void CellCoordinateObjectPairArchive::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// -------------------------------------------------------------------

// CellCoordinateObjectMapArchive

// repeated .TSCE.CellCoordinateObjectPairArchive cell_coordinate_object_pair = 1;
inline int CellCoordinateObjectMapArchive::cell_coordinate_object_pair_size() const {
  return cell_coordinate_object_pair_.size();
}
inline void CellCoordinateObjectMapArchive::clear_cell_coordinate_object_pair() {
  cell_coordinate_object_pair_.Clear();
}
inline const ::TSCE::CellCoordinateObjectPairArchive& CellCoordinateObjectMapArchive::cell_coordinate_object_pair(int index) const {
  return cell_coordinate_object_pair_.Get(index);
}
inline ::TSCE::CellCoordinateObjectPairArchive* CellCoordinateObjectMapArchive::mutable_cell_coordinate_object_pair(int index) {
  return cell_coordinate_object_pair_.Mutable(index);
}
inline ::TSCE::CellCoordinateObjectPairArchive* CellCoordinateObjectMapArchive::add_cell_coordinate_object_pair() {
  return cell_coordinate_object_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateObjectPairArchive >&
CellCoordinateObjectMapArchive::cell_coordinate_object_pair() const {
  return cell_coordinate_object_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateObjectPairArchive >*
CellCoordinateObjectMapArchive::mutable_cell_coordinate_object_pair() {
  return &cell_coordinate_object_pair_;
}

// -------------------------------------------------------------------

// OwnerFormulaMapArchive

// repeated .TSCE.CellCoordinateFormulaPairArchive coordinate_formula_pair = 1;
inline int OwnerFormulaMapArchive::coordinate_formula_pair_size() const {
  return coordinate_formula_pair_.size();
}
inline void OwnerFormulaMapArchive::clear_coordinate_formula_pair() {
  coordinate_formula_pair_.Clear();
}
inline const ::TSCE::CellCoordinateFormulaPairArchive& OwnerFormulaMapArchive::coordinate_formula_pair(int index) const {
  return coordinate_formula_pair_.Get(index);
}
inline ::TSCE::CellCoordinateFormulaPairArchive* OwnerFormulaMapArchive::mutable_coordinate_formula_pair(int index) {
  return coordinate_formula_pair_.Mutable(index);
}
inline ::TSCE::CellCoordinateFormulaPairArchive* OwnerFormulaMapArchive::add_coordinate_formula_pair() {
  return coordinate_formula_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateFormulaPairArchive >&
OwnerFormulaMapArchive::coordinate_formula_pair() const {
  return coordinate_formula_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::CellCoordinateFormulaPairArchive >*
OwnerFormulaMapArchive::mutable_coordinate_formula_pair() {
  return &coordinate_formula_pair_;
}

// -------------------------------------------------------------------

// FormulaRewriteCommandArchive

// optional .TSP.Reference table_rewrite_command = 1;
inline bool FormulaRewriteCommandArchive::has_table_rewrite_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormulaRewriteCommandArchive::set_has_table_rewrite_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormulaRewriteCommandArchive::clear_has_table_rewrite_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormulaRewriteCommandArchive::clear_table_rewrite_command() {
  if (table_rewrite_command_ != NULL) table_rewrite_command_->::TSP::Reference::Clear();
  clear_has_table_rewrite_command();
}
inline const ::TSP::Reference& FormulaRewriteCommandArchive::table_rewrite_command() const {
  return table_rewrite_command_ != NULL ? *table_rewrite_command_ : *default_instance_->table_rewrite_command_;
}
inline ::TSP::Reference* FormulaRewriteCommandArchive::mutable_table_rewrite_command() {
  set_has_table_rewrite_command();
  if (table_rewrite_command_ == NULL) table_rewrite_command_ = new ::TSP::Reference;
  return table_rewrite_command_;
}
inline ::TSP::Reference* FormulaRewriteCommandArchive::release_table_rewrite_command() {
  clear_has_table_rewrite_command();
  ::TSP::Reference* temp = table_rewrite_command_;
  table_rewrite_command_ = NULL;
  return temp;
}
inline void FormulaRewriteCommandArchive::set_allocated_table_rewrite_command(::TSP::Reference* table_rewrite_command) {
  delete table_rewrite_command_;
  table_rewrite_command_ = table_rewrite_command;
  if (table_rewrite_command) {
    set_has_table_rewrite_command();
  } else {
    clear_has_table_rewrite_command();
  }
}

// optional .TSK.CommandArchive super = 2;
inline bool FormulaRewriteCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormulaRewriteCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormulaRewriteCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormulaRewriteCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& FormulaRewriteCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* FormulaRewriteCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* FormulaRewriteCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FormulaRewriteCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// NumberTrackedReferencePairArchive

// required uint32 number = 1;
inline bool NumberTrackedReferencePairArchive::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumberTrackedReferencePairArchive::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumberTrackedReferencePairArchive::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumberTrackedReferencePairArchive::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 NumberTrackedReferencePairArchive::number() const {
  return number_;
}
inline void NumberTrackedReferencePairArchive::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional .TSP.Reference tracked_reference = 2;
inline bool NumberTrackedReferencePairArchive::has_tracked_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NumberTrackedReferencePairArchive::set_has_tracked_reference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NumberTrackedReferencePairArchive::clear_has_tracked_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NumberTrackedReferencePairArchive::clear_tracked_reference() {
  if (tracked_reference_ != NULL) tracked_reference_->::TSP::Reference::Clear();
  clear_has_tracked_reference();
}
inline const ::TSP::Reference& NumberTrackedReferencePairArchive::tracked_reference() const {
  return tracked_reference_ != NULL ? *tracked_reference_ : *default_instance_->tracked_reference_;
}
inline ::TSP::Reference* NumberTrackedReferencePairArchive::mutable_tracked_reference() {
  set_has_tracked_reference();
  if (tracked_reference_ == NULL) tracked_reference_ = new ::TSP::Reference;
  return tracked_reference_;
}
inline ::TSP::Reference* NumberTrackedReferencePairArchive::release_tracked_reference() {
  clear_has_tracked_reference();
  ::TSP::Reference* temp = tracked_reference_;
  tracked_reference_ = NULL;
  return temp;
}
inline void NumberTrackedReferencePairArchive::set_allocated_tracked_reference(::TSP::Reference* tracked_reference) {
  delete tracked_reference_;
  tracked_reference_ = tracked_reference;
  if (tracked_reference) {
    set_has_tracked_reference();
  } else {
    clear_has_tracked_reference();
  }
}

// -------------------------------------------------------------------

// NumberToTrackedReferenceMapArchive

// repeated .TSCE.NumberTrackedReferencePairArchive number_tracked_reference_pair = 1;
inline int NumberToTrackedReferenceMapArchive::number_tracked_reference_pair_size() const {
  return number_tracked_reference_pair_.size();
}
inline void NumberToTrackedReferenceMapArchive::clear_number_tracked_reference_pair() {
  number_tracked_reference_pair_.Clear();
}
inline const ::TSCE::NumberTrackedReferencePairArchive& NumberToTrackedReferenceMapArchive::number_tracked_reference_pair(int index) const {
  return number_tracked_reference_pair_.Get(index);
}
inline ::TSCE::NumberTrackedReferencePairArchive* NumberToTrackedReferenceMapArchive::mutable_number_tracked_reference_pair(int index) {
  return number_tracked_reference_pair_.Mutable(index);
}
inline ::TSCE::NumberTrackedReferencePairArchive* NumberToTrackedReferenceMapArchive::add_number_tracked_reference_pair() {
  return number_tracked_reference_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::NumberTrackedReferencePairArchive >&
NumberToTrackedReferenceMapArchive::number_tracked_reference_pair() const {
  return number_tracked_reference_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::NumberTrackedReferencePairArchive >*
NumberToTrackedReferenceMapArchive::mutable_number_tracked_reference_pair() {
  return &number_tracked_reference_pair_;
}

// -------------------------------------------------------------------

// TrackedReferencesRewriteCommandArchive

// optional .TSCE.NumberToTrackedReferenceMapArchive references_in_reference_tracker = 1 [deprecated = true];
inline bool TrackedReferencesRewriteCommandArchive::has_references_in_reference_tracker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackedReferencesRewriteCommandArchive::set_has_references_in_reference_tracker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_has_references_in_reference_tracker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_references_in_reference_tracker() {
  if (references_in_reference_tracker_ != NULL) references_in_reference_tracker_->::TSCE::NumberToTrackedReferenceMapArchive::Clear();
  clear_has_references_in_reference_tracker();
}
inline const ::TSCE::NumberToTrackedReferenceMapArchive& TrackedReferencesRewriteCommandArchive::references_in_reference_tracker() const {
  return references_in_reference_tracker_ != NULL ? *references_in_reference_tracker_ : *default_instance_->references_in_reference_tracker_;
}
inline ::TSCE::NumberToTrackedReferenceMapArchive* TrackedReferencesRewriteCommandArchive::mutable_references_in_reference_tracker() {
  set_has_references_in_reference_tracker();
  if (references_in_reference_tracker_ == NULL) references_in_reference_tracker_ = new ::TSCE::NumberToTrackedReferenceMapArchive;
  return references_in_reference_tracker_;
}
inline ::TSCE::NumberToTrackedReferenceMapArchive* TrackedReferencesRewriteCommandArchive::release_references_in_reference_tracker() {
  clear_has_references_in_reference_tracker();
  ::TSCE::NumberToTrackedReferenceMapArchive* temp = references_in_reference_tracker_;
  references_in_reference_tracker_ = NULL;
  return temp;
}
inline void TrackedReferencesRewriteCommandArchive::set_allocated_references_in_reference_tracker(::TSCE::NumberToTrackedReferenceMapArchive* references_in_reference_tracker) {
  delete references_in_reference_tracker_;
  references_in_reference_tracker_ = references_in_reference_tracker;
  if (references_in_reference_tracker) {
    set_has_references_in_reference_tracker();
  } else {
    clear_has_references_in_reference_tracker();
  }
}

// optional .TSCE.NumberToTrackedReferenceMapArchive original_tracked_reference_copies = 2 [deprecated = true];
inline bool TrackedReferencesRewriteCommandArchive::has_original_tracked_reference_copies() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackedReferencesRewriteCommandArchive::set_has_original_tracked_reference_copies() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_has_original_tracked_reference_copies() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_original_tracked_reference_copies() {
  if (original_tracked_reference_copies_ != NULL) original_tracked_reference_copies_->::TSCE::NumberToTrackedReferenceMapArchive::Clear();
  clear_has_original_tracked_reference_copies();
}
inline const ::TSCE::NumberToTrackedReferenceMapArchive& TrackedReferencesRewriteCommandArchive::original_tracked_reference_copies() const {
  return original_tracked_reference_copies_ != NULL ? *original_tracked_reference_copies_ : *default_instance_->original_tracked_reference_copies_;
}
inline ::TSCE::NumberToTrackedReferenceMapArchive* TrackedReferencesRewriteCommandArchive::mutable_original_tracked_reference_copies() {
  set_has_original_tracked_reference_copies();
  if (original_tracked_reference_copies_ == NULL) original_tracked_reference_copies_ = new ::TSCE::NumberToTrackedReferenceMapArchive;
  return original_tracked_reference_copies_;
}
inline ::TSCE::NumberToTrackedReferenceMapArchive* TrackedReferencesRewriteCommandArchive::release_original_tracked_reference_copies() {
  clear_has_original_tracked_reference_copies();
  ::TSCE::NumberToTrackedReferenceMapArchive* temp = original_tracked_reference_copies_;
  original_tracked_reference_copies_ = NULL;
  return temp;
}
inline void TrackedReferencesRewriteCommandArchive::set_allocated_original_tracked_reference_copies(::TSCE::NumberToTrackedReferenceMapArchive* original_tracked_reference_copies) {
  delete original_tracked_reference_copies_;
  original_tracked_reference_copies_ = original_tracked_reference_copies;
  if (original_tracked_reference_copies) {
    set_has_original_tracked_reference_copies();
  } else {
    clear_has_original_tracked_reference_copies();
  }
}

// optional .TSCE.FormulaRewriteSpecArchive rewrite_spec = 3;
inline bool TrackedReferencesRewriteCommandArchive::has_rewrite_spec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackedReferencesRewriteCommandArchive::set_has_rewrite_spec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_has_rewrite_spec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_rewrite_spec() {
  if (rewrite_spec_ != NULL) rewrite_spec_->::TSCE::FormulaRewriteSpecArchive::Clear();
  clear_has_rewrite_spec();
}
inline const ::TSCE::FormulaRewriteSpecArchive& TrackedReferencesRewriteCommandArchive::rewrite_spec() const {
  return rewrite_spec_ != NULL ? *rewrite_spec_ : *default_instance_->rewrite_spec_;
}
inline ::TSCE::FormulaRewriteSpecArchive* TrackedReferencesRewriteCommandArchive::mutable_rewrite_spec() {
  set_has_rewrite_spec();
  if (rewrite_spec_ == NULL) rewrite_spec_ = new ::TSCE::FormulaRewriteSpecArchive;
  return rewrite_spec_;
}
inline ::TSCE::FormulaRewriteSpecArchive* TrackedReferencesRewriteCommandArchive::release_rewrite_spec() {
  clear_has_rewrite_spec();
  ::TSCE::FormulaRewriteSpecArchive* temp = rewrite_spec_;
  rewrite_spec_ = NULL;
  return temp;
}
inline void TrackedReferencesRewriteCommandArchive::set_allocated_rewrite_spec(::TSCE::FormulaRewriteSpecArchive* rewrite_spec) {
  delete rewrite_spec_;
  rewrite_spec_ = rewrite_spec;
  if (rewrite_spec) {
    set_has_rewrite_spec();
  } else {
    clear_has_rewrite_spec();
  }
}

// required .TSP.Reference reference_tracker = 4;
inline bool TrackedReferencesRewriteCommandArchive::has_reference_tracker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackedReferencesRewriteCommandArchive::set_has_reference_tracker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_has_reference_tracker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_reference_tracker() {
  if (reference_tracker_ != NULL) reference_tracker_->::TSP::Reference::Clear();
  clear_has_reference_tracker();
}
inline const ::TSP::Reference& TrackedReferencesRewriteCommandArchive::reference_tracker() const {
  return reference_tracker_ != NULL ? *reference_tracker_ : *default_instance_->reference_tracker_;
}
inline ::TSP::Reference* TrackedReferencesRewriteCommandArchive::mutable_reference_tracker() {
  set_has_reference_tracker();
  if (reference_tracker_ == NULL) reference_tracker_ = new ::TSP::Reference;
  return reference_tracker_;
}
inline ::TSP::Reference* TrackedReferencesRewriteCommandArchive::release_reference_tracker() {
  clear_has_reference_tracker();
  ::TSP::Reference* temp = reference_tracker_;
  reference_tracker_ = NULL;
  return temp;
}
inline void TrackedReferencesRewriteCommandArchive::set_allocated_reference_tracker(::TSP::Reference* reference_tracker) {
  delete reference_tracker_;
  reference_tracker_ = reference_tracker;
  if (reference_tracker) {
    set_has_reference_tracker();
  } else {
    clear_has_reference_tracker();
  }
}

// required .TSK.CommandArchive super = 5;
inline bool TrackedReferencesRewriteCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackedReferencesRewriteCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackedReferencesRewriteCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& TrackedReferencesRewriteCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* TrackedReferencesRewriteCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* TrackedReferencesRewriteCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TrackedReferencesRewriteCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// TrackedReferenceArchive

// required .TSCE.ASTNodeArrayArchive ast = 1;
inline bool TrackedReferenceArchive::has_ast() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackedReferenceArchive::set_has_ast() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackedReferenceArchive::clear_has_ast() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackedReferenceArchive::clear_ast() {
  if (ast_ != NULL) ast_->::TSCE::ASTNodeArrayArchive::Clear();
  clear_has_ast();
}
inline const ::TSCE::ASTNodeArrayArchive& TrackedReferenceArchive::ast() const {
  return ast_ != NULL ? *ast_ : *default_instance_->ast_;
}
inline ::TSCE::ASTNodeArrayArchive* TrackedReferenceArchive::mutable_ast() {
  set_has_ast();
  if (ast_ == NULL) ast_ = new ::TSCE::ASTNodeArrayArchive;
  return ast_;
}
inline ::TSCE::ASTNodeArrayArchive* TrackedReferenceArchive::release_ast() {
  clear_has_ast();
  ::TSCE::ASTNodeArrayArchive* temp = ast_;
  ast_ = NULL;
  return temp;
}
inline void TrackedReferenceArchive::set_allocated_ast(::TSCE::ASTNodeArrayArchive* ast) {
  delete ast_;
  ast_ = ast;
  if (ast) {
    set_has_ast();
  } else {
    clear_has_ast();
  }
}

// required uint32 formula_id = 2;
inline bool TrackedReferenceArchive::has_formula_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackedReferenceArchive::set_has_formula_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackedReferenceArchive::clear_has_formula_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackedReferenceArchive::clear_formula_id() {
  formula_id_ = 0u;
  clear_has_formula_id();
}
inline ::google::protobuf::uint32 TrackedReferenceArchive::formula_id() const {
  return formula_id_;
}
inline void TrackedReferenceArchive::set_formula_id(::google::protobuf::uint32 value) {
  set_has_formula_id();
  formula_id_ = value;
}

// -------------------------------------------------------------------

// ReferenceTrackerArchive

// required .TSCE.CFUUIDArchive uuid = 1;
inline bool ReferenceTrackerArchive::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceTrackerArchive::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceTrackerArchive::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceTrackerArchive::clear_uuid() {
  if (uuid_ != NULL) uuid_->::TSCE::CFUUIDArchive::Clear();
  clear_has_uuid();
}
inline const ::TSCE::CFUUIDArchive& ReferenceTrackerArchive::uuid() const {
  return uuid_ != NULL ? *uuid_ : *default_instance_->uuid_;
}
inline ::TSCE::CFUUIDArchive* ReferenceTrackerArchive::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == NULL) uuid_ = new ::TSCE::CFUUIDArchive;
  return uuid_;
}
inline ::TSCE::CFUUIDArchive* ReferenceTrackerArchive::release_uuid() {
  clear_has_uuid();
  ::TSCE::CFUUIDArchive* temp = uuid_;
  uuid_ = NULL;
  return temp;
}
inline void ReferenceTrackerArchive::set_allocated_uuid(::TSCE::CFUUIDArchive* uuid) {
  delete uuid_;
  uuid_ = uuid;
  if (uuid) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
}

// repeated .TSP.Reference tracked_reference = 2 [deprecated = true];
inline int ReferenceTrackerArchive::tracked_reference_size() const {
  return tracked_reference_.size();
}
inline void ReferenceTrackerArchive::clear_tracked_reference() {
  tracked_reference_.Clear();
}
inline const ::TSP::Reference& ReferenceTrackerArchive::tracked_reference(int index) const {
  return tracked_reference_.Get(index);
}
inline ::TSP::Reference* ReferenceTrackerArchive::mutable_tracked_reference(int index) {
  return tracked_reference_.Mutable(index);
}
inline ::TSP::Reference* ReferenceTrackerArchive::add_tracked_reference() {
  return tracked_reference_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ReferenceTrackerArchive::tracked_reference() const {
  return tracked_reference_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ReferenceTrackerArchive::mutable_tracked_reference() {
  return &tracked_reference_;
}

// repeated .TSCE.TrackedReferenceArchive contained_tracked_reference = 3;
inline int ReferenceTrackerArchive::contained_tracked_reference_size() const {
  return contained_tracked_reference_.size();
}
inline void ReferenceTrackerArchive::clear_contained_tracked_reference() {
  contained_tracked_reference_.Clear();
}
inline const ::TSCE::TrackedReferenceArchive& ReferenceTrackerArchive::contained_tracked_reference(int index) const {
  return contained_tracked_reference_.Get(index);
}
inline ::TSCE::TrackedReferenceArchive* ReferenceTrackerArchive::mutable_contained_tracked_reference(int index) {
  return contained_tracked_reference_.Mutable(index);
}
inline ::TSCE::TrackedReferenceArchive* ReferenceTrackerArchive::add_contained_tracked_reference() {
  return contained_tracked_reference_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCE::TrackedReferenceArchive >&
ReferenceTrackerArchive::contained_tracked_reference() const {
  return contained_tracked_reference_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCE::TrackedReferenceArchive >*
ReferenceTrackerArchive::mutable_contained_tracked_reference() {
  return &contained_tracked_reference_;
}

// -------------------------------------------------------------------

// BooleanCellValueArchive

// required bool value = 1;
inline bool BooleanCellValueArchive::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BooleanCellValueArchive::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BooleanCellValueArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BooleanCellValueArchive::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool BooleanCellValueArchive::value() const {
  return value_;
}
inline void BooleanCellValueArchive::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// DateCellValueArchive

// required double value = 1;
inline bool DateCellValueArchive::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateCellValueArchive::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateCellValueArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateCellValueArchive::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double DateCellValueArchive::value() const {
  return value_;
}
inline void DateCellValueArchive::set_value(double value) {
  set_has_value();
  value_ = value;
}

// required .TSK.FormatStructArchive format = 2;
inline bool DateCellValueArchive::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateCellValueArchive::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateCellValueArchive::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateCellValueArchive::clear_format() {
  if (format_ != NULL) format_->::TSK::FormatStructArchive::Clear();
  clear_has_format();
}
inline const ::TSK::FormatStructArchive& DateCellValueArchive::format() const {
  return format_ != NULL ? *format_ : *default_instance_->format_;
}
inline ::TSK::FormatStructArchive* DateCellValueArchive::mutable_format() {
  set_has_format();
  if (format_ == NULL) format_ = new ::TSK::FormatStructArchive;
  return format_;
}
inline ::TSK::FormatStructArchive* DateCellValueArchive::release_format() {
  clear_has_format();
  ::TSK::FormatStructArchive* temp = format_;
  format_ = NULL;
  return temp;
}
inline void DateCellValueArchive::set_allocated_format(::TSK::FormatStructArchive* format) {
  delete format_;
  format_ = format;
  if (format) {
    set_has_format();
  } else {
    clear_has_format();
  }
}

// optional bool format_is_implicit = 3 [default = true];
inline bool DateCellValueArchive::has_format_is_implicit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DateCellValueArchive::set_has_format_is_implicit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DateCellValueArchive::clear_has_format_is_implicit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DateCellValueArchive::clear_format_is_implicit() {
  format_is_implicit_ = true;
  clear_has_format_is_implicit();
}
inline bool DateCellValueArchive::format_is_implicit() const {
  return format_is_implicit_;
}
inline void DateCellValueArchive::set_format_is_implicit(bool value) {
  set_has_format_is_implicit();
  format_is_implicit_ = value;
}

// -------------------------------------------------------------------

// NumberCellValueArchive

// required double value = 1;
inline bool NumberCellValueArchive::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NumberCellValueArchive::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NumberCellValueArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NumberCellValueArchive::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double NumberCellValueArchive::value() const {
  return value_;
}
inline void NumberCellValueArchive::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional int32 unit_index = 2;
inline bool NumberCellValueArchive::has_unit_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NumberCellValueArchive::set_has_unit_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NumberCellValueArchive::clear_has_unit_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NumberCellValueArchive::clear_unit_index() {
  unit_index_ = 0;
  clear_has_unit_index();
}
inline ::google::protobuf::int32 NumberCellValueArchive::unit_index() const {
  return unit_index_;
}
inline void NumberCellValueArchive::set_unit_index(::google::protobuf::int32 value) {
  set_has_unit_index();
  unit_index_ = value;
}

// optional string currency_code = 5;
inline bool NumberCellValueArchive::has_currency_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NumberCellValueArchive::set_has_currency_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NumberCellValueArchive::clear_has_currency_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NumberCellValueArchive::clear_currency_code() {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    currency_code_->clear();
  }
  clear_has_currency_code();
}
inline const ::std::string& NumberCellValueArchive::currency_code() const {
  return *currency_code_;
}
inline void NumberCellValueArchive::set_currency_code(const ::std::string& value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void NumberCellValueArchive::set_currency_code(const char* value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void NumberCellValueArchive::set_currency_code(const char* value, size_t size) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NumberCellValueArchive::mutable_currency_code() {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  return currency_code_;
}
inline ::std::string* NumberCellValueArchive::release_currency_code() {
  clear_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_code_;
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NumberCellValueArchive::set_allocated_currency_code(::std::string* currency_code) {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_code_;
  }
  if (currency_code) {
    set_has_currency_code();
    currency_code_ = currency_code;
  } else {
    clear_has_currency_code();
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSK.FormatStructArchive format = 3;
inline bool NumberCellValueArchive::has_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NumberCellValueArchive::set_has_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NumberCellValueArchive::clear_has_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NumberCellValueArchive::clear_format() {
  if (format_ != NULL) format_->::TSK::FormatStructArchive::Clear();
  clear_has_format();
}
inline const ::TSK::FormatStructArchive& NumberCellValueArchive::format() const {
  return format_ != NULL ? *format_ : *default_instance_->format_;
}
inline ::TSK::FormatStructArchive* NumberCellValueArchive::mutable_format() {
  set_has_format();
  if (format_ == NULL) format_ = new ::TSK::FormatStructArchive;
  return format_;
}
inline ::TSK::FormatStructArchive* NumberCellValueArchive::release_format() {
  clear_has_format();
  ::TSK::FormatStructArchive* temp = format_;
  format_ = NULL;
  return temp;
}
inline void NumberCellValueArchive::set_allocated_format(::TSK::FormatStructArchive* format) {
  delete format_;
  format_ = format;
  if (format) {
    set_has_format();
  } else {
    clear_has_format();
  }
}

// optional bool format_is_implicit = 4 [default = true];
inline bool NumberCellValueArchive::has_format_is_implicit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NumberCellValueArchive::set_has_format_is_implicit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NumberCellValueArchive::clear_has_format_is_implicit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NumberCellValueArchive::clear_format_is_implicit() {
  format_is_implicit_ = true;
  clear_has_format_is_implicit();
}
inline bool NumberCellValueArchive::format_is_implicit() const {
  return format_is_implicit_;
}
inline void NumberCellValueArchive::set_format_is_implicit(bool value) {
  set_has_format_is_implicit();
  format_is_implicit_ = value;
}

// -------------------------------------------------------------------

// StringCellValueArchive

// required string value = 1;
inline bool StringCellValueArchive::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringCellValueArchive::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringCellValueArchive::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringCellValueArchive::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StringCellValueArchive::value() const {
  return *value_;
}
inline void StringCellValueArchive::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StringCellValueArchive::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StringCellValueArchive::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringCellValueArchive::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* StringCellValueArchive::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StringCellValueArchive::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSK.FormatStructArchive format = 2;
inline bool StringCellValueArchive::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringCellValueArchive::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringCellValueArchive::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringCellValueArchive::clear_format() {
  if (format_ != NULL) format_->::TSK::FormatStructArchive::Clear();
  clear_has_format();
}
inline const ::TSK::FormatStructArchive& StringCellValueArchive::format() const {
  return format_ != NULL ? *format_ : *default_instance_->format_;
}
inline ::TSK::FormatStructArchive* StringCellValueArchive::mutable_format() {
  set_has_format();
  if (format_ == NULL) format_ = new ::TSK::FormatStructArchive;
  return format_;
}
inline ::TSK::FormatStructArchive* StringCellValueArchive::release_format() {
  clear_has_format();
  ::TSK::FormatStructArchive* temp = format_;
  format_ = NULL;
  return temp;
}
inline void StringCellValueArchive::set_allocated_format(::TSK::FormatStructArchive* format) {
  delete format_;
  format_ = format;
  if (format) {
    set_has_format();
  } else {
    clear_has_format();
  }
}

// optional bool format_is_implicit = 3 [default = true];
inline bool StringCellValueArchive::has_format_is_implicit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StringCellValueArchive::set_has_format_is_implicit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StringCellValueArchive::clear_has_format_is_implicit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StringCellValueArchive::clear_format_is_implicit() {
  format_is_implicit_ = true;
  clear_has_format_is_implicit();
}
inline bool StringCellValueArchive::format_is_implicit() const {
  return format_is_implicit_;
}
inline void StringCellValueArchive::set_format_is_implicit(bool value) {
  set_has_format_is_implicit();
  format_is_implicit_ = value;
}

// -------------------------------------------------------------------

// CellValueArchive

// required .TSCE.CellValueArchive.CellValueType cell_value_type = 1;
inline bool CellValueArchive::has_cell_value_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellValueArchive::set_has_cell_value_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellValueArchive::clear_has_cell_value_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellValueArchive::clear_cell_value_type() {
  cell_value_type_ = 1;
  clear_has_cell_value_type();
}
inline ::TSCE::CellValueArchive_CellValueType CellValueArchive::cell_value_type() const {
  return static_cast< ::TSCE::CellValueArchive_CellValueType >(cell_value_type_);
}
inline void CellValueArchive::set_cell_value_type(::TSCE::CellValueArchive_CellValueType value) {
  assert(::TSCE::CellValueArchive_CellValueType_IsValid(value));
  set_has_cell_value_type();
  cell_value_type_ = value;
}

// optional .TSCE.BooleanCellValueArchive boolean_value = 2;
inline bool CellValueArchive::has_boolean_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellValueArchive::set_has_boolean_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellValueArchive::clear_has_boolean_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellValueArchive::clear_boolean_value() {
  if (boolean_value_ != NULL) boolean_value_->::TSCE::BooleanCellValueArchive::Clear();
  clear_has_boolean_value();
}
inline const ::TSCE::BooleanCellValueArchive& CellValueArchive::boolean_value() const {
  return boolean_value_ != NULL ? *boolean_value_ : *default_instance_->boolean_value_;
}
inline ::TSCE::BooleanCellValueArchive* CellValueArchive::mutable_boolean_value() {
  set_has_boolean_value();
  if (boolean_value_ == NULL) boolean_value_ = new ::TSCE::BooleanCellValueArchive;
  return boolean_value_;
}
inline ::TSCE::BooleanCellValueArchive* CellValueArchive::release_boolean_value() {
  clear_has_boolean_value();
  ::TSCE::BooleanCellValueArchive* temp = boolean_value_;
  boolean_value_ = NULL;
  return temp;
}
inline void CellValueArchive::set_allocated_boolean_value(::TSCE::BooleanCellValueArchive* boolean_value) {
  delete boolean_value_;
  boolean_value_ = boolean_value;
  if (boolean_value) {
    set_has_boolean_value();
  } else {
    clear_has_boolean_value();
  }
}

// optional .TSCE.DateCellValueArchive date_value = 3;
inline bool CellValueArchive::has_date_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellValueArchive::set_has_date_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellValueArchive::clear_has_date_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellValueArchive::clear_date_value() {
  if (date_value_ != NULL) date_value_->::TSCE::DateCellValueArchive::Clear();
  clear_has_date_value();
}
inline const ::TSCE::DateCellValueArchive& CellValueArchive::date_value() const {
  return date_value_ != NULL ? *date_value_ : *default_instance_->date_value_;
}
inline ::TSCE::DateCellValueArchive* CellValueArchive::mutable_date_value() {
  set_has_date_value();
  if (date_value_ == NULL) date_value_ = new ::TSCE::DateCellValueArchive;
  return date_value_;
}
inline ::TSCE::DateCellValueArchive* CellValueArchive::release_date_value() {
  clear_has_date_value();
  ::TSCE::DateCellValueArchive* temp = date_value_;
  date_value_ = NULL;
  return temp;
}
inline void CellValueArchive::set_allocated_date_value(::TSCE::DateCellValueArchive* date_value) {
  delete date_value_;
  date_value_ = date_value;
  if (date_value) {
    set_has_date_value();
  } else {
    clear_has_date_value();
  }
}

// optional .TSCE.NumberCellValueArchive number_value = 4;
inline bool CellValueArchive::has_number_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CellValueArchive::set_has_number_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CellValueArchive::clear_has_number_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CellValueArchive::clear_number_value() {
  if (number_value_ != NULL) number_value_->::TSCE::NumberCellValueArchive::Clear();
  clear_has_number_value();
}
inline const ::TSCE::NumberCellValueArchive& CellValueArchive::number_value() const {
  return number_value_ != NULL ? *number_value_ : *default_instance_->number_value_;
}
inline ::TSCE::NumberCellValueArchive* CellValueArchive::mutable_number_value() {
  set_has_number_value();
  if (number_value_ == NULL) number_value_ = new ::TSCE::NumberCellValueArchive;
  return number_value_;
}
inline ::TSCE::NumberCellValueArchive* CellValueArchive::release_number_value() {
  clear_has_number_value();
  ::TSCE::NumberCellValueArchive* temp = number_value_;
  number_value_ = NULL;
  return temp;
}
inline void CellValueArchive::set_allocated_number_value(::TSCE::NumberCellValueArchive* number_value) {
  delete number_value_;
  number_value_ = number_value;
  if (number_value) {
    set_has_number_value();
  } else {
    clear_has_number_value();
  }
}

// optional .TSCE.StringCellValueArchive string_value = 5;
inline bool CellValueArchive::has_string_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CellValueArchive::set_has_string_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CellValueArchive::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CellValueArchive::clear_string_value() {
  if (string_value_ != NULL) string_value_->::TSCE::StringCellValueArchive::Clear();
  clear_has_string_value();
}
inline const ::TSCE::StringCellValueArchive& CellValueArchive::string_value() const {
  return string_value_ != NULL ? *string_value_ : *default_instance_->string_value_;
}
inline ::TSCE::StringCellValueArchive* CellValueArchive::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == NULL) string_value_ = new ::TSCE::StringCellValueArchive;
  return string_value_;
}
inline ::TSCE::StringCellValueArchive* CellValueArchive::release_string_value() {
  clear_has_string_value();
  ::TSCE::StringCellValueArchive* temp = string_value_;
  string_value_ = NULL;
  return temp;
}
inline void CellValueArchive::set_allocated_string_value(::TSCE::StringCellValueArchive* string_value) {
  delete string_value_;
  string_value_ = string_value;
  if (string_value) {
    set_has_string_value();
  } else {
    clear_has_string_value();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSCE

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCE::ReferenceArchive_ReferenceType>() {
  return ::TSCE::ReferenceArchive_ReferenceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCE::SpanningDependenciesArchive_RangeContext>() {
  return ::TSCE::SpanningDependenciesArchive_RangeContext_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCE::CalculationEngineArchive_ExcelImportDateMode>() {
  return ::TSCE::CalculationEngineArchive_ExcelImportDateMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCE::ASTNodeArrayArchive_ASTNodeType>() {
  return ::TSCE::ASTNodeArrayArchive_ASTNodeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCE::FormulaRewriteSpecArchive_RewriteType>() {
  return ::TSCE::FormulaRewriteSpecArchive_RewriteType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCE::CellValueArchive_CellValueType>() {
  return ::TSCE::CellValueArchive_CellValueType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSCEArchives_2eproto__INCLUDED
